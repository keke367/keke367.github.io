<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>æ•´å‹å­—é¢å€¼çš„è¡¨ç¤ºæ–¹æ³•</title>
    <url>/2022/04/05/C++/</url>
    <content><![CDATA[<h2 id="3-1-6"><a href="#3-1-6" class="headerlink" title="3.1.6"></a>3.1.6</h2><p>iostreamæä¾›æ§åˆ¶ç¬¦endlçš„åŒæ—¶è¿˜æä¾›decã€hexå’Œoct,åˆ†åˆ«ç”¨äºæŒ‡ç¤ºcoutä»¥åè¿›åˆ¶ã€åå…­è¿›åˆ¶å’Œå…«è¿›åˆ¶æ ¼å¼æ˜¾ç¤ºæ•´æ•°ã€‚</p>
<p>ä¾‹ï¼š</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	int chest = 42;</span><br><span class="line">	int waist = 42;</span><br><span class="line">	int inseam = 42;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;chest =&quot;</span> &lt;&lt; <span class="string">chest &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	cout &lt;&lt; hex;</span></span><br><span class="line"><span class="string">	cout &lt;&lt; &quot;waist =&quot; &lt;&lt; waist &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	cout &lt;&lt; oct;</span></span><br><span class="line"><span class="string">	cout &lt;&lt; &quot;inseam =&quot; &lt;&lt; inseam &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1-8"><a href="#3-1-8" class="headerlink" title="3.1.8"></a>3.1.8</h2><p>c++å°†å­—ç¬¦è¡¨ç¤ºä¸ºæ•´æ•°æä¾›äº†æ–¹ä¾¿ï¼Œä½¿å¾—æ“çºµå­—ç¬¦å€¼å¾ˆå®¹æ˜“ã€‚ä¸å¿…ä½¿ç”¨ç¬¨é‡çš„è½¬æ¢å‡½æ•°åœ¨å­—ç¬¦å’ŒASCIIç ä¹‹é—´æ¥å›è½¬æ¢ã€‚<br>å³ä½¿é€šè¿‡é”®ç›˜è¾“å…¥çš„æ•°å­—ä¹Ÿè¢«è§†ä¸ºå­—ç¬¦ï¼ŒC++é€šè¿‡å€¼çš„ç±»å‹å¼•å¯¼couté€‰æ‹©å¦‚ä½•æ˜¾ç¤ºå€¼ä»¥åŠcinå¦‚ä½•è½¬æ¢å€¼</p>
<table>
    <tr>
        <td>è¡¨æ ¼test</td>
        <td>è¡¨æ ¼test</td>
    </tr>
    <tr>
        <td>è¡¨æ ¼test</td>
        <td>è¡¨æ ¼test</td>
    </tr>
</table>]]></content>
      <categories>
        <category>åç«¯</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/01/hello-world/</url>
    <content><![CDATA[<p>è®°å½•æˆ‘çš„ç¬¬ä¸€æ¬¡Blog</p>
]]></content>
  </entry>
  <entry>
    <title>nextä¸‹æ–°å¢åˆ†ç±»ã€æ ‡ç­¾ç­‰é€‰é¡¹å¡</title>
    <url>/2022/04/01/hexo%E4%B8%8Enext%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-ä¸»é¢˜ç›®å½•ä¸‹ä¿®æ”¹-config-yml"><a href="#1-ä¸»é¢˜ç›®å½•ä¸‹ä¿®æ”¹-config-yml" class="headerlink" title="1.ä¸»é¢˜ç›®å½•ä¸‹ä¿®æ”¹_config.yml"></a>1.ä¸»é¢˜ç›®å½•ä¸‹ä¿®æ”¹_config.yml</h2><p>ä½¿ç”¨notepad++æˆ–å…¶å®ƒå¥½ç”¨çš„æ–‡æœ¬ç¼–è¾‘å™¨æœç´¢_configæ–‡ä»¶ä¸‹menué€‰é¡¹ï¼Œå»é™¤#æ ‡ç­¾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || fa fa-tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || fa fa-th</span></span><br><span class="line">  <span class="comment">#archives: /archives/ || fa fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h2 id="2-åœ¨åšå®¢æ ¹ç›®å½•ä¸‹æ‰“å¼€git-bash"><a href="#2-åœ¨åšå®¢æ ¹ç›®å½•ä¸‹æ‰“å¼€git-bash" class="headerlink" title="2.åœ¨åšå®¢æ ¹ç›®å½•ä¸‹æ‰“å¼€git bash"></a>2.åœ¨åšå®¢æ ¹ç›®å½•ä¸‹æ‰“å¼€git bash</h2><p>ä½¿ç”¨å‘½ä»¤ï¼š</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page ******* //*å·ä¸ºä½ éœ€è¦æ·»åŠ çš„é€‰é¡¹å¡</span><br></pre></td></tr></table></figure>
<p>ä¾‹ï¼š</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<h2 id="3-mdæ–‡ä»¶æ–°å¢typeç±»å‹"><a href="#3-mdæ–‡ä»¶æ–°å¢typeç±»å‹" class="headerlink" title="3.mdæ–‡ä»¶æ–°å¢typeç±»å‹"></a>3.mdæ–‡ä»¶æ–°å¢typeç±»å‹</h2><p>åœ¨æ ¹ç›®å½•sourceæ–‡ä»¶å¤¹ä¸‹æ‰¾åˆ°å¯¹åº”é€‰é¡¹å¡æ–‡ä»¶å¤¹ï¼Œæ‰“å¼€é‡Œé¢çš„indexæ–‡ä»¶<br>åœ¨å¼€å¤´å¯çœ‹è§ç±»ä¼¼ä»¥ä¸‹æ ¼å¼å£°æ˜</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Categories</span><br><span class="line"><span class="built_in">date</span>: 2022-03-31 18:45:34</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>åœ¨ä¸‰æ¨ªçº¿åŒ…è£¹ä¸­æ–°å¢typeç±»å‹,typeç±»å‹ä¸menuä¸‹ç±»å‹åç§°ä¸€æ ·</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Categories</span><br><span class="line"><span class="built_in">date</span>: 2022-03-31 18:45:34</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>æ›´å¤šnextçš„é…ç½®å¯å‚è€ƒğŸ‘‰<a href="http://theme-next.iissnan.com/">nextå®˜ç½‘</a></p>
]]></content>
      <categories>
        <category>å‰ç«¯</category>
      </categories>
      <tags>
        <tag>é™æ€ç½‘é¡µ</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>C++å†…å­˜æ³„æ¼</title>
    <url>/2022/04/14/%E5%85%B3%E4%BA%8EC++%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<img src="../img/cpp.PNG">
å‡ºå¤„ï¼šã€ŠC++ Primer Plusã€‹]]></content>
      <categories>
        <category>åç«¯</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>æ•°ç»„ä¸æŒ‡é’ˆç†è§£</title>
    <url>/2022/04/13/%E5%85%B3%E4%BA%8EC++%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>æŒ‡é’ˆå’Œæ•°ç»„åŸºæœ¬ç­‰ä»·ï¼Œä¸ªäººè®¤ä¸ºåªæ˜¯æ•°ç»„ç±»å‹çš„åˆ›å»ºå¤šäº†ä¸€äº›è§„åˆ™ï¼Œä¾‹å¦‚sizeof(æ•°ç»„åç§°)çš„å€¼ç­‰äºæ•´ä¸ªæ•°ç»„çš„å­—èŠ‚ï¼Œä½†å…¶åç§°æŒ‡çš„ä¾ç„¶æ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ç±»å‹ï¼Œé€šè¿‡ç±»ä¼¼äºæ•°ç»„çš„æŒ‡é’ˆç®—æœ¯å¾—åˆ°ä¸åŒå…ƒç´ çš„å€¼<br>å¯¹äºæ•°ç»„ä¸­çš„å­—ç¬¦ä¸²ï¼Œç”¨å¼•å·æ‹¬èµ·çš„å­—ç¬¦ä¸²å¸¸é‡ä»¥åŠæŒ‡é’ˆæ‰€æè¿°çš„å­—ç¬¦ä¸²ï¼Œå¤„ç†çš„çš„æ–¹å¼æ˜¯ä¸€æ ·çš„ï¼Œéƒ½å°†ä¼ é€’ä»–ä»¬çš„åœ°å€ã€‚ä¸é€ä¸ªä¼ é€’å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å­—ç¬¦ç›¸æ¯”ï¼Œè¿™æ ·åšçš„å·¥ä½œé‡é›€é£Ÿè¦å°‘<br><img src=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>åç«¯</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>pygameä»‹ç»è‹±æ–‡å­—å¹•</title>
    <url>/2022/06/09/python%E2%80%94%E2%80%94pygame/</url>
    <content><![CDATA[<p>1<br>00:00:00.280 â€“&gt; 00:00:08.840<br>[Music] hello there in this tutorial we are going to be making this game however the game itself isnâ€™t really the point of the video instead it is more of a vehicle to explore pygame essentially this is an introduction to all the major components of pygame that you need to start making games in python and by the end of it you should have all the tools to approach any 2d game starting from text adventures and pong going all the way to the first generation of doom and wolfenstein games and i do plan to make more advanced games in pygame so get subscribed if you donâ€™t want to miss those and really quickly before i start you should know some python already it doesnâ€™t have to be much but i do assume that you know how to use functions and simple classes so nothing fancy but the basics of python and if you want to code along you can find all the assets in the description so i hope you enjoy alrighty so before we get into any actual code letâ€™s first talk about how video games work on a general level that is really going to help us understand what pygame does and how it actually works so how do video games work and i think the best way to think about that is to start with movies because that is the technology video games leaked off from essentially a movie is really just a ton of images playing really fast after each other so for example hereâ€™s a movie and all i have to do is to slow it down and you can see individual images although for movies these are usually called frames but itâ€™s well itâ€™s the same thing and most of the time a movie has 24 frames per second so you see 24 images per second and your eye perceives this as a moving image at least in most situations and if you do this long enough you eventually have a movie that lasts about an hour and a half and thatâ€™s essentially it the only real difference between different kinds of movies is how each individual image is being made and there are basically three different ways to approach this number one you could get a camera and just point it at something and record it number two you could draw an image or number three you could use a computer to create a 3d image and each of these approach would give you a very different look of your movie but at the end of the day all weâ€™re doing is creating lots of individual images and playing them really fast after each other and thatâ€™s literally it so with that we have movies and video games are quite similar to that and in the most basic sense a video game basically works like a movie that you have lots of individual images being played really fast after each other but obviously there need to be a couple of differences to really make all of this work number one and i guess the most important one is that on a video game each individual image isnâ€™t set in stone instead itâ€™s dynamic meaning that each individual image is created on the fly and plays dynamically depending on what the game needs so for example is the enemy in a certain position or did the player press a certain kind of button to move in a certain direction and then each individual frame is being updated automatically whereas for a movie each individual image is basically always the same so this already makes video games different that you have dynamic content and that already brings us to the second point that for video games we are checking player input which means that at the beginning of each image that we are drawing we are first checking the input from the player so we are checking if the player presses the button on the keyboard or moves the mouse or says something into a microphone lots of different things that we could be checking and then we are using that information to place something dynamically on the screen and well once we have accounted for those two differences we basically have a video game so letâ€™s give how a video game works on a conceptual level we always start by taking the player input and this is usually called an event loop so each kind of event could be a different kind of thing a player does it could also be something else for example a timer running out but essentially we are taking all the necessary inputs we need to draw the current image and once we have all that information we are actually placing all the relevant parts on the screen so we are placing the player in a certain position we are placing all the enemies we are drawing the health indicator the coin indicator whatever we really need and well once we have all of that we have one finished frame so this is one image the player is going to see now once this process is finished we are getting rid of the entire image again and starting this process from scratch and we are doing this multiple times per second usually about 30 to 60 times depending on how fast the computer is now that is really it and this applies both to 2d and 3d games so it doesnâ€™t really matter if you have a 2d image or 3d object to generate each individual frame at the end of the day you are just putting different elements together and displaying them to the player so with that letâ€™s talk about how pygame comes into this and well pygame has a couple of key functionalities that we can use to make a game and it doesnâ€™t necessarily have to be a game we could also make a movie in pi game or we could display some graphs this would also be possible so what does pygame actually do in the most basic sense pygame gives you a really good way to display images and this might be relevant if you just started with python development you might have realized that drawing anything on the screen is actually really hard and most of the time you just work with a console where you can see text but displaying actual images and animations is not that easy and this is the first thing that pygame is really good at that it helps us create a window and it helps us display images something that is well important for video games and along with that pie game can also play sounds this goes along with that quite well now the second point pygame can do well is to look for player inputs so pygame can help you get the mouse position or get keyboard inputs or even get gamepad input lots of different things that it can do and again in standard python you have the input method but this one stops the entire code if you want to get input which would break any kind of game so this would be the second important part of pygame that we can get actual player input and those are the two really important parts that pycam helps us with but there are a couple more that are general helpful things for a video game for example pygame is really good to help us with collision detection or pygm can help us create text and timers lots of things that are important for a video game but these are things you could also do in standard code but pygame has lots of ways to make it easier when it comes down to it pygame is a very simple module now thereâ€™s one important thing i do want to address that if you want to make really sophisticated games letâ€™s say a dark souls or an assassinâ€™s creed then you would not use something like pygame because it doesnâ€™t really give you too many tools for this kind of thing instead you would use a proper game engine and this would be something like unreal unity godot and there are quite a few more and the game engine has a lot of additional tools that make game developments significantly easier for example thereâ€™s gravity detection thereâ€™s support for 3d objects thereâ€™s lots of inbuilt stuff that makes game development very easy and along with that thereâ€™s also graphical user interface that allows you to place elements on the screen and you see the game as you develop it and pygame doesnâ€™t have any of that itâ€™s well not really designed for that sort of purpose so just keep that in mind now this already brings us to the first important point why would you want to use pygame over something like unreal or unity and this is actually bringing us to one of the important parts of pygame that most of the time pie game isnâ€™t used for actual game development at least for games that you want to publish instead pygame is incredibly good to learn how to code and to create systems yourself so if you only ever use a proper game engine and you have all the systems in place for you you donâ€™t really learn good programming instead you learn to rely on external tools that somebody else provides for you but if you develop all of this in py game yourself you become a much better programmer and later on if you have more experience in programming you can very easily switch to other engines and actually make professional games but to get started working in pygame is really useful because you learn very good practices and become a much better programmer so now letâ€™s actually get started in pygame and before we can start with pygame we first have to install it because pygame does not come with python automatically but installing it is super easy all you have to do is either go to the terminal or the powershell and type pip install pygame and then you should be seeing a short animation and after that you should get the message that the module was installed successfully so with that letâ€™s actually get started by creating a window in pi game so here i have an entirely empty sheet of code and the first thing i want to do is to import my game and at this stage i would already recommend to run the code here we can see we have pygame version 2.0.0 you can see our python version and then you have a hello from the pygame community and a link where you can contribute so if you can see this message you have installed pygame successfully if at this stage you get some kind of error message you probably didnâ€™t install pygame successfully so check that stage so now we have pygame how can we actually use it and well the first line we need is pygame.init and donâ€™t forget to call it thatâ€™s really important and pygame.init is incredibly important and absolutely necessary to run before any other pygmy code so pi gamma knit essentially starts pygame and initiates all the sub-parts of pygame that you need to make a game for example this init helps us render images and play sounds and stuff like that basically and while it does lots of complicated stuff you donâ€™t really have to worry about this at all all you really have to do is to call it in the first place but once you have called it itâ€™s basically good to go think of it like starting the engine of a car that when you actually do that lots of really complicated stuff happens but for you as a driver well you turn around the keys and thatâ€™s basically it thatâ€™s essentially the same principle here now on the next line we have to create what is called a display surface and a display surface is basically the window the player is going to see in the end and this we have to store in a variable that is usually called screen and to create a display surface we need pygame.display.set mode and into this set mode we have to place at the very least one argument and this has to be a tuple and this one should contain the width and the height of our game window so essentially later on when we create our window the width is going to be this part and the height is going to be this part so uh well thatâ€™s all we really need and in this case i want to go with a width of 800 pixels and a height of 400 pixels and now once we have that we can actually run the code and letâ€™s see what happens and there you could see a window for just about one frame and this is the intended behavior for now so if you get the same result you have done everything correct and let me explain why this is happening what happens right now is that we are importing pygame we are initializing pygame and we are creating a display surface but after that is done our code ends and our computer stops running this python code and as a consequence of the code ending this display surface also disappears so we are seeing it for a second because pygame is starting to run it but then closes it basically immediately afterwards and this is why we only see it for a second or so and well the solution to that is that we need to figure out some kind of way to keep our code running forever and well for that all we really need is a wild true loop so this while true loop is going to run forever for the simple reason that this condition in here is never going to be false and we have to break the while loop from the inside so basically our entire game is going to run inside of this well true loop and in here we are going to draw all our elements and also update everything so this is all going to happen inside of a while loop and there is one important line we have to add in here as well and that is pygame dot display dot update and all that bond is really doing is it updates this display surface so that anything we have drawn inside of this while loop we actually want to display to the player so we have to take it and actually put it on the display surface and this is what this line here is for so donâ€™t forget this one either but again just like with pygame.init you only really have to call it and then you donâ€™t really have to think about it that much more so all right now we could be running this code now and we would get a window that would stay open forever however please do not call the code right now because you wouldnâ€™t be able to close it by itself for the simple reason that right now we do not check for any kind of player input and one type of player input would be to close the window so keep that in mind as well that if you didnâ€™t check specifically for closing the game well the player wouldnâ€™t be able to close the game so letâ€™s add that one first and this again happens in the well true loop and really what we want to do here is to check for all the possible types of player input and this is called an event loop and more practically this is just a for loop we are looking at all the possible types of player input and see if one of them is happening right now so what we want to do is for event so all the possible events and to get the events we use pygm.event.get so this method here would get us all the events and this part here just loops through all of them thatâ€™s really all thatâ€™s happening here and for now all we want to check is if the event type we are looking for is equal to pygame dot quit so this pygame.quit here is a constant that is synonymous with the x button of the window so if the type of the event is equal to pygm.quit we are indicating what to close the window and if that is the case we want to do pygame dot quit and let me add a proper double colon and indent everything so now this is working and well now we run the code this should be working much better and now you can see the actual window and i can also close it so let me close it and weâ€™re getting an error message that we are getting the error you can see it right here that we have a pygame error video system is not initialized and let me explain whatâ€™s going wrong here whenever we call pygame.quit we are basically doing the opposite to pygame.init so these two are essentially polar opposites that pygame.net initializes all of pygame pygm.quit uninitializes everything so once weâ€™re running this code we canâ€™t display anything anymore so we couldnâ€™t for example run this method here because pygame needs to be initialized for this to be possible and basically what happens here is that we are calling this method and then we continue down our code and then python encounters this line and it canâ€™t run it so it throws an error so the problem here is that we are closing pygame but we still keep this while loop open and this is causing the problem so really what we have to do is to end this well true loop on the spot and well you could call something like a break statement in here but the most secure way to close pygame is to use the sys module and the sys module is something inbuilt into python and it gives you access to different system commands one of these commands is to close any kind of code you have opened entirely which is exactly what we want so well i want to import another module and i only want to import one specific part from it so i use from sys import exit and this exit method closes any kind of code once you call it so well i just want to do that so i call exit and once we have called this exit here this weld true loop will also be gone so then we are not calling this pygame dot update anymore and our code is just going to end so now letâ€™s try all of this again so i can still see the window if i close it now our code just finishes and we donâ€™t get an error message so this is working pretty well now with that we have a basic setup for our game although there are two more things i would like to add one is very simple the other is slightly more complex so letâ€™s start with the most simple one and well what i want to do is to give our game a title because if you check right now we just call it pygame.window so we can see it up here in the title we have pygame.window which well doesnâ€™t sound particularly good and we can update this title letâ€™s say do it right up here all we have to do is call display dot set caption and in here you have to pass in a string with the name of the game in my case i just called it runner and now if you run it again you can see runner in the top left now you could also change the icon but in my case i donâ€™t really care so much but okay this is a pretty good start now for the next part we have to talk about something really important and that is the frame rate or how fast our game is going to run and this is something really important to keep in mind so let me illustrate in a movie the speed is always the same usually 24 frames per second and this stays constant but for a video game the framerate can fluctuate quite a bit so for example if you try to run a modern game on a computer from 25 years ago you would probably only get one to two frames even at the best computer from that time and this would basically make it impossible to play that game but thereâ€™s also the other side that if you have a modern computer your computer might be able to run the game at something like a thousand or two thousand frames per second and if the game wasnâ€™t optimized to handle these kind of frame rate differences the game might run incredibly fast and this might be a problem because our animation speed depends on how fast weâ€™re updating the game so think of it like this we have a main player character and letâ€™s say we are moving him 10 pixels to the right on every single frame now if you are doing this with 1 frame per second you are moving him by 10 pixels every second now if you are doing this with 100 frames per second youâ€™re moving him a thousand pixels per second so you have a massive difference in speed and this is something we have to be able to address because you want your game to run consistently on basically any platform at least within reason and in our case we just want to keep the frame rate constant so we donâ€™t want our game to run too fast and we also donâ€™t want to run it too slow ideally we would like to run our game at 60 frames per second constantly so we have to create a ceiling and a floor for our frame rate and well creating the ceiling is very easy but creating the floor is much more difficult for the simple reason that you can just tell your computer not to run the game faster than a certain speed and if your computer can run a game at 100 frames per second you could just tell it to run slower that shouldnâ€™t really be a problem however if your computer is too slow to run the game then well you couldnâ€™t magically tell it to run faster and be more capable so to account for the minimum frame rate you just have to be a good video game developer and ensure that thereâ€™s never too much on the screen at the same time for example something that video game developers are very much concerned with but setting the maximum frame rate is very easy to do so letâ€™s actually do that so here iâ€™m back in pi game and what i want to do is to create a clock object because the clock object helps us with time and this also helps us with well controlling the frame rate and this usually put in a separate variable that i have called clock and to create a clock object we need pygame.time.clock and make sure that the c in clock is capitalized that is really important and now this is going to give us a clock object now by itself it doesnâ€™t really do anything but when we call it in our while loop we can call clock.tick and in here you can add an integer in my case 60 and this 60 is telling pygame that this wild true loop should not run faster than 60 times per second or about one while loop for every 17 milliseconds and that way our game is not going to run too fast i will illustrate later on in this tutorial how this is actually making a difference for the animation but alright so with that we have set a maximum frame rate now the minimum frame rate we canâ€™t set with one line of code we just have to make sure our game doesnâ€™t become too complex now that being said we are only going to create basic 2d games in pygame and those are basically never going to run to promise for even reasonably modern computers so we donâ€™t really have to worry about a minimum frame rate but it is something to keep in mind if you want to make more sophisticated games but alright so with all of that we finally have our basic setup for our window so obviously this still isnâ€™t great because we are not displaying anything so letâ€™s actually start working on that and letâ€™s put some basic images on our display surface so how can we actually draw anything in pygame and well to draw any kind of image we need one important concept and that is called a surface and there are two different kinds of surfaces in pie game and the one we have already seen was the display surface so a surface can just be the main window the player can see but thereâ€™s another kind of surface that we are going to use much more so let me explain if you want to display anything in pygame you essentially always put it on some kind of surface what the player is going to see at the end is anything that was put on the display surface so this is the actual window that we are going to display but to display anything on this display surface we need regular surfaces and a regular surface or just a surface is basically just an image and this image can be different kind of things it could for example be an image you have imported it could just be a plain color or it could be some kind of text these are basically the three different kinds of possibilities and then you could place a surface with some content on the display surface and that way you would actually display the regular surface i think the best way to understand this is like this imagine you want to create a really big post and present it to people the actual canvas you are putting stuff on is the display surface so this is what you are going to present at the end but by itself just having a canvas doesnâ€™t really help you all that much so instead you have to place individual post-it notes and pictures on this display surface and each individual post-it note and image is going to be a regular surface and if you place enough surfaces on the display surface at the end you are going to have something that hopefully looks quite nice so that really is all the difference here that we have to worry about but just to mention it we can only have one display surface and the display surface is always shown so we can basically never hide it however for regular surfaces we can have as many as we want thereâ€™s no limitation to it however a regular surface is only displayed if we actually put it on the display surface so you could have created a thousand surfaces unless they are specifically attached to the display surface they will not be visible so all right that was again quite a bit of theory so letâ€™s actually get into our code and letâ€™s create a basic surface and for this section i want to create three different kinds of surfaces one with a plain color one with an image that we imported and one with text and they all work by creating first the surface and then placing the surface on the display surface letâ€™s start with the simplest one to just create a surface with a plain color here iâ€™m back in my code and i want to create a new variable and letâ€™s just call this test surface so we are going to play around with this one and then later on we are going to delete it to replace it with something more proper and to just create a plane surface we need pygame dot surface and here again make sure that this s is capitalized otherwise it is not going to work and this surface is going to need a tuple with the width and the height so here we want to get width and height and this is very similar compared to what we have seen for the display surface and this is something you are going to see very often that the display surface and the regular surface have lots of things in common and this would be just one of them and in my case i want to give this surface a width of 100 and a height of 200. so now we have created a surface now the next thing we have to do is to actually display this and this is going to happen in this well true loop and let me get rid of the comments they donâ€™t really help us all that much so in the first indentation of this well true loop i want to actually attach this test surface to our display surface and this happens by first calling our display service itself and then using the blit command and blitz stands for block image transfer which is essentially a fancy way of saying you want to put one surface on another surface and in here we need two arguments we first need the surface we want to place and then the position and well the surface we already have is just our test surface and for position for now i just want to place it in position 0 and 0. and you are going to see in a second what that actually means but now letâ€™s run the code and well what we can see is that we well canâ€™t see anything and thereâ€™s a specific reason for that and the reason is quite simple actually that right now both our surfaces are plain black so this surface here is black and this surface here is black and if you put something black on something else that is black you just get more black it doesnâ€™t help you all that much so what we have to figure out is how to add color to either of these surfaces and well fortunately that is very easy to do because thereâ€™s a specific command for it and let me just run this on test surface because all we need is the fill command and in the fill command we can add a specific color and pie game has a couple of ways to add color and the simplest way is to use a couple of named arguments that are predefined for pygame and thereâ€™s a long list online that you can find that i would recommend to check out iâ€™ll put a link in the description of the video and one that we could use is just red so that we want to fill this test surface with a red color and now letâ€™s run the code and now we can actually see our red surface in the top left of the screen and now i really want you guys to think about why is this thing in the top left that is really important to understand and well i guess let me actually explain whatâ€™s happening here most importantly our main window is this display surface and is 800 pixels wide and 400 pixels high so this here would be the height and let me actually put it down here so this would be 400 and our width would be this entire width and this would be 800. so this is just the arguments we specified up here but thereâ€™s one super important thing you have to understand about this that you have to think about this window as a coordinate system think of it like in basic math where you had a coordinate system that looked something like this and on this you could have displayed a graph or something like this and the really important part of this coordinate system is that the origin point was always in the bottom left so this point was always 0 and 0. and if you wanted to go either to the left or upwards you had to increase either of these numbers now in the case of pygame this is slightly different so what you have to be aware of for pygame is that the origin point is in the top left so this point here is the point zero and zero so if you want to go to the right you still have to increase x so letâ€™s call it plus x however if you want to go downwards you have to increase y whereas in the system you learned in high school if you wanted to go downwards you had to decrease y so this is slightly different for pi game and this is also something you see in lots of other game engines and especially in the beginning unfortunately this is really confusing and you will need some time to get used to it for basically any game engine so something important to learn so this is the first thing you have to understand here that this is our origin point so now when we place something at zero and zero we are looking at this point up here now this brings us to the second point that when we have this test surface thereâ€™s one specific point we place when we place this surface and the specific point we are placing is always the top left so when we specify this 0 and 0 here we are saying essentially that we want to get the top left position of this test surface and place it right in the top left of our display surface and that way we have our surface right in the top left so this is really important to understand for pygame to understand how the coordinate system works with a bit of practice this should come quite naturally to you and letâ€™s actually do an exercise if you want to follow along that right now i donâ€™t want this surface to be in the top left anymore instead i want it to be 200 pixels from the left and 100 pixels from the top so try to implement this yourself all right welcome back so letâ€™s try to do this together now so right now we are placing the top left position in 0 and 0 which is not appropriate anymore instead i want this to be 200 pixels from the left and 100 pixels from the top and now if i run the code again we can see let me draw on this again we have this distance here is 200 pixels from the left and we have 100 pixels from the top so this is what these two numbers here illustrate and again we are placing this point here so actually this line here should have been rather right on top of that so i hope that makes sense and if you get stuck on this definitely play around with the different kind of points itâ€™s really important to understand and later on we are going to learn a specific method to help us place something more deliberately but for now this should be good to go so that way we can create a basic surface that has a plain color but obviously that still isnâ€™t all that great because well our game isnâ€™t going to consist out of plain colors instead we want to have actual images and well for that we want to import some images and well the first we need for that is to actually have some images and in my case i have a couple of folders that are in the same folder where my code is so let me open that one and in here we have our runner code and then we have three more folders we have graphics we have font and we have audio and well each of these contain what the name implies they contain so let me open graphics and there we have for example a ground and the sky these are what we are going to use in just a second but thereâ€™s also a couple of enemies and the player itself so these are the tools iâ€™m going to work with for now and i will always assume that our actual code is in the same top folder as these three other folders so when we import something we have to specify a specific path and if you want to follow along keep the same folder set up but right let me go back to the code and now i want to get rid of all of this and instead import an image and to import an image we need pygame.image.load and in here we have to specify a path and in my case i want to go into the folder called graphics and in that folder we have an image called sky and donâ€™t forget we need the file ending so my case this is dot png and well with that we have imported an image so now letâ€™s run the code again and we have our background and right now you can actually see the offset really well let me get rid of the offset entirely so i just want to place this background on position 0 and 0. we can see the actual background so this way itâ€™s super easy to import an image and one important thing to keep in mind here every time you import an image into pygame you are putting this new image on its separate surface so any kind of graphical import is going to be a new surface and in this case i guess we can call this our sky surface because we can actually keep it this one works pretty well already so sky surface and with that we have our sky and now actually this is something we can practice really well because thereâ€™s another image inside of the folder that is called ground.png and i want you guys to import this and place it somewhere in the bottom of the screen so we actually have something that looks halfway decent already so try this yourself if you want to code along letâ€™s first create a new variable that i called ground surface and to import this one we are going to need the same setup so pygame dot image to load i want to look at graphics and in there we have a file called ground.png and i guess something slightly tricky about this that this ground is not capitalized whereas this sky is and uh well thatâ€™s just my mistake sorry about that but now we have our ground surface so this is just another image and let me place this right before our sky so i again want screen.lit this time i want ground surface and for now let me place it at position zero and zero just to see what happens and another one the code we can see an error because i made a typo so this should be graphics so now letâ€™s run it again and now we can see that we canâ€™t see the background and this again is intentional so right now the problem here is that we have our sky thatâ€™s the main image we have and our ground is right behind it so our ground would basically be somewhere here ish but we canâ€™t see it because the sky image is right on top of it so it overlaps it entirely and the reason for that is that we first create our ground and then we put the sky on top of that and pygame always draws an order of when you call the code so in this case we first draw the ground and then we put the sky on top of that which doesnâ€™t really help us all that much but we can fix that very very easily all we have to do is to first draw the sky and then the ground and now we run the code again you can see the actual ground so now weâ€™re drawing the ground on top of the sky surface and okay right now we can see that our ground is way too high so we have to place it a little bit further down and well in here you can just play around with this and see what looks good letâ€™s try 300 this i think looks pretty good so with that we already have a fairly basic setup by just importing two images so with that we have basically already covered the two most basic kinds of surfaces we have a surface with a plain color and a surface with an image now thereâ€™s a third kind that you can have a surface with some text and here the really important thing to understand is that every time you want to create text you first have to create an image of the text and place that on a surface and then you place that surface on the screen and this is a slightly cumbersome process although it is quite workable but to work with text you essentially need three different steps number one you first have to create a font that stores your basic font information so the style of the font and the font size then in the next step you use that font information to create some actual text and this text is going to be on the surface and then in the third step youâ€™re placing that surface on the actual image and thatâ€™s really all you need so letâ€™s actually implement all of this so here iâ€™m back in the code and the first thing i want to do is to create a font and iâ€™m going to place this right in our starting variables but you could basically place it wherever you want and letâ€™s just call it test font for now and to create a font in pi game we need pygame.font.font and here again the first letter of the second font has to be capitalized otherwise this is not going to work and in here we have to specify two arguments the first one is the font type you want to use and the second one is the font size that we want to have and for the font size thatâ€™s the easier one itâ€™s just an integer i went with 50. and for the font type for now iâ€™m just going to use none so we are using the default font of pie game but we are going to change this in just a second so now we have a font and later on we are going to use that to display the score but for now i just want to write some basic information so we know itâ€™s working so that brings us to the second step and let me place this right below our other surfaces and in here i want to create a new surface and letâ€™s call this one the text surface and to create this surface we first need our test font and then the method render and render is going to need three bits of information number one is the text information number two if you want to anti-aliase it and number three is the color letâ€™s go through those one by one first up is the text and this one literally is just the text we want to display and in my case i am just going to call this my game for now next up is anti-aliasing and anti-aliasing basically means that we are going to smooth the edges of the text which in this case is not something we want to do because we are working with pixel art but if you are working with any text thatâ€™s not pixel art you basically always want this to be true because it makes your text look a little bit better and then finally we have our color and here again we can use the same kind of approach we have seen earlier so in this case i want to go with letâ€™s go with green this time so essentially iâ€™m going to create some text that says my game and itâ€™s green thatâ€™s really all thatâ€™s happening here and with that we have a surface so now all we have to do is to use screen dot blit again use our text surface and now place this somewhere in the middle of the screen at the top and the numbers here donâ€™t have to be specific we are learning later on a better way to place text but i know in this case our window is 800 pixels wide and 400 pixels high so i want to place this roughly at 300 from the left and 50 from the top and now letâ€™s actually run this and there we go we can see my game right in the top of the screen now obviously the font doesnâ€™t really match the rest of the game and this we can work on right now actually so right now we have the problem that we are using the default font of pygame which is none up here which well doesnâ€™t look particularly good but if we specify a specific file in here we can use a much better looking font and again if you look at the folder thereâ€™s one specific file that we can use so so all i have to do is go to font and in front we have a file called pixel type and this is a ttf file so this specifies a font and all i want to do is to import this file so i specify it in here so we have our font and then pixeltype.ttf and now weâ€™re on the code we can see a very different looking text and this one i think looks much better and i guess the green color doesnâ€™t work too well with it so letâ€™s go with black for now and yeah this is looking much better now so with that we have the three different kinds of surfaces that we can draw some text we can draw a basic color and we can also import some images and display them and this is already bringing us so much closer to an actual working game but obviously right now nothing is moving which isnâ€™t great for a game so letâ€™s actually start animating some of this and the logic to animate something in pygame is actually fairly straightforward and here again you have to remember the basic logic about video games i talked about earlier so right now we are drawing three different images our sky our ground and our text and we always place them in the same position and the important thing you really have to understand here is that we are not drawing a static image right now it just looks like a static image to us but essentially we are updating this entire image over and over again 60 times per second now the problem for us right now is that we are placing all of these images always in the same position and this is what it looks static to us but if we were to update the position of each of these surfaces we would get a moving image so really all we have to do in the most basic sense is when we use screen.blit we donâ€™t use one constant position instead we use a variable that we continuously update and once we have that we have a moving image thatâ€™s literally all it is so what i want to do in this section is to get our snail enemy and move it from the right of the screen to the left of the screen so well letâ€™s actually jump into our code and letâ€™s have a look at this here iâ€™m back in my code and the first thing i want to do is to import our snail image so let me call this snail surface and here again we need pygame.image.load and the path to the snail is graphics snail and snail one there are multiple snail images because they show an animation of the snail itself weâ€™re going to cover that later on but for now just work with snail one so this would give us our snail surface and let me actually draw this on the screen so again i want screen dot blitz i want our snail surface and letâ€™s place this about 600 pixels from the left and 250 pixels from the top so now if i run this we can see our snail so this one is already working fairly well and the problem here right now is that this is static because these two numbers are never going to change we always place the snail in the same position and well we are placing all of this always in the same position but we donâ€™t necessarily have to do that what we could do for example is create another variable letâ€™s call this snail x position and by default this is going to be 600 so i just copy this 600 and place it in here and then call snail x position so all we really did is move this 600 into a specific variable so right now if we run the code we are going to get the same result our snail is still static but now what we can do is every time this while loop is running we want to increase our snail x position by one so that every time we come to this line here our snare lacks position is going to be increased by one and if we run the code now we can see our snail moving to the right because the x position is going to be greater on every single cycle of this while loop and now if you want to move this nail to the left all we need is minus equal 1 and now our snail is going to move to the left and this is already working pretty well and well minus one is probably a bit slow letâ€™s go with four and yeah this looks like a decent speed cool but now obviously once the snail is leaving the screen this snail is going to keep on moving to the left and we will never see it again so this isnâ€™t great yet but really all we have to do to overcome this is use an if statement that if our snail exposition is too low we want to again put our snail exposition on a higher number and this is a very simple if statement and this could actually be an exercise try to figure out how you could place the snail on the right of the screen if it crosses the left side of the screen letâ€™s try together now so i want to use an if statement and i want to look at my snail x position and really i want to do is to check if this is smaller than letâ€™s say minus a hundred and if that is the case i want to get my snail x position and set it to something like 800 and now if i run the code i can still see the snail if it moves too far to the left now it reappears on the right and well really all thatâ€™s happening here is we look at this point here so about minus 100 and if our snail x position so this point here gets further to the left than that we are putting this position all the way over here so this way it looks like our snail is looping but really all weâ€™re doing is weâ€™re looking at this snail x position and we are updating it and then placing the snail in a specific part so really all we are seeing right now is that our snail is continuously updated and our brain interprets all of this as a moving image but okay and i guess now what we can actually do just to illustrate how the animation works is this clock.tick right now is at 60. but if i set it to 1 you can actually see whatâ€™s happening so now let me run the code again and now you can see the snail is just being updated a little bit further to the left every single time and weâ€™re just drawing a new image every single time and if this is slow enough it looks like well our snail is very sloppy and on the counter side if i set this to something like 600 then our snail is going to be significantly faster so because of that our frame rate is really important and we really want to make sure that this stays at least somewhat constant so all right with that we have a basic animation so this is already going pretty well now before we continue thereâ€™s one more thing i do want to show you guys and let me just comment out all the images we have drawn earlier so right now we have no sky we have no ground and we have no text the only thing we are drawing is the snail and now we run the code we get a very strange looking result and the reasons for that should make sense if you think about it for a tiny bit that right now all we are drawing is the snail and the snail doesnâ€™t cover the entire screen so every time we are updating this surface we donâ€™t really get rid of the previous frame weâ€™re just drawing on top of it and since we are not drawing on the entire surface we can still see the previous frame and as a consequence it just looks like we are stretching out something which well looks terrible so always keep in mind that you want to draw a proper background for your display surface otherwise you will be able to saw the previous frames you are drawing which looks very strange unless well itâ€™s something you actually want to achieve but okay so with that we have our basic animation and this is already looking pretty good i think and thereâ€™s one more thing i would like to talk about before we get into the next section and that is converting our surfaces so let me go to the surfaces right now we have imported three different surfaces we have our sky we have our ground and we have our snail and right now all of them used to be png files and this is fine for basic setup however ideally we would like to convert all of them into something pygam can work with more easily and this we can do very easily all we have to do is to add the line.convert after we are importing an image and this i do want to do for all of the imported images and all this really does is it converts the image to something pi game can work with more easily so our game is going to run faster thatâ€™s really all thatâ€™s going to happen here but now if i run this weâ€™re going to see something strange so now our snail is going to look well slightly weird and the problem here is that we didnâ€™t respect the alpha values so this is all the white and black stuff behind the snail and to get rid of that all we have to do is change convert to convert alpha and that way we are removing the alpha values enough around this now we can see our snail properly and you canâ€™t really see a difference however now our game should be running faster at least in theory and especially once we have more stuff on the screen this might become important although in our case it really shouldnâ€™t make that much of a difference but itâ€™s generally good practice so donâ€™t forget to add this line every time you import an image so with that i do want to start working on the player character however thereâ€™s one more really important concept we have to cover to really make the player character work and that is called a rectangle and rectangles in pygame essentially have two different functions at least in the most basic sense they can do quite a few more things but the two core functions of rectangles are this number one is that theyâ€™re helping you place a surface much more efficiently and much more precisely and number two rectangles are going to help you detect collisions something we are going to see very soon but for now i do want to focus on using rectangles to place a surface on the screen so let me explain what we are going to do right now when we place the snail we couldnâ€™t really place it precisely because we can only ever place the top left which made it very difficult to place the bottom of the snail right on the ground so ideally we would like to grab a point on the bottom of the snail and place that point which we couldnâ€™t do with surfaces by themselves but something we could do with rectangles and this is something that you see all the time in pygame that you separate placing images in two different steps the actual image information is placed on the surface but then the position information is placed in a rectangle so essentially you are splitting your image into two different variables that you then have to control together and much later on in this tutorial we are going to see the sprite class and this one combines these two so you can work with them more efficiently so then how does a rectangle work well a rectangle is a well rectangle but this rectangle has a couple of points that we can work with we can either get points that are a tuple so they have an x in the y position or we can have points that are individual positions like left and right you can see all of them on the screen right now and we can grab each of these points and either measure or move them and if we move any individual point on a rectangle we move all the other points as well so the points always stay relative to each other and then we can use a rectangle to place a surface right in the middle of the rectangle so a rectangle we could place for example in the top left or in the center on the bottom mid or on the mid right we could literally place all of these points and then we can use that information to place the surface right into this rectangle and that way we are going to have much more control over how our surface is going to be placed and later on we can also use that rectangle to detect collisions but thatâ€™s coming later for now letâ€™s just use a rectangle to place a surface so here iâ€™m back in the code and the first thing i would like to do is to import the surface of the player so letâ€™s call this for now player surface and this again we just have to go with pygame.image.load and here the path is in graphics and for this one the path is graphics player player walk1 so again we have multiple images that we are later going to use for animation but for now weâ€™re just going to use one and this again i want to use with convert alpha so itâ€™s going to run slightly faster and letâ€™s just put this on the screen so we can see it so i want to use screen dot blit again i want to place my player surface and for now letâ€™s place it letâ€™s say 80 pixels from the left and 200 pixels from the top and now letâ€™s see how it looks now we can see our player and here you can already tell that thereâ€™s a distance between the bottom of the player and the ground so this area here we want to bridge but the problem is that well we donâ€™t really know how big this area here has to be so placing just the top left of the player is very difficult and to fix that we are going to use a rectangle so step number one for this is we have to create a rectangle and there are different ways to do that so for now letâ€™s just call it the player rectangle and in the most basic sense you could create a rectangle by using pygame.rect and in here you could specify a left a top the width and the height and then this would create a rectangle however this is not something you see all that often actually because ideally you want to have a rectangle that is the exact same size as this surface and this we can create all weâ€™re going to need is our player surface so player surface and then the method get rekt so all that this get rekt does is it takes a surface and then it draws a rectangle around it and then for this rectangle we can specify a specific position where we want to place it so in here we could for example use top left and then give it an x and a y position so here for example i could copy the information from down here and just place it in there and letâ€™s just start with that so let me copy all of this and now we have a rectangle that is in the same position as our surface used to be and now when we use blit we can use a rectangle to place this surface so all i have to do in here is insert player right so now essentially what we are doing we are taking a player surface and weâ€™re placing it in the position of this rectangle so now if i run this we can see no real difference because the rectangle is in the same position where the surface used to be but what we can do for example now use a different position on this rectangle for example we could use mid left instead of top left and now if we run this our player is slightly higher or we could also use mid bottom and now our player is again in another position and really what you have to understand about this is that we are placing this point here right at the bottom of the player whereas for surface we always grab this point up here so let me draw a rough rectangle around it so for surface we always place this point but for a rectangle we can grab any of these points around it there are lots of points we can grab and that way we can have much more control over what point we want to place so this is super useful and now we can use that to place the player right on the ground and we know where the bottom of the player has to be because we know the ground is at position 300 so thatâ€™s when the ground starts so the bottom of our player has to be on this position as well so letâ€™s say for the mid bottom i want to go with 300 and now letâ€™s run this and now we can see our player is touching the bottom perfectly and here again you might be wondering that this setup is kind of tedious and time consuming so that whenever we want to place a surface and have any control over how itâ€™s going to be placed we always have to create two variables first a surface and then a rectangle and i agree it is quite cumbersome and later on in this tutorial we are going to see a sprite class and a sprite class essentially combines a surface and a rectangle and places them in one class and this makes it much easier to work with them so later on we are going to make all of this much more streamlined but for now i do want to work with them separately so you understand them better so with that we have our player rectangle and now what we can do with this player rectangle we could move every single point of this rectangle and then use that to control the surface so for example what i could be doing right in our game loop i want my player rectangle and i want to grab any individual point from it so for example i could get the left of the player and this i could either measure or move so really what i could do here for example is just move this to the right so add plus one to it and now if i run this we can see our player moving to the right so this is how you would actually move something in pygame that you donâ€™t move the surface instead you move the rectangle that contains the surface but what you can also do is you can print this information so i just want to print it and now you can see that the left of our players are position 48 so we know that this line here is 48 which can be really useful to measure different things so this is stuff that is going to be really useful but for now i donâ€™t really going to need it but something i do want to do and this could be a really good exercise for you as well is that i want you guys to update this snail that we donâ€™t just use the surface to move it instead i want you guys to place a rectangle around the snail and then influence that rectangle to move the snail so if you want to code long pause the video now and try this yourself all right letâ€™s try together now so my snail is this line here and this net exposition i donâ€™t need anymore instead i want to create a snail rectangle and let me use the surface line a bit more consistently so instead of writing surface i always write surf because itâ€™s a bit shorter and i really like to keep this a bit more consistent so faster surface i just write snail surf that makes it a bit easier to read i think but okay now to get this rectangle i want to get my snail surface again and call get wrecked on it and now again in here i have to specify a position where i want to place this rectangle and here again i could use mid bottom again but just to mix things up a bit i could use the bottom right for example although in this case it really doesnâ€™t make much of a difference and where i used to place this was at position 600 and now for the height i want to go with 300 so again the important coordinates that we have to worry about is this ground here this is where our snail has to be on top so when we specify the bottom of our snail it has to be the same position so just keep that in mind and now we just have to use that rectangle to place the snail and that happens on this line here so now instead of placing it in this one position i just want to use my snail rectangle and along with that we donâ€™t need all of this information anymore so let me get rid of it and instead i want to do all of this with a rectangle but letâ€™s first try if it works in the first place and there we go now we can see our snail right on the ground this already looks much more realistic but now i do want to move the snail and well for that all i need is my snail rectangle and then get one of the points that we want to move so here you can really pick any point you like letâ€™s say in my case i want to go with x and this i just want to move by minus equal letâ€™s say 4. and now if i run this we can see our snail moving again and now if you want to move the snail back to the right of the screen all i need is an if statement and get my snail wrecked again and here we want to measure if our snail leaves the screen so effectively what i want to know is when the right side of the snail is smaller than zero because then i know the snail has left the screen so what i want is to get the right side of the snail and check if this is smaller or equal to zero and if that is the case i want to get my snail wrecked again and now i want to place the left and this is supposed to be at position 800 because 800 is our right side of the screen itâ€™s that position up here and well with that line this snail should be working okay so letâ€™s try this now and we can see our snail moving to the left and now it reappears and this way we have much more control over the different points of our snail so this is super useful but this is essentially it when it comes to using rectangles to position surfaces it really is quite tedious especially early on but once you get used to this this is actually quite a powerful system but alright with that one we can learn about this second aspect of rectangles where they are really useful and that is collisions so what i want to do for this section is to get a collision between our snail and our player and this is actually super easily done with rectangles because all i really want to do is to check if thereâ€™s a collision between the player and the snail or the rectangles that contain them and this can be done with the collide rect method which just checks if one rectangle is colliding with another rectangle thatâ€™s really all thatâ€™s happening here so letâ€™s jump right into our code and letâ€™s implement this so here iâ€™m back in the code and all i want to do is go right to the bottom and in here i want to check if my player rack is colliding with the snail right and really all i have to do is to get my player rectangle and use collide rect and in there i have to place the other rectangle i want to check against so this would be my snail rectangle and this method returns either a zero or a one so if thereâ€™s no collision we get a zero if there is a collision between these two rectangles we are going to get a one and that information we can then use in an if statement but first let me print the entire thing so just you can see whatâ€™s actually happening here so now if we run this we can see lots of zeros but once the snail is colliding with the player we can see once then we go back to zeros then we go back two once all the way down here and this happens over and over again so we can tell that this here is returning one so this i can then use an if statement so in here you could write if this is equal to one but since python automatically converts a zero to false we donâ€™t really need that so this line here by itself is fine as well and well if that is the case let me just print collision just to see if it works and now if i run this we can see a collision once the snail is colliding with the player so we know this line here is working but thereâ€™s one thing you really want to keep in mind here that this might trigger multiple times because right now when our snail is overlapping with the player pygame checks every single frame of the game if thereâ€™s a collision or not so if we just had this line then this collision might trigger multiple times which if you have some kind of health system would be a big problem because later on we are going to end the game once thereâ€™s a single collision but if you have a hard system or some kind of health bar you really want to make sure you only have a single collision and then you have some kind of invincibility frames something lots of games actually have but in our case this kind of collision system is fine and this would be then the basics of collision now thereâ€™s a different kind of collision that you can use with rectangles and thatâ€™s collide point and this is not something we are going to use too much but it is also quite important so i do want to talk about it and all that collide point really does is it checks if one point collides with a rectangle the name should kind of make sense here and this isnâ€™t something you are going to use too often however if you ever want to click with a mouse on something then collide point is incredibly important and this is kind of why iâ€™m going to talk about it so in this section we are going to talk about collide point and using the mouse and pygame just as a small interlude weâ€™re not going to use it too much so letâ€™s go for both of these and letâ€™s first talk about politepoint we are basically calling this like collide right so we first need our rectangle and then calling this as a method but now as an argument into collide point we donâ€™t pass in a rectangle instead we have to pass in a tuple with an x and a y position and then pygame checks if this one position is inside of the rectangle or not and then it again is going to return something that we can use in an if statement so far so good but now how can we get individual points or rather how can we measure the mouse position and for that pi game has two different approaches we could either target the mouse with pygame.mouse or we could look in the event loop and check the events that check the mouse position those basically get you the same position but there are two different ways to approach it and well iâ€™m going to demonstrate both so the first one is pygame.mouse and this one gives you lots of information about the mouse for example the position or what buttons are being pressed you could also set the position of the mouse or if the mouse is visible in the first place and if you check the documentation there is quite some more stuff you could be working with but in my case i am only going to work with get pressed and get position so get the mouse buttons pressed and get the position of the mouse now besides that approach you could also use the events so when we have the event loop in there you could also work with the mouse position but that was quite a bit of talk let me actually implement all of this so here we are back in the code but now what i want to do is to check if our mouse is also colliding with the player and just to make this a bit easier to see iâ€™m going to comment this one out for just a second so we donâ€™t get too much at the same time so i again want to get my player rectangle and i want to get collide point and in here we have to pass in a tuple that has x and y positions so this is the point we want to measure if it is inside of the player rectangle and then again we can use this inside of an if statement and check and print if thereâ€™s a collision now then the important question is how do we get this x and y position so let me put this inside of a new variable that iâ€™m going to call mouse position and to get the x in the y of the most position all we need is pygame.mouse.getposs and this would give us an x and the y position that we can then use inside of this so what i want to do is to copy my mouse position and place it in here so now let me activate the mouse and now if i run the game now i can see my mouse and if i hover over the player with my mouse you can see collision so this one is already working quite well so really all we have done here is we have used this pygame.mouse and used getpost to get the position of the mouse this one should be quite straightforward now pygame.mouse has quite a few more methods that we can use and one would be get pressed so let me call this one if we are hovering over playerrec so pygame.mouse.get pressed and of course i do want to print all of that information and now we run the code again and you can again see my mouse i hover over the player and now you can see faults falls and faults and this is a boolean value for each of my mouse buttons so if i press any of the mouse buttons and let me scroll down a tiny bit here actually so now you can see all of my mouse buttons and if i press the left mouse button you can see true if i press the right mouse button you can see true on the final boolean statement and if i press the middle mouse button you can see true in the middle so this is basically which mouse button i am pressing so that way you could check if i am pressing different mouse buttons so that way you could check what the mouse position is and what buttons are being pressed so this would be one way to approach this now what we can also do in the event loop we can also access the mouse position so we want to check for a different kind of event and this would be if event dot type is equal to pygame dot mouse motion all in uppercase letters and this would give us the mouse position and this would only trigger if we move the mouse so if you donâ€™t move the mouse this is not going to give you anything but once you do have it you can print the event position so this would then give us also the mouse position and now let me run this code again now i can see my mouse again and now okay let me scroll down again now you can see wherever i move my mouse you can see the actual position so if you move to the top left you can kinda get closer to zero and zero and if i get to the bottom right you can see close to eight hundred and four hundred and well that way we can also get our mouse position so this would be another way to approach this now another thing that you could use in here is mouse button up and mouse button down so this would ever check if we are pressing the mouse button down or if we are releasing it so let me start with mouse button down and if thatâ€™s the case i just want to print mouse down so now let me run this again and let me spell all of this correctly now this works and now whenever i click we get mouse down and now if we change this to mouse button up this is only going to be triggered once we release the mouse button so let me go with mouse up and if i run this now well you canâ€™t really see it but now iâ€™m pressing the button and nothing happens only if i release the button we can see mouse up so this would be a good way to check if the button is pressed or released but this is basically all you have to know to use pygame with a mouse if you check the documentation thereâ€™s quite a bit more about small details but this is the basic and the most important stuff and letâ€™s do one small exercise to finish this part off that i want you guys to use the event loop to check if the mouse is over the player rectangle and well pause the video now and see if you can figure this out letâ€™s try together now obviously i want to work in this line here and figure out how i can use that information to check if my mouse is over the player rectangle and well the first thing i need to get is the mouse position so i want to go with mouse motion and once i have that i can print the event position so this would be the first step to approach this and this is what we have seen earlier but now what you have to be aware of that this event position is also going to give us an x and a y position so this is something we can use in collide point with a rectangle so all we have to do in here is to check our layer rectangle and then use collide point with the event position and use this in an if statement and if that is the case i want to print letâ€™s call it collision and let me disable and comment out all of this down here so we donâ€™t get confused with that line so now in theory this should print a collision and letâ€™s try this and now we can indeed see collision all right and with that we would be having our mouse collision now for now i am going to comment all of those out but we will later on revisit them to implement a proper collision for our player and our obstacles but before that thereâ€™s one more thing i would like to address and thatâ€™s the score and right now the score or my game is not really centered in the middle of the window so this is something i would like to address and well this we can also use with rectangles quite easily but along with that i would also like to highlight another functionality of rectangles because rectangles can be used to draw images on the screen but letâ€™s talk about that after we have centered the score so we go step by step so letâ€™s get started by centering the score and this again could be a challenge for you so if you want to go long try this yourself right now all right so letâ€™s try to do it together and here we have our text surface and let me put this in like a separate paragraph and again i donâ€™t want surface as a whole word i just want surf i think thatâ€™s a bit more readable so a bit further down we have our text surface here and actually i think a better way to call this would be score surface thatâ€™s making more sense so letâ€™s call this score surface sorry about the renaming i should have really thought about this earlier but never mind so now we have our surface again and the first thing i want to do is to create a rectangle so i have score rect and this is going to be our score surface and i want to get get rekt and this score rectangle i want to be right in the center of the screen and roughly in the top of the screen with a little bit of an offset between the top of the window so the point i want to place is the center and in here again we need x and y and we know our entire window is 800 pixels wide so half of that is going to be 400 and i think the original offset of 50 so the value we have specified down here should still be fine so all iâ€™m going to do is to place this 50 in here and weâ€™re good to go so all i need is 50 and then i want to get this score rectangle and place it in the score surface and now if i run this we can see my game right in the middle of the screen so this is working quite well so far we have used rectangles for two different purposes we have used them for positioning and for collisions but there is a third one that you also see fairly regularly although not as often as the first two and that is you can use rectangles to draw or at least rectangles are part of the drawing module you can use other tools to draw as well so let me explain within pygame thereâ€™s a sub module called draw and in draw you could for example pass in a rectangle and then you would be drawing this rectangle you could also be passing in a rectangle and then you would draw a circle inside the boundary box of that rectangle but you donâ€™t necessarily have to use a rectangle you could also draw a line from one point to another where you would just specify two points you wouldnâ€™t need a rectangle for that and this is also quite a useful thing to work with so how i want to illustrate this is i am going to give our score some background color so it looks a little bit nicer oh yeah and along with that we are also going to talk about colors after that but step by step so the first thing i want to do is i want to draw this score rectangle and well all i have to do for that is in the line before that i have to call pygame.draw.rect and all thatâ€™s happening here is the first help again we want to draw a certain thing with the draw module and then we want to specify what kind of shape we are drawing in this case itâ€™s going to be a rectangle but if you look at the documentation there are quite a few more shapes that you could be drawing for example a polygon or an ellipse but in my case i will just draw a rectangle and in here we have to specify three different arguments we first need the surface we want to drawn so our display surface in this case then we need a color and then the actual rectangle we want to draw so in my case this is actually quite easy so i want to start with the screen itself thatâ€™s our display surface then iâ€™m going to need a color and for now we are just going to use the default colors so letâ€™s go with pink itâ€™s going to look terrible but that doesnâ€™t matter for now and then i want to draw the actual rectangle so score rectangle and now if i run out of this we can see a pink background that doesnâ€™t actually look all that bad and in here well you can see that the background covers the text just about thereâ€™s no margin whatsoever and that isnâ€™t great and well you can work with that quite a bit more so if you go to the documentation there are quite a few more arguments that you could be passing into this the one you are probably going to see the most are width and border radius so letâ€™s specify both of those just to see how they look like so argument number four that you could pass in here but donâ€™t have to repeat with and letâ€™s just pass in is six for now and letâ€™s just see what happens and now we can see something probably slightly weird that we only get the surrounding we donâ€™t get the actual rectangle itself anymore so this is something you should be aware of when you work with this that once you specify a line width pi game stops drawing the center of the rectangle so this is a little bit annoying but now i can also specify another argument and this would be the border radius so let me put it 20 in here and now we have quite a bit of rounding but in my case i donâ€™t want to have any border rounding i just want to keep the border with so now how could you draw a rectangle that both has a border width and a center thatâ€™s colored and well all you really have to do is to copy this line and then add one without a width and one with one so now if i run this we can see that we have a bit more of a margin around the text and let me change this to a 10 and now letâ€™s try this again and this is looking marginally better not great but i would say good enough so this is something you could work with to draw different kind of shapes and letâ€™s just play around with this and this could be a really good exercise so i want you guys to look at the documentation and just draw a line from the top left of the screen to the bottom right of the screen so check out the documentation and see if you can figure this out yourself right welcome back so right now hereâ€™s the documentation and in there we have two methods that can be used with us we have pygm.draw.line and pygm.draw.antialias line or aa line and those two basically do the same thing except one line is anti-alias the other one isnâ€™t and those two for the most part are going to be identical so iâ€™m just going to work with line and if we look at this one in more detail this one is going to need five different arguments we have a surface a color a start position and end position and a width so thatâ€™s really all we need and well letâ€™s implement that so here iâ€™m back in the code and let me add a new line with pygm.draw.line and in here we are going to need five different arguments so the first one is this green or what surface we want to draw on then we need a color for now letâ€™s go with gold and then we are going to need two points so the start point and the end point and both have to be two builds and since i want to start in the top left and end it in bottom right i have to start with zero and zero so the top left and the bottom right is 800 and 400 and now i have to specify a width so letâ€™s go with 10 but you could leave out this argument but letâ€™s specify it and if we run this we can see a line going from the top left to the bottom right and even better what you could for example be doing in here is replace this with pygame dot mouse dot get pause and now what you would get is a line that always follows the mouse which is kind of cool i think but we donâ€™t really need it so let me get rid of it and letâ€™s do one more that i just want to draw a circle and this would be an ellipse and for the ellipse we would again need the surface to drawn now we need a color letâ€™s go with brown and this rectangle is going to be the bounding box for the surface and really what we can do in here is generate this surface on the fly and we could do one of the rectangles we have created earlier although what i also want to cover is that we havenâ€™t created a rectangle from scratch yet which can also be useful sometimes so what i want to do in here is pygame.rect so we are creating a rectangle right inside of the method and this is going to need four arguments we need the left argument the top the width and the height so letâ€™s place this i donâ€™t know 50 pixels from the left letâ€™s say 200 pixels from the top i want this to be a hundred pixels wide and 100 pixels high and now letâ€™s run this and now we are getting a circle or well an ellipse with an equal width and height but that doesnâ€™t really matter but we do have a problem right now that the colors donâ€™t really match up so when i open this again the black text and the pink background just donâ€™t look very good and the problem here is that for now we always rely on the predefined colors which can be okay for starting point but donâ€™t look too great so how could we specify more specific colors and there are two ways to specify colors in pygame and this also applies to basically any other program and theyâ€™re called rgb colors and hexadecimal colors and they do essentially the same thing so let me start with rgb colors all that rgb stands for is red green and blue thatâ€™s really all it means and all we are doing here is that we are specifying how much of each color we would like to have and then pie game mixes all of them together and we are getting one customized color out of that thatâ€™s really all we are doing and for each color you can choose between 0 and 255 with 0 being the absence of the color and 255 being the full color so for an rgb value we would specify a tuple with three different values one with the amount of red one with the amount of green and one with the amount of blue and for example if you had an rgb tuple with 255 0 and 0 you would have a plain red color because we would have only red and no green or blue and now for hexadecimal colors we are basically doing the same thing we just write it down in a slightly different way so we donâ€™t have a tuple anymore instead we have the hash symbol followed by six numbers and the first two numbers are for the red color the third and the fourth number are for the green color and the final two are for the blue color and then for each of these two we can specify the amount of each color we want to have and with that you basically have the same outcome as rgb now how you count how much of each color you have for this is slightly weird because the lowest possible value is 0 and 0 and the highest possible one is f and f so the counting here is slightly different if you want to read more on this i put a link in the description but essentially you are never going to create your own code instead you would use something like photoshop or some kind of website to create a color for you nobody ever really reads these things by themselves theyâ€™re not really made for that so with that we have some colors letâ€™s actually implement them and there are two colors that we are going to need one is the color for the text and the other is the color for the box behind it and iâ€™m going to use an rgb color for the text and a hexadecimal color for the box just to show you how both are going to look like and here are the two colors i am going to use so you can see what they look like so letâ€™s implement all of this so here i am back in the code and if i run out of this we can still see our pink box with the black text and letâ€™s start working on the text itself and to change the color of the text we have to work up here and we have to update the text when we create the surface and right now we are just creating a black text inside of a surface and iâ€™m going to get rid of that and instead replace it with an rgb tuple and this one is going to have 64 for all three colors so we have 64 for red 64 for green and 64 for blue which gives us a fairly darkish gray so this would then be the text and thatâ€™s really all we had to do now if i run this again now our text is looking slightly more grayed out it still doesnâ€™t look all too good because the background is pink so letâ€™s work on that one and for that i have to scroll down a little bit and now i want to change this pink here to a different kind of color and this happens with a hexadecimal string although you could also use an rgb string and in my case i have a string that looks like this and really important here do not forget the hashtag in the beginning that one is super important if you donâ€™t include that one itâ€™s not going to work but this is well itâ€™s a bluish color let me run the code and now you can see that this color of the text box is the same color as the background so this is i think the best kind of color for this and here again if you want to choose your own colors either for rgb or for hexadecimal there are loads of programs that you can be using for example in photoshop you can see both the rgb and the hexadecimal color but alright so with that we have the different colors next up i want to start working on the player and this is going to involve a couple of different steps number one is i want keyboard input and well most games are used with a keyboard so this one should be quite straightforward but what i essentially want to achieve is that if the player presses space our player is going to jump so we have to implement a jump mechanic but to implement that we are also going to need gravity so those two things are going together that you can both jump and fall at the same time but once we have that thereâ€™s one more thing that we do need and that is some kind of floor because if we can jump and fall down if we donâ€™t continuously jump our player would eventually fall into nothingness so this is then the third one we have to implement and these are three things that are kind of independent of each other so i go for them step by step and letâ€™s start with keyboard input because this should be the simplest one by now because we have already seen something similar with mouse input and keyboard input isnâ€™t all that different from that and here again we have two different ways of getting input we could either get all of the keyboard inputs with a specific method or we could use the event loop and well there isnâ€™t really all that much to talk about letâ€™s actually go straight into the code and letâ€™s implement all of this and then we are going to look at both kinds of inputs so here iâ€™m back in the code and it is already taking shape quite a bit but now what i want to do is to get all the keyboard input and letâ€™s start with the first one that we want to use the sub module called keys and to access that we need pygame dot key and in there we have a method called get underscore pressed this one is going to return an object that contains all the buttons and their current state so if they are being pressed or not and well letâ€™s just print the entire thing and see whatâ€™s going to happen and right now you can see a ton of different zeros and each of these zeros is going to stand for one button with zero meaning the button is not pressed and the one meaning the button is pressed so this is very similar compared to the mouse and that information we can use to well access the button and see if itâ€™s pressed or not and how you would usually do that let me stop all of this is you would use this kind of like a dictionary that you would first store it in a variable letâ€™s say in my case iâ€™m going to call it keys and then you can use keyword arguments to find specific buttons inside of this object so what we could for example do is look for one specific button and if you look online in the documentation you can find all the constants that represent specific keys thereâ€™s quite a long list of different things you can do the one i want to look for is called pygame dot k space which stands for the space button and this one is going to return either a 0 or 1 and that information we can again use an if statement so if that is the case letâ€™s say i want to print jump and now letâ€™s run this and let me press space and here again we can see jump so this is working pretty well so this would be one way to access all the different keys that you can have but again this we donâ€™t really want to do right now so let me comment it out and letâ€™s look at the other way because you can achieve the same thing in the event loop as well so in here and letâ€™s work on that actually and in here you have a little bit more control over what you do with the keyboard because in here you wouldnâ€™t just check for what button was being pressed instead you would go for a two-step process number one is you would first check if any button was pressed in the first place and only then would you check the specific button that was pressed and then you can do the same way with a button being released this is again kind of similar compared to what we have done with a mouse click but all right letâ€™s implement it here so i want to look for an event dot type that is equal to pie game dot key down and if that is the case for now letâ€™s just print key down and just to illustrate what we can also do we can print key up so this would be releasing the key and then we can print key up and now let me run all of this our game is still working and now let me just press a button and we can see key down on the bottom of the window and i keep the button pressed for now and this is why you canâ€™t see key up but now if i release the button now i can see key up so this way we can separate if the button is being pressed or released which can be quite useful in some instances so this would then be one way to check if a button was pressed in the first place what if i want to check for a specific key here well all we would have to do is look for the event key and this would compare with the same keyword arguments that we have seen down here so here again we could use pygame.kspace and if that is the case no i want to print letâ€™s call it jump again and now if i press space we can see jump and also key up so this one is working super well and well with that you basically have all the different ways that a player could enter information into the game so you have seen different ways to work with the mouse and also with the keyboard now and you can do this either in the event loop or you could do this inside of the game itself and now i guess thereâ€™s one question thatâ€™s been looming over input so far that why do you have two different methods in the first place why do you need that and the answer here is actually quite obvious that later on we are going to learn about classes that are ideally self-contained and this would also include input methods and for that it is super useful to have input that we can work separately from the event loop but for most of the time the event loop should be the good way to go because then we have all of our input nicely organized in one place so itâ€™s easy to work with but again this is something you are going to understand later on once you actually work with it so for now just donâ€™t worry about it too much so now we have all the input we need and i donâ€™t think thereâ€™s too much we need to practice with this so letâ€™s go straight to the next part and that is that i want to give our player the ability to jump and also to fall so what do we need for that and well the first thing that we are going to need is some kind of gravity because well our player needs to be able to fall and hereâ€™s a slight problem that we are going to have that in reality gravity isnâ€™t a linear function instead itâ€™s exponential which basically means that the more you fall the faster you fall and if that doesnâ€™t happen falling is going to look really weird it looks like weâ€™re in space so we have to create some kind of method that looks like our player is going to fall in an exponential speed which is kind of annoying to do so we are only going to imitate that weâ€™re not going to replicate it although itâ€™s something you could be doing but essentially all weâ€™re going to do is weâ€™re going to separate this process into two different parts where number one weâ€™re going to create a variable that has a gravity and this gravity is going to increase so itâ€™s just the number for now that just increases constantly and then weâ€™re going to add this number to move our player downwards and since our gravity is getting larger and larger it looks like our player is falling at a faster and faster speed itâ€™s not exponential but it starts to look quite a lot like it and especially since we are not falling that far this is not something that a player would notice and this is something you see really often in video games that game developers just donâ€™t really care about physics as long as it looks and feels good if itâ€™s actually physically accurate nobody really cares but alright that was again lots of talk letâ€™s actually implement all of this so here we are back in the code and the first thing i want to do is to create some kind of variable that tracks gravity and this let me put it right below the player so letâ€™s call this player gravity and by default this is going to be zero but now whatâ€™s going to happen in our game loop and let me separate the player a little bit and letâ€™s add a comment here so we know weâ€™re always working with the player that should organize our code a little bit better at least so before we are drawing our player i want to increase the gravity by one so player gravity plus equal one so on every single cycle of the game loop we are going to increase our gravity by a bit but right now this isnâ€™t going to do anything because this player gravity and this player rectangle are well theyâ€™re not connected so they donâ€™t influence each other whatsoever and well letâ€™s change that so what i want to do is this increase in gravity i want to use that to move the player downwards and this could actually be a really good exercise for you guys so i want you guys to use this player gravity to move the player downwards continuously so pause the video now if you want to code along and implement this yourself all we have to do is to get our player rectangle and then target one of the vertical attributes doesnâ€™t really matter which one in my case iâ€™m just going to go with y and here all we have to do is to plus equal this with player gravity and now letâ€™s try this and now we can see our player falling downwards obviously this isnâ€™t going to look too great because our player just disappears immediately but let me explain whatâ€™s happening here that at the beginning our player gravity is zero and then we add plus equals one to it so we will get one out of it and this is then what we would add to our player gravity so then our player gravity would be 301 but on the next cycle of the loop let me use a different color for that we would start with one already and we would add one towards it so now we will get to two and now if we add this to the player gravity we would get 303 so we have an increase in speed in terms of how fast we are falling down and this is going to look very much like our player is falling in real world gravity and this to our primitive brains looks like the player is falling at the natural speed although itâ€™s not real gravity so with that we have to find a counter measure that our player has to jump upwards and this is also something we can implement quite easily because right now this player gravity is moving our player downwards because itâ€™s positive but if this number were to become negative our player would move upwards and let me actually demonstrate this so when i set this player gravity right now 0 but i could set this to minus 20. another on the code we can see we have one jump because we initially move the player upwards but then weâ€™re moving it downwards at an increasing speed and this we donâ€™t want to do when we create a player gravity we only want to do when we are pressing a button so in here we want to do it and well this is then all we have to do so we have to get our player gravity and set this to negative 20. and let me get rid of key up because we are really not going to need it and now if i try this again i can see if i keep on pressing space we have a jumping player still not particularly realistic but we are definitely getting there so with that we have gravity and the ability to jump and actually on that note i also want to reactivate this mouse motion to click on the player so what i want to do in here is if the player is clicking on the player i want the player to jump as well and this could again be a good exercise for you that just implement some kind of system that if the user clicks on the player then the player jumps as well so pause the video now and try this yourself so to fix this kind of problem we have a couple of different ways to go for example we could check our most position and then check if there is a collision and we are pressing the mouse button or we could check if we are pressing the mouse button and then there is a collision and thatâ€™s basically the same result in my case i first check if the mouse button was pressed in the first case and then i checked for a collision and the different approaches here really arenâ€™t going to make a big difference although they might make a small difference and keep that in mind that if we first check for mouse button press and then we check a collision is more efficient at checking for a collision and then for a mouse button press because checking for a mouse button is much easier than checking a collision and itâ€™s not going to make much of a difference but if you have 20 or 30 of these small differences they might actually add up to a faster game so just keep that in mind for actual games that you always want to have the most efficient way to run your game which can make a difference but alright letâ€™s actually implement all of this so here iâ€™m back in the code and i first want to check for mouse button press so this is mouse button down so we check if any mouse button was being pressed and iâ€™m not going to care which mouse button so any mouse button is fine and then i actually already have all the code we are going to need so if if player collide point event pause this still works because the event position we can always check and well if thatâ€™s the case let me put it on the next line i just want to copy this code here and then add it in there and let me actually try if this is going to work this is going to be slightly difficult to do and yeah now if i click on the player we can indeed see that the player is jumping if i click on it although itâ€™s much harder to do than just pressing space alright this is indeed working so with that we have some kind of gravity and a proper jump mechanic and thereâ€™s one more thing i do want to do and that is to get rid of all of this stuff down here because we are not going to use any of those for a while and i want to keep my code clean so all right with that we have quite a bit of progress now thereâ€™s one more thing i do want to achieve that i want to create some kind of ground for the player and here you might be tempted to do something very inefficiently that you might want to check the collision between the ground and the player and anytime the player is colliding with the ground we want to move the player up and this would be possible but it also wouldnâ€™t be a good solution for the simple reason that is complete overkill that we donâ€™t really have to check for collision with the ground because we effectively only need one point and that is the point 300 on the y-axis and if the player is going below that we want to move the player on top of it so effectively we donâ€™t want to check a collision we just want to check if the player is on that point so here we are only going to simulate a collision thereâ€™s no actual collision all we really are going to do is if the player is below 300 we are going to put the player at position 300 and that way itâ€™s going to look like the player is standing but in reality it really isnâ€™t the case so here back in the code i want to add one more line before we draw the player and that is if player rect dot bottom so we check the bottom of the player is greater or equal than 300 so this position here and this is why iâ€™ve chosen 300 that the top of the ground and the bottom of the player once those two are identical of the players overlapping with the ground if that is the case i want to get my player rectangle and the bottom of it and set this to 300. so every time our players exceed in the ground we are going to set the player on top of the ground and well thatâ€™s all we have to do so now our player is going to stand and if i jump we are falling down and well the player is still standing on the ground so now it looks like thereâ€™s a collision with the ground on the player but in reality there really isnâ€™t and again this is a common thing for video games that you just simulate something that looks realistic to us but well weâ€™re not really creating the real thing because that would be really difficult to do so all right with that we are almost done thereâ€™s one more thing that we have to address and that is let me run the game again now if i keep on pressing space while we are in the air our player keeps on jumping so effectively we are flying and well this i want to get rid of and this we can do quite easily all we have to do is in these two lines we have to add one more condition that we are only able to jump if we are touching the floor and this again could be a small exercise for you so again if you want to code along try to figure this out yourself that how can we check if the player is touching the ground right so all we really have to do in here is to check if our player rectangle and the bottom of it is greater or equal to 300. effectively the same condition we have used down here and well thatâ€™s literally it and donâ€™t forget an end between the two so it works and this we have to do for both of these if statements you could also put all of this inside of an if statement it really doesnâ€™t matter but now let me run all of this again and now i keep on pressing space but the player is only going to jump if we actually touching the floor so this is then getting much closer to an actual game and in here i can almost try to play the game where we are well having almost a game nothing really happens yet if our player touches the snail but that comes next so letâ€™s talk about that part that i want to end our game if our player touches one of the snails and well we already have the collision mechanics so this is something we can already implement and letâ€™s actually do this right now so here iâ€™m back in the code and again somewhere in our game loop i want to implement a function that ends the game if our player touches the snail and let me add a comment first so we have collisions here and all i want to check for now is if our snail rectangle is collide wrecked with the player rectangle and this has to be an if statement of course and if that is the case for now i just want to end the game so i just copy those two lines and if this is working then our game should just end if these two collide so letâ€™s run all of this and we can see our game is ending once the player is touching the snail so this would kind of work and we would actually have a game at this point obviously not a very good game but this is kind of working but instead i want to do something slightly different that i have two states in my game one is the actual game we have already seen but then i want to have some kind of start screen so that if the player is colliding with an object we are coming to an overview screen where the player can see the score and press a button to start again so for that we have to figure out how can we have different states in our game and well the answer here is actually surprisingly simple that right now in our game loop we are drawing and checking certain things and all we really have to do is to put all of this inside of an if statement so for example if our game is active we want to draw all the stuff we have seen so far however once we are colliding we are setting this game active to false and then we have an else statement that draws something else thatâ€™s literally all we have to do now obviously this is a very simple setup and not particularly good for really complex games but it is the basic logic you have to understand to basically create any kind of multi-level system so letâ€™s start by implementing that one so here iâ€™m back in the code and right at the top because itâ€™s an important variable i want to create game active and this by default for now is going to be true and then further down all of the stuff we have drawn so far so literally all of this bit here we only want to do if our game is active and actually if i go further up this part here as well i only really want to do if our game is active although that we are going to work on later for now i just want to put all of this here into an if statement so iâ€™m going to indent all of it and add an if statement so if our game is active then i want to do all of this and since this game active right now is true i can run the game and we have the same outcome cool so this is still working but now what i can do is if i was nervous colliding with the player i want to set my game active to false and now if i run this and our player is colliding with this nail well nothing is going to happen anymore our game stops for the simple reason that we donâ€™t update any of this anymore but we donâ€™t draw anything on top of it so all we can really see is the last frame of this game loop but now what we could for example do is add an else statement in here and letâ€™s say for now i just want to screen dot fill and letâ€™s add yellow just to see what happens so now i use the game and now we have yellow and then here we could literally add any kind of code we want so this could be much more extensive and we are going to add quite a bit on this later on but for now this would be pretty good way to separate our game that all of this code here is going to be our actual game or the game part of our game and all the stuff down here is going to be some kind of intro or menu screen and that way we can separate our game into logical parts that are also going to be easier to work with and well with that the one thing we have left to do for this part is to set up some kind of way to restart our game and well all really have to do for that is if our game active is false we have to check for some kind of player input and if thatâ€™s the case weâ€™re going to restart the game and this is then going to bring us up here that right now we only want to check all of this if our game is active and then we want to do something else down here if the game is not active anymore and this could be a good challenge for you that if game active is false and weâ€™re pressing the space button we want to restart the game try to implement this yourself and see how far you get the first thing we have to do just like with our main code we want to put all of this inside of an if statement that if game active we are checking all of this and what we can do now is add an else statement in here and i just want to check if we are pressing the space button so let me copy this line here so right now weâ€™re checking if our key is down and we could also put these two lines here on the same line just to save some space and let me do that now so i want to check if the event type is key down and the event key is case space and if that is the case i want to get my game active and set this to true again and well letâ€™s trial of this now thatâ€™s kind of all we needed so now our game stops and now i press space and okay this kind of almost worked that right now our game goes straight back because our snail if you can see it is overlapping with the player so now it stopped and now we can play again and i can jump over the snail this is actually working really well but now i collide it again and now we go to the game over state but a problem here is if i start the game again our player is still overlapping with the snail and hence the game stops after one frame so this is something we do have to work on but at least in theory for now this is working and actually what we could be doing is we can set our snail rectangle dot left to something like 800 just to make it work for now so now letâ€™s try this again so now we go to game over and now i can start again and we have a proper working game so at this point we actually have a really working game where you have a failed state where you have a challenge itâ€™s not a very good game but well it does work so for the rest of this tutorial itâ€™s basically all about making this more interesting and making our code better organized but you really have all the basics you need to create basic games so well done so far so for the next part letâ€™s start working on the score and all i really want to display here is the amount of time the player managed to stay alive so for this one we have to figure out how to measure time and for that we are going to need a new method and that one is called pygame.time.getticks and all this one is doing is it gives us the time since we started pygame in milliseconds and that is really all we are going to need to create our timer although the actual logic to implement all of this gets a little bit more complex but we get to that when we get to that so letâ€™s go into our code and letâ€™s have a look at this so here iâ€™m in the code and right now we are creating our text right here so right now we are only displaying my game and it doesnâ€™t really do anything and further down in the game right here we are putting that text on the surface but obviously this doesnâ€™t really help us all that much so we have to make a couple of updates here and let me start by just commenting out all of this because we are going to make some changes and hereâ€™s what we want to do we want to continuously update our score which means that in our game loop we have to continuously create a new score surface and put that on the screen so that every time we are creating a new frame we are also creating some new text and to keep our code a bit more organized iâ€™m going to put all of this into its own function so here iâ€™m back in the code and i want to create a new function and letâ€™s do it right at the top and letâ€™s call this one display score we are not going to need any arguments so letâ€™s go straight into the body and the first thing we are going to need is our current time and that we are going to achieve with pygame.time.getticks and this is going to give our time in milliseconds and letâ€™s actually for now just print it and see whatâ€™s going to happen and let me actually put it into its own variables so you can work with it a bit easier letâ€™s call it current time so i just want to print my current time and now if i go down we are drawing all of our stuff in these three lines so what i want to do with them is to just comment them out for now and now letâ€™s run this and now we can see that we have a time that continuously updates at least as long as our game is active and that is our time so we can see that our game roughly ended two seconds after it started and that is information we can use very well so let me close all of this and let me go back to the top so thatâ€™s the information that we want to use and all we really have to do is to put this on a new surface and put that surface on the display surface so letâ€™s create a new variable that i call score surface and for this one we are going to need our test font and render again and in here for now all i really want to display is our current time then i needed two hour arguments which is false for anti-aliasing and then iâ€™m going to need the color which was 64 64 and 64. so now we have a new surface now with that we have to create a score rectangle and this one is just going to be our score surface with get rekt and in here the center is going to be 450 the same position we had earlier and now the final step we have to go with is screen dot blit and we want our score surface and our score rectangle and then i can get rid of our print statement and we should be good to go at least in the most basic sense and we are getting an error because this right now is an integer and this function here wants to have a string so we can approach this in a couple of ways in my case iâ€™m going to put this into an f string so that way itâ€™s going to be converted to a string anyway and now let me run all of this and you can see a score and if i keep on running the game this is still working however hereâ€™s one problem right now the game ended but now if i restart it the score has continued to increase which obviously doesnâ€™t work too well and here itâ€™s really important to understand what get ticks does and what it does is it gives us the time since pygame started or more specifically since we called pygame.init but obviously in our current setup this causes a problem because we only check the current time we donâ€™t really adjust this for restarting the game which is whatâ€™s causing the problem here so how can we adjust for this and well the answer here is kind of simple all we really have to do is when we are restarting the game we are taking the time when the game is restarting and then when we are calculating our score we are always subtracting that beginning time from our actual score and that way we are always starting from zero and going from there so letâ€™s implement that and the first thing i want to do is to create a new variable that iâ€™m going to call start time and by default this one is going to be 0. and now essentially what i want to do is when iâ€™m getting this number i want to subtract my start time from it so iâ€™m going to subtract my start time from it now right now this really isnâ€™t going to do much because we just subtract 0 from this number but now what i can do if i scroll down a bit in this bit here i am checking for keyboard input to restart the game and what i want to do in here once this is activated i want to set my start time to pygame dot time thought get ticks and that in the most basic sense is all we needed so letâ€™s try this now so a game still works properly well now i failed and letâ€™s try it again now and again we start from zero itâ€™s very hard to see because our counter starts too fast but it does work and letâ€™s try it again letâ€™s restart and this is still working pretty well so this is actually working really well cool and let me just go through what happens here now every time we are looking for our current time we are checking in this bit here our current time since the beginning of our game so since this line here has run however from that number we are going to subtract the start time so when the current iteration of our game has started so that way every time the player starts the actual game part of our game we are going to have a zero for our score and then weâ€™re adding towards that score which is then giving us a proper scoring system now thereâ€™s one more problem that right now if i run it again i think the score adds up a bit too fast and itâ€™s very hard to read so i donâ€™t really want that high of a number i want this to look more like one two three and four and so on and that could actually be a really good exercise for you try to change our current time in such a way that you get more manageable numbers now for this exercise i think it was very easy to overthink the problem which is a common issue in programming so let me explain my approach essentially this pygame.gettix gives us the milliseconds so if we add second one we would have a number of 1000. now this number i want to get to look like a one and really all we have to do for that is to subtract this thing by one thousand and that literally is all we had to do in here so what i want to do is to subtract this number by 1000 and letâ€™s put it into brackets just to be a bit more clear and what you can also do to avoid floating point numbers is to set this to an integer so this way this number here would always become a zero or one or two and that is then the number we want to go for now thereâ€™s one important thing you have to be aware of that let me copy it that right now when we set our start time this has to look the same actually let me demonstrate what happens if we donâ€™t do it so let me run the game now we get 0 1 and this is working really well but now i failed letâ€™s start again and now we get negative 5000 so this is well kind of weird and the reason for it is that this number here returns numbers in the thousands this one here returns numbers from 0 to 10 basically so thatâ€™s something to keep in mind but alright so if i add this in here now our game should be running pretty well and the score is updating properly and if our game ends and i start again we start again with zero so this is working quite well and i think i have to increase the speed of the snails thatâ€™s a bit annoying but okay iâ€™m gonna work on that in a bit thereâ€™s one more thing i would like to add and that i want to actually call this score just to be a bit more clear so now if i run this again you can see score at the top but letâ€™s well itâ€™s up to you if you want to add it now next up i think the next big issue is that our game over screen looks kind of empty so i want to add a couple of things to make it look a bit nicer which is going to end up looking like this that we have our player in the middle we have the name of the game and we have a short line at the end that tells the player how to restart the game none of this is particularly fancy and you should already be able to do most of this although thereâ€™s one more important concept i would like to add in here and that is how to transform surfaces so for example if you want to increase the size or rotate the surface thatâ€™s what transform is all about and well pygame has a transform method and if you look in the documentation this part of pygame has lots of different methods that you can use for example you can rotate something you can scale some you can flip something you can do lots of different things with surfaces now in my case all i really want to do is to scale up our player to make it look a little bit nicer but all of the transfer methods work in basically the same way so letâ€™s actually jump into this so here iâ€™m back in my code and let me minimize our display score first because weâ€™re not going to need it anymore now next up i want to create our game over screen in here and all of this our game so far we can ignore because weâ€™re not going to work on it so i am going to minimize all of this and let me also minimize the event loop so all of this is a bit easier to see and first of all i donâ€™t want this to be yellow anymore instead iâ€™m going to add a tuple that is 94 129 and 162 and actually just to test all of this iâ€™m going to set game active to false when we start our game so that way we go straight to the game over screen so letâ€™s run this and now you can see a much nicer color and again if i press space our game starts as always so this one is working pretty well cool and i guess with that we can add the player in the middle of the screen and for that i first want to import our player and let me do this right in the beginning so i already have my player variables and i want to create a new one here letâ€™s call this player stand and all we have to do in here is pygame.image.load as always and thereâ€™s one file that is just called playerstand and i am going to import is like all the other ones and iâ€™m going to convert alpha this as well and now on the next line iâ€™m going to call this player stand a rectangle and this one is just going to be player stand and get rekt and then the center is going to be right in the middle of our screen so 400 and 200 and let me actually add some comments um i think thatâ€™s a bit easier to see so letâ€™s call this intro screen now this is then what i want to display in the game over screen so all we have to do in here is to use screen dot blit and our player stand and our player stand rectangle so now letâ€™s try this and then we can see our little player this works pretty well so far so now i want to scale this one up and how would i do that and to scale something in py game we actually have a couple of different methods so if you open the documentation we have scale we have rotozoom we have scale to x and we have smooth scale and they all essentially do the same thing that they are changing the scale but they do it in slightly different ways and the result is going to look different depending on what method you are using but for now letâ€™s keep things simple so i just want to use pygame.transform.scale the simplest one i would say and if you open this one it tells you to add at very least two arguments the surface you want to scale up and then a new width and a new height both inside of a tuple and then this one is going to return a new surface and then you can use this surface like any normal surface so letâ€™s have a look at that now when i import our player stand i want to create a new player stand and just for clarity letâ€™s call this scaled and really all i want to do in here is to get my pie game transform and scale and now i am going to need a tuple with my wife and my height and unfortunately here right now i have no idea about the dimensions of our player um so letâ€™s go with random numbers letâ€™s say for the weft i want to go with 200 and for the height i want to go with 400 and well now for our player stand rect we also have to update this but all we have to do is to get a new variable so now i am simply updating this line here to get a rectangle around this new scaled surface instead of our player stand and besides that i also have to update the player stand down here to have this scaled one in there so letâ€™s do that as well so we want player stand scaled and now this should already be working so letâ€™s try it and there you can see our player is very obviously scaled up really doesnâ€™t look all that good so letâ€™s close this one but this would be one approach with scale although not a very good one and not the one i would recommend to use however before we are learning a better way to scale something thereâ€™s one more update i want to make because right now this here doesnâ€™t feel like good code because we are creating more variables than we really need to so let me update this slightly before we get into the proper bit and really all we have to do is to get rid of this scaled and then again we want to get rid of this scale as well and this scale at the bottom here and uh well thatâ€™s all we have to do so let me go for what happens here thatâ€™s kind of important to understand we are starting number one by importing this image now on the next step so this number two here we are taking the image and then updating it with this pygame.transform.scale and this one is returning a new surface and weâ€™re using that new surface to overwrite the initial surface and thatâ€™s perfectly fine to do that you take one surface you scale it and then you assign it to the variable that you originally used and then we are creating the rectangle in step number three and then in step number four you are drawing all of this so i hope that makes sense and this is something you see fairly often and also what you see fairly often is that you could just take all of this and paste it directly into the scale method and if i run this this would also still work although the downside of that is you would get one very long line that i think would be quite hard to read so iâ€™m not going to do that and i think this is a fairly good middle ground between readability and efficiency of code so iâ€™m going to go with that one however the problem now is that this scaling just doesnâ€™t look very good because it well it distorts the image a lot and there are two methods that would be better here the first one is called scale 2x and this one is a really simple scale method all it does is it takes a surface and makes it twice as large and this one works by just calling scale 2x and this one needs only one argument and thatâ€™s the surface you want to scale so now letâ€™s have a look at this and now we can see a much better player but thereâ€™s one more method that i do want to show you and that is called row to zoom and rotozoom is a more complex method because it does three different things that you have to be aware of number one it rotates the surface number two it scales the surface and number three it filters the surface and the filter here is intended to make the resulting surface a bit smoother so to make it look a bit better in some instances and to call rotozoom we are going to need three different arguments we need the surface the rotation and the scale so let me update this to row to zoom we are still going to need our player stand for angle for now iâ€™m going to go with zero and then for the scaling letâ€™s go with two and that literally is all we needed so letâ€™s run this and now we can see a surface that looks very similar although if i compare these two images side by side you can tell some very slight differences and this is because of the filtering and i actually think this rotozoom looks the best so i am going to stick with this one and actually what you can also do with rotozoom you can change the angle so if i change this to for example 90 we would also get a rotated surface so this is a very easy way to both scale and rotate something and still have the resulting surface look quite good but i donâ€™t want to rotate it so this one is perfectly fine by itself so alright with that we have learned about the basics of influencing a surface now next up we do have to add a couple of lines of text so we do have to add the name of the game the score and the instructions to start the game and this could actually be a really good exercise for you that try to implement all of this yourself and see how far you get but at this point you know all the tools to make this work so here we are back in the code and i am going to go to our intro screen and in here i just want to create a new variable called game name and for this one we need our test font.render again and now we have to specify the name of our game and i just called this one pixelrunner but well give it whatever name you want then for ntl youâ€™re saying i want false and for the color i go with one one one one nine six and one six nine so with that we would have the surface of our text next up we would need our game name rectangle and this one is just going to be game name dot get wrecked and this i want to place at position 400 and 130 so in the middle of the screen slightly to the top and that is all we needed to get the name of the game so now in our game over loop we have to draw all of this so we just need screen dots blitz then game name and game name rectangle and now letâ€™s see and that is a little bit too far down so let me go up again and letâ€™s put this to letâ€™s go with 80. and that is looking much better all right so with that we have the name of the game in there everything else still works just the same cool and now iâ€™m going to add a second bit of text and this one is going to pull double duty if thereâ€™s no score it is just going to tell press space to run however if there is a score it just shows the score and to implement all of that all we really need is an if statement that cycles between two different text surfaces so letâ€™s start with the first text and this i called game message and this again we need to test font.render and test font really isnâ€™t a good name but i guess now weâ€™re stuck with it and this is press space to run then i want false again and now for the text color i just want to copy the text we had above so with that we have our surface and now i want my game message rectangle and this one again is going to be game message dot get wrecked and here once more i want to place the center and now in here i want to put it in the middle and no for the y position letâ€™s go with 320 letâ€™s see if that one is going to work and well now again we have to go with screen dot blit i called this game message and game message rect and letâ€™s see if this one is working and it does not letâ€™s see what went wrong here oh and the reason is that i have the wrong rectangle so this should be game message wrecked there we go this is much better and i think i could move this text slightly further down so letâ€™s go with 340. now this one is again and uh okay tiny bit higher so now the last thing that we have to do is to add some kind of if statement that we only show the text if thereâ€™s no score and if there is a score we donâ€™t want to show the game message instead we want to show the score and for that we do have to make a couple of changes so let me go through them one by one and i think itâ€™s best to explain it first and then we get into it so right now we are keeping all of our score instead of the update score function which works fine by itself but we want to access the score to display it in our game over screen so we have to get the current time variable inside of the update score function and for that we could either create a global variable or we could return the value and both would be okay iâ€™m going to go with the return statement but once we have that all we have to do is to put this current time on its own surface and then display it thatâ€™s literally all we have to do so letâ€™s go back in the code and letâ€™s have a look at this so here iâ€™m back in the code and right now the variable that we have to access is this current time here because that effectively is our score so how can we access this we could either go with global current time [Music] to make it accessible everywhere or what we could also do is after this function is run we can return current time and this is the one iâ€™m going to go with because itâ€™s a bit more focused so now that we have that i can create another variable letâ€™s call it score and this by default is going to be zero however now every time our update or display score is going to run this score is going to get the value of whatever is being returned by this display score which is going to be our actual score so this way we can access the value of our score basically any time so now what we have to do in the game over screen we have to turn this into a surface and well this is going to work in exactly the same way as before so i create a new variable letâ€™s call it score message and this one again i want my test font.render and in this case i want to go with an f string that says your score and then we put our actual score in there then again we need false and for the color i am just going to copy this same one again and then after that you should know this by now really well we want to turn this into a rectangle or we want to put a rectangle around it rather so i want score message dot get rekt and for the center iâ€™m going to go with 400 400 and 330 so now this is going to give us our score and now this score i only want to print when there actually is a score so when we are starting the game this isnâ€™t visible however as soon as we have a score all of this is going to replace this game message here and well to achieve all of that all we need is an if statement so if our score is equal to zero we know we donâ€™t have a score yet and then i want to display my game message and if that is not the case so else i want to go with screen dot blitz and score message and score message wrecked and well letâ€™s try so i can run the game we can still see our basic setup now let me run it now we get a score of 2 and there we can see it so now every time we have a score we can see it and this is looking really well then so i can also jump over snail or i canâ€™t and now we get a score of four so this one is indeed working very nice and let me just update them ever so slightly to put them on the same line because that feels better cool so all right with that we have all the text that we are going to need so with that letâ€™s work on another really important topic to make the game look better and that is to spawn different kinds of obstacles so right now we only ever have a snail and i want to mix this up a tiny bit that we have a chance to ever get a snail or a fly so the player has to make a choice between jumping or well not jumping and this is going to be a really good opportunity to work on something a bit more complex to spawn our enemies because right now this is a bit overly simplistic that we donâ€™t really spawn multiple enemies instead we have a snail we keep on moving from the right to the left and then we just place it back to the right and the problem here is that we have very little control for example we donâ€™t have control how fast the snail is moving and we also donâ€™t really have control over how often itâ€™s spawning so itâ€™s always the same interval which is kind of boring and to update it we are going to need one new concept and that is a timer so that we can tell pygame to run a certain kind of code in certain time intervals and this timer is going to be quite simple because all we really are going to do is to create a new user event thatâ€™s triggered by pygame and so far all of our user events were something the player is doing but that doesnâ€™t necessarily have to be the case because a user event could also be triggered by pygame and a timer is one of those instances where we tell pygm to trigger a user event at certain intervals which is what a timer really is and there are three steps to doing all of this number one we have to create a custom user event number two we have to tell pygm to trigger this user event at a certain interval and then number three we have to add code in our event loop to do something when this event is being triggered but that is all we needed so letâ€™s actually implement this so here i am back in the code and let me add a new section with a comment letâ€™s call it timer and in here i want to have an obstacle timer and all we need to create a custom user event is pygame dot user event all in uppercase letters and here one important thing is to add plus one the reason for it is that there are some events that are already reserved for pygame itself and to avoid a conflict with those we always have to add plus one to each event we are going to add and if you want to read more on that thereâ€™s quite a bit more in the documentation on this but by itself thatâ€™s all we need here so this would be step number one that we have created a custom user event now what we have to do is to trigger this event in certain intervals and this happens with pygame.time.set underscore timer and this is going to need two different arguments number one the event we want to trigger and number two how often we want to trigger it in milliseconds so in my case i want to trigger my obstacle timer and i want to trigger this every 900 milliseconds so a bit shy of one second but with that we have a timer so now in my event loop i want to go all the way to the bottom and here we are going to add a new event so here if event dot type is equal to obstacle timer and if that is the case for now letâ€™s just say print test and now letâ€™s run it and we can see test just about every second so this one is already working pretty well so with that we have a timer and i guess one thing we can add already here that we only want to run this if our game is active because if itâ€™s not active we donâ€™t have to spawn an enemy so now letâ€™s trace again now we canâ€™t see anything and if i run the game we can see test every just about one second cool so now we have a timer but how can we use that timer to work with our obstacles and well here we have to make quite a few changes so let me explain this first and then we are going to implement it but before that let me go down a tiny bit i want to get rid of this snail movement we had so far because this one is not going to be needed anymore so letâ€™s talk about how all of this is going to work now first of all we have to create a list that is going to contain all the rectangles of the obstacles and every time our timer triggers we are going to add a new rectangle into this list and then on every single cycle of our game loop we are going to move every single rectangle inside of that list a little bit further left and if any of these rectangles goes too far to the left we are going to delete it and that way we can continuously create new enemies and move them to the left and if they get too far to the left we just make them disappear so ultimately a fairly simple idea so letâ€™s implement it so here iâ€™m back in the code and right now we have all of our enemies in here or our one enemy right now and let me add a section here as well letâ€™s call it obstacles just to keep the code a bit more organized and all i want to do in here is to get an obstacle wrecked list and right now this is just going to be an empty list and now when we go to our timer so down here all i want to do is to get this obstacle racklist and append something new and what i want to append is the rectangle and this we already have so this is going to be this rectangle here so i can just copy it and paste it in here although we have to make one update that right now this 600 needs to be higher so it just snails outside of the screen and i want to have a value between 900 and 1100 and for that we are going to need a random number so letâ€™s import one so at the top i want from random import rand and this is just going to give us a random integer between two boundaries and that is exactly what i needed so now in here all i want is to get my rent int and this is supposed to be between 900 and 1100 so that way the snail is going to be spawned slightly to the right of the screen and then we are moving it further to the left so this is then going to give us our list but obviously right now nothing is going to move so to fix that we have to create a function that takes care of all of that and well let me put it somewhere in our game active loop and letâ€™s put it right after the player so letâ€™s call it here obstacle move mint it doesnâ€™t really matter where you put it just whatever makes the most sense to you and in here i want to create a new function that is called obstacle movement and in here i want to add one argument and that is the obstacle rack list so we know exactly what we are working with and well letâ€™s create this function so at the top of the code i want to create obstacle underscore movement and in there we need an obstacle list and now we have to work with this list however we first have to check if thereâ€™s something in the list in the first place and that we can just do if obstacle list so this here is going to work because python if it finds an empty list is going to evaluate that to false so if our list is empty this if statement is not going to run but if it is going to run we want to cycle through all of our rectangles inside of that list so letâ€™s call it for obstacle rect in obstacle list and then we want to move with every single of these obstacles so obstacle rect letâ€™s call it dot x minus equal and now we have to define a certain kind of speed letâ€™s say i want to go with five and that way every single obstacle would be moved to the left by a tiny bit on every cycle of our game loop so this is exactly what we needed but right now obviously you canâ€™t see any of this so this is something i also want to put right inside of here although you could also place it in a separate function but in my case iâ€™m going to be a little bit lazy but all i want to do here is screen dot blit and for now i just want to get my snail surface and then go with my obstacle rect so that way we are moving our rectangle and drawing the surface in the same position all in one go but right now we have a little bit of a problem that right now all the stuff inside of this function here is going to be a local variable and we want to make sure that we are targeting the global scope and really all we have to do to fix that is after we have done all of this we are returning a new list so the list we just created so return obstacle list and then in our game loop when we do all of this here i want to get my obstacle right list and overwrite it so let me explain what happens here we first run this function here and this is going to take our obstacle rack list and move every single rectangle inside of it a bit further to the left and after thatâ€™s finished we are going to take this new list and overwrite the previous list and that way we can continuously update our list and not worry about scope in too much detail right so letâ€™s try all of this and we are getting an error and the reason for it is that python told us that non-type has no attribute append and you might already be able to figure out what went wrong here and let me explain basically if we run this in the beginning thereâ€™s nothing inside of this obstacle list because our timer hasnâ€™t triggered yet and as a consequence this entire thing is going to return none and none doesnâ€™t have the append method so what we have to do if thereâ€™s nothing inside of this list we have to else return an empty list thatâ€™s not an empty list thatâ€™s one and that way our append method should still work so now letâ€™s try this and let me run this and now we can see our snails obviously theyâ€™re all way too fast right now or the collision doesnâ€™t work anyway but now you can already tell that some of these snails move slightly differently because we have changed the starting position so cool this is already working and i guess what we can do is that this 900 is probably a bit low letâ€™s go with a thousand four hundred letâ€™s try this now and letâ€™s see uh potentially still a little bit fast but i think this is kind of workable um okay letâ€™s go with 1500 so with that we have a slightly more robust system to work with our obstacles but there are a couple of problems with this and let me go through them one by one number one the one problem we have already seen is that our collisions do not work anymore so thatâ€™s one thing we have to work on number two is right now when our obstacle leaves the screen we donâ€™t delete it so we are going to end up with a longer and longer obstacle rack list something we really want to avoid because it would eventually slow down our game and number three is we only have one type of enemy so thatâ€™s also something we have to work on so letâ€™s start with number two that we want to delete a rectangle if the rectangle goes too far to the left and this we can do inside of our function so inside of this function we want to check if any of these rectangles is going too far to the left so if this number here goes to letâ€™s say lower than negative 100 and if thatâ€™s the case we want to kill it and all of that we can achieve fairly easily with list comprehension so what i want to do is to get my obstacle list and assign it a new list already and this list comprehension is going to check all of our rectangles and then see if theyâ€™re too far to the left so all we have to do in here is to go obstacle for obstacle in obstacle list so this right now would only copy the existing list so it wouldnâ€™t do all that much however what we can do now is we only want to copy an item if obstacle dot x is greater than zero so that way we are only going to copy an existing item in the list if x is greater than zero so that way we are only going to copy every single item of the list if the condition is true that the x attribute is greater than zero so if the obstacle is on the screen and if that is not the case we are not going to copy the item and the item is going to disappear and actually let me go with minus 100 so we know that the obstacle is off the screen for sure so this would already be the first problem we had to target that we wanted to delete the rectangles if they leave the screen so with that letâ€™s go to the next point that right now we only have one type of obstacle which really isnâ€™t looking all that good so instead i want to have two different kinds of obstacle and if you check out the folder there are two different types we have a snail and a fly and i want to randomly spawn either a snail or a fly and this isnâ€™t very difficult to achieve but it does need a couple of steps to work through it so let me explain it while i implement it i think that is going to be the best way to approach this so all right let me minimize the function we are not going to need it for a bit and instead in my rectangles i want to import a new variable and letâ€™s call this fly underscore surface and this is just going to be pygame dot image dot load and the path towards this fly is going to be graphics.fly.fly1 again we have several images to get an animation we are going to cover that very soon but next up i need convert alpha and that is all we needed oh and actually i just realized this snail rectangle we donâ€™t need anymore so all right now we have our fly surface and now we have to add this to our obstacle rack list so right now we always add the fly towards this and here we want to randomly assign either the snail or the fly however there is going to be a problem that the fly cannot be on the same y position so while the snail is on position 300 the fly has to be higher up because itâ€™s well flying so we canâ€™t just add a random statement in here but we can overcome this fairly easily because all we have to do is to run an if statement that randomly triggers either true or false and in my case iâ€™m going to use rand in to do this so here we have rent in from 0 to 2 and this is going to give us a value thatâ€™s either 0 or 1 and 0 would evaluate to false and 1 would evaluate to true so that way we have an if statement and randomly triggers true or false and if it is true i want to create a snail and if itâ€™s not true i want to create a fly so let me just copy this entire line here and now i want to get my fly surface and the x position for that is still perfectly fine but what i want to change is the y position because this one has to be high up and in my case i went with 210. so this way would be slightly higher up and now letâ€™s actually run this and see whatâ€™s going to happen itâ€™s not going to work perfectly just yet oh and weâ€™re getting an error because this snail rect.left shouldnâ€™t be in there anymore now letâ€™s try this again and we are getting another error somewhere down here oh but we have the collision so this one should also go because we donâ€™t need it anymore and i hope now itâ€™s working there we go so now we can see a snail we can see another snail and now we can see a flying snail um i guess that also kind of works so the problem here now is that we always draw the surface of the snail on top of the screen and that would be a problem so let me go to the part in the code in our function that right now it doesnâ€™t really check in our function if we are drawing a fly or a snail we are always drawing our snail and this is something that we have to change so we have to figure out in this function if the obstacle rectangle is for a fly or for a snail and the problem here is that the rectangle by itself has no information if it belongs to a snail or to a fly it is literally just a rectangle of a size and a position but that information we can use because we know it at the bottom of the snail is at position 300 and the bottom of the fly is at position 210 so really all we are going to do in here is if the bottom of the rectangle is at position 300 we are going to draw a snail and if it is not the case we are going to draw a fly and that way we are going to draw only this surface thatâ€™s appropriate so let me cut this out here for now and i want to get an if statement that if obstacle rect.bottom is equal to 300 and if that is the case i want to draw my snail and if that is not the case i want to draw my fly surface and i guess again i can put them all on one line that tends to make it look a bit cleaner and now letâ€™s try all of this again now we get a snail and now we get a fly cool so this is working pretty well oh yeah i donâ€™t actually have to jump it still works just fine and uh we are getting a lot of snails but we do get the odd fly eventually cool so let me remove a bit of the white space here and now we can close our function and never think about it again so with that we have different kinds of obstacles now the final thing i want to work on is a collision between the obstacles and the player and this i want to put in a whole new function because that i think is going to make the most sense but really all that we are going to do in here is we are going to check the player and the obstacle rack list and if the player is colliding with any of the rectangles inside of that obstacle rack list then we want to end our game and that is going to work in a very similar way compared to the obstacle movement function that we are just going to use a for loop to get every single rectangle inside of the list and then on every single rectangle we are going to call collide rect so let me start by creating a new function so letâ€™s call this collisions i guess that kind of works and in here i want to have two arguments first one is the player and then i want to have the obstacles and in here again i first want to check if there are obstacles in the first place so if obstacles very similar compared to what we have done earlier so let me actually open both functions so right now this one here is pretty much the same thing we have done up here now next up i want to cycle through every single rectangle inside of this list so for obstacle underscore act in obstacles and now i want to check if any of these obstacles is colliding with the player so if player dot collide rect with the obstacle rectangle and if that is the case i want to do a certain thing and now we have to figure out what certain thing i want to do and here let me explain the problem that right now we have all of our code inside of this function in the local scope so all of this here is the local scope but the problem with that is that we let me go down a tiny bit that here again we have our global scope and the problem is that this game active controls if our game is active or false and this game active is in the global scope so we have to work out how to get from a local scope to the global scope and well here again iâ€™m just going to use a return statement so iâ€™m just going to return false so as soon as our player collides with any of the rectangles this value is going to return false and all of this here runs without doing anything then we want to return true and now all we have to do is to either assign this return false or return true to gameactive.false to gameactive in our game loop so all i have to do is to go down to my game loop and in here we still have our collisions let me put it below there and there i want game active and this is going to get collisions collisions this one and here the two arguments we are going to need is our player rectangle and we are going to need our obstacle rect list and that should be all we needed so now letâ€™s run this and letâ€™s see if this is working and yeah there we go so now our game is going to end if we collide with any of the obstacles and just to explain what happens here that this collisions can either return true or false if thereâ€™s a collision with an obstacle it is going to return false so this game active here is going to become false and we are going to the else statement because this game active all the way to the top is not true anymore however if that is not the case and no collision triggers this collision here is going to return true so this game active stays true and we just keep on going back to game active so that way we have a proper collision mechanic however now we have one more problem and let me run the game again and let me just collide with one of the snails and never run the game again we still have to snail in the same place so this is crashing our game immediately to account for that when our game is over i want to empty our obstacle reckless and well all we need is to get our obstacle rack list and clear it so that way we are going to so that way we are removing every single item inside of it and now letâ€™s try this again and now we crashed and now letâ€™s rerun the game and now the game restarts properly so this is working quite well cool and actually while we are in here there are two more things i would like to add number one is i want to put my player rectangle at the bottom again so dot mid bottom is going to be 80 and 300 the same positions we have specified earlier so that way the player is always going to start at the bottom of the screen so for example if we jumped into a fly at the end of the game and crashed because of that our player would restart at the bottom so that i think makes it look a bit better and along with that my player gravity should also be zero so that way we start at the bottom and donâ€™t fall any further it just makes the game a little bit cleaner so alright with that we have made pretty good progress that now our game has multiple types of obstacles and everything else is still working just the same cool now with that we can start addressing something slightly more complex and that is to animate the fly the player and the snail so that we donâ€™t have a static image instead we have an animated image that looks significantly better however to achieve that we are going to need a couple of different things but in the most basic sense we donâ€™t really do anything complicated so let me explain what we are going to do in the most basic sense all we are going to do is to update the surface we are putting on the screen every few milliseconds so for example for the snail sometimes we are drawing one image and sometimes we are drawing an other image and these images are very very similar but slightly different and if you put them together fast enough it looks like the snail is actually slivering walking moving well moving in an animated way whatever you want to call it and all we really have to figure out is how to update the surface every few milliseconds and this can be done in a couple of different ways as a matter of fact our player animation and our obstacle animation works in different ways for our player animation weâ€™re going to create a random timer that updates on every single cycle of the game loop and if that number becomes too large we are going to change the image we are going to placing on the screen and for our obstacles we are going to create a new timer so that we are changing every few milliseconds what kind of surface we are going to put on the rectangles and that again was me talking way too much letâ€™s actually look at this in code and letâ€™s start with the player i think thatâ€™s going to be the easier one so here we are back in the code and the first thing i have to do is to import a couple more images because thatâ€™s what we need for animation so if i scroll down a bit in this part here we have imported the player image so far which is player walk one and what i want to do for now is to import more and put all of this into a list so let me rename a couple of things first of all this isnâ€™t supposed to be player surf anymore this is supposed to be player walk 1 or underscore 1. then i want to copy the entire thing and have player walk 2 and this is going to be the other image so our play has walk 1 and walk 2 and if you play those two fast after each other you have a walking animation and those two surfaces i want to place into a list that i call player walk and this is literally just a list with player walk 1 and player walk and then besides that i also want to import a file that i called player jump and this is just going to be another surface so let me copy the entire import line this is just going to be jump.png and with that we have a surface that we want to display when our player is jumping and when our player is walking i want to alternate between these two different surfaces but thereâ€™s one more variable that we are going to need and let me place it right under the player walk list and iâ€™ve called this one player index and by default this is going to be zero and what this number is going to be is later on weâ€™re going to use it to pick either this surface here or this surface here and i have just realized that this should be player walk one and player work two so basically this player index is what we are going to change to pick either the first work surface or the second work surface and we donâ€™t need that for player jump because we only have one surface for the jumping and we can actually start using our player index right away because right now we need a player surface to get the player rectangle and this i just want to get back with player serve and when we start the game i just want to go with player walk and from that i want my player in this one so all this one right now is going to do because it is zero it is going to pick the first player walk surface so right now we havenâ€™t really accomplished anything we just imported a couple more images that donâ€™t really do too much right now so to actually make all of this work we have to create a function and let me go all the way to the top and create a new function here and i have called this one player underscore animation spelled correctly really helps and in here we want to do a couple of things we want to play walking animation if the player is on floor or we want to display the jump surface when player is not on floor so yeah i hope that makes sense and this player animation i want to call in our main game loop so all the way down here letâ€™s say we can place it right before we bled the playerâ€™s surface that kind of makes sense i think so now we have to create this function properly and the first thing we have to do is to declare a couple of global variables because we want to work very much outside of this function and the two variables that we need is player surface and player index so we want to work with this player index here and this player surface those are the only two that we really have to influence from inside of the function okay so with that we first have to figure out if the player is on the floor or not so that we can either display a jumping animation or walking animation and well this is literally just an if-else statement so if player rectangle dot bottom is letâ€™s say smaller than 300 then i want to show the jump animation and if that is not the case i want to show the walk animation and in here the jump animation isnâ€™t actually animation itâ€™s just the surface that we are displaying so all we have to do here is to set our player surface to our player jump i start to have a ton of variables but this is literally all we have to do to get the jump animation so if our player is not touching the floor or is above this y position we are just displaying the jump image so thatâ€™s literally it but now for the walking animation this gets a little bit more complicated because in here we want to alternate between work surface 1 and work surface 2 at a fairly slow speed and this i want to do with the player index so the variable we cleared earlier so i want to first target that one so player index and i just for now just want to add not one but 0.1 so i want to slowly increase this number and let me explain what iâ€™m actually going to do so letâ€™s say here we have our list with our two work surfaces so we have w1 and w2 short for walk one and walk two and by default walk index is going to be zero and let me use a different color for this actually so by default this walk index is going to be right here because itâ€™s zero and then i donâ€™t want to jump straight to the next frame to walk two because thatâ€™s going to be too fast instead i want to increase walk index only by smaller increments so it takes a couple of frames to get to work to which will be our index one this is why iâ€™m only adding 0.1 but if i were to add 1 here we would straight jump to the next walk cycle but that would be too fast instead i just want to go much slower so i hope that makes sense so with that what i want to do now is to get my player surface again and just look at my player walk list and from there i want to take the index of the integer of player in dex for the simple reason that we can only take the index with an integer and this would already kind of work with the simple problem that we would very fast run out of this list so this number here would go to one and then would go to two then we go to three and so on but our list so this player walk only has two elements zero and one so what we want to do is after we reach one we want to go back to zero so we have to add a bit more code to make sure that we get this border here that we donâ€™t cross and this is fortunately very easy to achieve all we need is an if statement between these two that if our player index is greater or equal than the length of our player walk and if that is the case i want to set my player index back to zero and that is literally all the logic we needed for this thing to work and we are already calling the function so letâ€™s actually trial of this so it still works and now we have a walking animation and now if i jump we have a jumping animation so this is working really well let me just go through this really quickly again i think this needs a bit of explanation so when we are starting our game we are simply picking the first item here from our player walk animation so we just get one of the walking animation however now in our game loop further down here before we blit the player we are running our player animation and if i look at this this player animation looks at a couple of different things first of all it looks if the player is on the ground or not so here the first line or the first if statement if the player is not on the ground or smaller than position 300 we want to change the playerâ€™s surface so the player image to play a jump and this way we give the illusion that the player is jumping because we changed the image but thatâ€™s literally all thatâ€™s happening here however if that is not the case so if the player is on the floor we want to show either walk one or walk two and to get these two surfaces we use player index and increase this number very slowly and if this number gets too large so with this if statement here we are setting it back to zero and then we use that to animate the player although animate here literally just means we have a pick walk 1 or walk 2. thatâ€™s really all thatâ€™s happening here but alright with that we have our player animation cool now next up i want to animate all of the snails and all of the flies and for this we have a minor problem that for the player we only had to worry about a single surface but we have lots of flies and snails on the screen so animating all of those with this method would be a little bit annoying however we can approach this slightly differently and what weâ€™re actually going to do is use a timer both for the snails and for the flies and essentially all weâ€™re going to do is weâ€™re going to create a timer that runs pretty fast so itâ€™s going to trigger multiple times per second and every time it triggers weâ€™re going to change all of the surfaces for either the flies or the snails each of those have their own separate timer and well thatâ€™s all we need letâ€™s actually have a look at this so here iâ€™m back in the code and let me first import a couple more images so for the snail we have snail serve letâ€™s call this snail frame 1 and i want snail frame 2 as well and this is literally just going to be snail 1 and snail 2. and then for the fly we have the same thing we have frame 1 and then we have frame 2 and it probably is going to make sense to separate them a bit more consistently so this is going to be snail and this is going to be fly and in here we have to do the same thing we did for the player so we want a list with all the different frames so this would be snail frame one and snail frame two and then the same for the fly so fly frames is going to be a list with fly frame 1 and fly frame 2 and then both are also going to be needing an index so letâ€™s call it snail frame index and by default this one is also going to be 0. so fly frame index going to be zero as well and then finally we are going to need a default snail so i call this one snail surface and all we need here is our snail frames and then snail frame index and then the same for the fly so fly surface and this is going to be our fly frames and fly frame index so this is pretty much the same thing we did for the player you can actually see it right below and we could update each of these flies and snails in the same way we updated the player although this would be kind of annoying because we would have to do it for every single fly or snail on the screen so thatâ€™s not great so instead iâ€™m going to create a couple more timers so here we have our timers and i want to create a couple more so the first one is the snail animation timer and iâ€™m really bad at spelling animation i realized and this is going to be pygame dot user event plus two and then we need pygm.time.settimer and here we have our snail animation timer and for the snail i went with letâ€™s say 500 and now we need this same thing for the flies so let me just copy all of this and this is going to be our fly animation timer itâ€™s going to be plus and this one have set to 200 because i think the fly should animate a bit faster than the snail and now if i go down a bit i just want to add a couple more if statements for um updating these timers and first of all i want to check if our game is active because i only want to do this if the game is actually running as a matter of fact letâ€™s make some changes here so i realized when we call our obstacle timer we already check if game is active so i just want to take this out here and check all the timers only if our game is active so if game is active then i want to run the obstacle timer and i also want to check if event.type is equal to letâ€™s start with the snail animation timer snail animation time this one and all i have to do in here is to change our snail frame index either to zero or to one depending on what we need for the animation so if our snare frame index is zero i want it to be one and if itâ€™s one i want it to be zero and this is literally a very simple if statement so if our snail frame index is equal to zero then i want my snail frame index to be one and if that is not the case then i want my snail frame index to be zero and once i have all of this information i want to get my snail surface again and i want my snail frames and pass in there my snail frame index so this way every time this timer is running we are updating all of the surfaces for the snail so once this timer is running we are going to update all of the snail frames and well thatâ€™s all we have to do and now we have to do the very same thing for the fly and i havenâ€™t done an exercise in quite a while so letâ€™s do one now that i want you guys to create a timer for the fly and this is going to work in exactly the same way as we did for the snail so if you want to go long pause the video now and try this yourself alrighty so letâ€™s copy all of our snail timer and really all i have to do is to change snail to fly so we have this fly we have this flight this is going to be a fly frame index this is also going to be fly from index then this is a fly and two more to go we have fly here and we have fly here and already so this is done all we needed for the fly animation timer and now once we have that letâ€™s try to run the code and itâ€™s still running thatâ€™s a good sign and now you can see animations for the snails and i hope i get a fly soon there we go the flies are not animating so letâ€™s have a look at those and i have found the error if we go up right now we call for both timers the snail animation timer so whenever we actually call the fly animation timer i just made a typo but thatâ€™s very easy to fix fortunately because this needs to be fly animation timer and now letâ€™s start off this again and letâ€™s hope i get a fly fairly soon and there we go now we have flies that also animate and this is making the entire game look much more realistic and much more well animated cool so with that we have our animation and this is another major step towards the good looking game so with that we basically have a working game but there are two more things we really want to add to this number one is music and adding music in pie game is super simple the only reason i havenâ€™t done this is because i donâ€™t want to have music in the background every time i run the game but you could add the entire music in a couple of lines of code thatâ€™s not the problem however thereâ€™s one more topic i really want to cover thatâ€™s fundamental to pygame but unfortunately this is going to be quite a large topic so this is going to be a larger section that is going to change our code quite substantially and that is going to be the sprite class and the sprite class you see all the time in our code so far we havenâ€™t really used any kind of class but it might be really useful for example for our player we have lots of different code snippets throughout our code to make our player work but if we wanted to make changes to the player it would be kind of annoying to do because we constantly have to look around our code to find different things we want to work on and our code is still very simple so if you get a more complex game this sort of setup would be a nightmare to maintain and it would be a much better idea to have all of our player in one player class so this would contain all the surfaces the rectangle the player input all the animations all of that stuff basically anything for the player is in one class and pygame is fully aware of that and thatâ€™s why the sprite class exists because all it really is is a class that has a surface and a rectangle and these are being drawn automatically in the right spot and this makes it very easy to work with all of this and in our code more specifically i want to change a couple of things into its own separate class most importantly our player is going to be its own class however i also want each fly and each snail to be its own sprite as well and this would be the most common way to organize this sort of game and well that is what we are going to implementing before we work on the music and this is going to be a larger section so well letâ€™s go through it slowly and i explain why i implement it thatâ€™s probably going to be the best so all right here we are back in the code and let me give some space right at the top and i want to create a class and letâ€™s call it player and this player has to inherit from another class thatâ€™s called pygame.sprite.sprite and make sure you get the capitalization right so this second sprite here has to be uppercase and next up we have to create an init method so whenever this class is created we want to do something and this needs the usual self and in here the first line thatâ€™s very easy to forget we need super and then the dunder ended as well so that we are initializing the sprite class right inside of this class as well so we can access it and this class is now going to need two attributes at the very minimum one is called self.image and the other is self.rect and the image is the surface that is going to be displayed by default and direct as well the rectangle to figure out where itâ€™s going to go so we need self.image and self.rect so in here what you could be doing for example is use pygame.image.load and load for example our player walk 1 and we still need to convert the alpha of it and then for the self.rectangle we could get our self.image and then get wrecked again and in here let me for now just place the mid bottom at position letâ€™s go with 200 and 300. for now i just want to place it somewhere so i can show you whatâ€™s going to happen so now we have an image and we have a rectangle so what we could do now let me scroll down a tiny bit and let me create our player is equal to layer so that way weâ€™re creating an instance of this class however if weâ€™re going to run the code now oh and iâ€™m getting an error this needs to be called so now itâ€™s right again and now if we run the code we canâ€™t see anything but the game well still works perfectly fine so nothing is going wrong so why canâ€™t we see this class here and the reason why we canâ€™t see it is that pygame doesnâ€™t draw sprites automatically for the simple reason that a sprite is basically just a surface and a rectangle combined but we also canâ€™t use screen.blit because that isnâ€™t going to work with a sprite instead we have to do it differently instead what we have to do is take all of our sprites and place them inside of a group and then this group can do two different things they can one draw all of the sprites inside of it and it can also update all of these sprites which is going to be really useful for us later on and pygame has two different kinds of groups number one is a regular group and this one can contain multiple kinds of sprites and this would be perfect for our flies in our snails because they can all be in one big group and they are not going to interact with each other however for the player itâ€™s not really going to work because the player is supposed to be in its own group and self-contained and for that pie game has a different kind of group and thatâ€™s called group single which is a group for a single sprite itâ€™s kind of weird but well it is what it is so our player is going to be in single group and all the other sprites will go in the normal group and the major reason why i put them into different groups is when we are checking for the collision we need to have them in different groups thatâ€™s really important but thatâ€™s going to come later for now let me first get rid of this player here and instead i want to for my player create pygame.sprite dot group single and into this group so player i want to add an instance of my player and this way we are going to have a group that is going to contain a sprite and this sprite is going to contain all of this stuff here and that way we are able to access it so now if we run the code we still canâ€™t see the player however now if i go to my code all the way down in our game loop our game is getting quite long here we have the player now i want to get my player and on this i can call the draw method and in here i have to specify one argument and thatâ€™s the surface i want to draw on so in this case screen so now now we can see our actual player and well this is going to be there forever it doesnâ€™t do anything right now but well itâ€™s going to do very soon so this way once you have a bit of setup you can add all of your code for the player in here and then just add this to a group and then call the group later in the code down here and this is going to clean up our code considerably however we will have to recreate the entire player inside of this class so this is going to be a slightly longer thing so let me go through step by step and the first thing i want to do is to get my player input so player underscore input needs itself as before and in here we have to get our player input and here itâ€™s really useful what we learned like two hours ago that we can get all of the keys being pressed by pygame so pygame dot key dot get underscore pressed and this is then going to give us all the possible key inputs and we can just go through them so if keys pi game dot k underscore space and self.rect.bottom is greater or equal than 300. then we want to jump so self.gravity is going to be minus minus 20. so this is pretty much the same thing that we have seen a bit further down here all of this so this is just making the player jump but now obviously we need a gravity for all of this so we have to set self.gravity to 0 by default and now since we have gravity we also have to apply it so define apply gravity again with itself and in here i want to go self.gravity is plus equal 1 and then self.rect.y so here again we are just picking the rectangle to move it and we just apply the gravity towards it so plus equal self dot gravity and this should be it dot and then to make sure that our player isnâ€™t going to fall outside of the game we need self dot wrecked dot bottom if that is greater or equal than 300 so our floor then i want self.direct.bottom is going to be equal to 300 and this is going to be we have put all of this that is essentially this line here or these lines rather and we are essentially going to do the same thing the only difference now is instead of player rect we have self.right but thatâ€™s literally the only difference that we really have to worry about so with that we have our gravity and our jump mechanic however now if we run the code nothingâ€™s going to happen for the simple reason that we donâ€™t call any of these methods and you might be tempted here to go with let me find it in the code here we have our player and you might be tempted to do something like player dot jump or something but that would be the wrong way to go on about it instead what weâ€™re going to do is use player dot update and this is what i mentioned earlier that sprite groups in pygame have two main functions one is to draw all of the sprites and the other one is to update all of the sprites and well this is what we are going to make use of here so instead of calling each method individually what we are going to do is inside of our player class we are going to define an update method it still needs self but in here we are going to run self.player input not index input and we are going to run self dot apply gravity and if you now go down a little bit further this play update here is going to call the update method inside of our player class so that way we are going to use that update method to run all of the other code and now let me go all the way to the top again the code is getting quite extensive so now if i run the code this should be working and i made a typo this should be self now letâ€™s try it and now we can see that we have two players that will work together and this is looking kind of freaky and here you can see quite well thereâ€™s a very slight delay but in our case this isnâ€™t going to matter too much but if you use different methods of input so in this case this key.get pressed is going to make a very minor difference so just be aware of that but in our case it really doesnâ€™t matter so with that we have most of the player the one thing thatâ€™s missing is the animation frames and well that is going to be the longest part and the first thing that we need to do is to import all the images inside of this class so let me go down a bit and here we have all the frames that we want to import and let me just copy them and now when we call the init method i still want to import all of these so what i want to do in here and i also want to keep myself.playerindex and i also need self dot player jump so let me go through whatâ€™s happening here first of all weâ€™re going to import these two frames and place both of them inside of the player walk frames and this needs self because we want to access it outside of this init method then we have our self.player index this also needs to be available in the entire class and we need our self.jump so this is just the jump frames so this is very similar compared to what we did earlier mostly because i just copied all of it and now when we are loading our self.image i donâ€™t just want to have walk frame one for it instead i want to add myself dot player walk and from there i want myself dot player index and this is going to give us right now the index 0 so we would be picking this surface here so still if you are running all of this it is not going to make any noticeable difference we still have the same setup however what we can do now is to declare another method and this i called animation state um couldnâ€™t think of a better name and what we are going to do in here is we are essentially going to copy this player animation however now we donâ€™t need the global methods anymore because we can work with self so letâ€™s work through this step by step first of all again we want to check if the player is on the floor or in the air so this is ifself.rect.bottom is going to be smaller than 300 then we want to do one thing and if that is not the case we want to do something else and well all we want to do in here is to go with self.image and self dot player jump i think i called it uh yeah this one player jump and if that is not the case i want to get myself dot player index and add 0.1 towards it and then again iâ€™m going to need the if statement to check if this index is still inside of this list here so if it is going to be 0 or 1 and well for that i need self dot player index is greater or equal to the length of our self dot player walk and if that condition is true i want to set myself dot player index back to zero and then finally self dot image is going to be self dot player walk then we want to take the index this needs to be an integer and self dot player index so all of this is essentially identical to what we have done down here the only difference now is that we add itself to all of the statements before but in terms of basic logic this is identical so with that we have our animation state and all we have to do now is to call it so dot animation state and now letâ€™s try off this again and now we have two walking players and they also jump together so this is working pretty well so this is basically covering the player now what is missing is that we donâ€™t have any collisions with the flies or the snails but for that we first have to create the sprites for all of these so well thatâ€™s going to be the next big step that i want to minimize this class and create another class and this class i have called obstacle and also it needs to inherit from pygm.sprite.sprite and in here again we have to define an init method that needs self and this time we also want to have another argument and thatâ€™s the type of obstacle so if it is going to be a fly or a snail and then on the first line of the init method we need super and then init again if you donâ€™t do that pi game is going to throw an error and itâ€™s very easy to forget and in here again we are going to need a self.image and a self.rect those are always needed you canâ€™t have a spread class without these two and in here i want to run an if statement to import different kinds of images depending on what i get so if this type is going to be snail i only want to import this stuff here and if itâ€™s a fly i want to input all of this so before i create my image i want to run an if statement that if my type is letâ€™s say fly so this would look something like this so we are still importing two different surfaces and we place both of them inside of a list that are called frames so this is still very similar compared to the player but now we are also going to need another thing and that is going to be the y position because the flies need to be higher than the snail so in this case letâ€™s go with 210 and this is the number if you remember from a couple of hours ago that we have specified here so 300 or 210 and well that is going to be the y position for the fly and now all i have to do is if that is not the case so if we donâ€™t type fly and type anything else i want to have an else statement and this is then going to do the exact same thing except for the snail so itâ€™s going to look like this and that way when we create the obstacle we can just type in what kind of obstacle we want and finally we are going to need self dot animation underscore index and that needs to be zero and now we can create our image and our rectangle so for the image we need self dot frames and here we need self dot animation index and then for rectangle all we really need is self dot image dot get underscore act and then mid bottom is going to be random dot rand this was between 900 and 1100 and then the y position all we really do is to set a certain kind of type and then use that type to either import all of this or all of this and this is just going to give us a list with our frames and a y position and then later on we are going to use that list to get an image and then we use that image to get a rectangle thatâ€™s really all thatâ€™s happening here now we do need a couple of other things now the first one is letâ€™s call it the animation state again it needs self as usual and in here i want to do basically the same thing i did for the player and this could be a really good exercise for you guys then i want you to pause the video and try to figure out the animation for both the flies and for the snails so pause the video now and try to implement all of this yourself alrighty letâ€™s do it together now so first of all i need to get myself dot animation index and now i just want to add plus equal and letâ€™s say 0.1 again although what you could be doing is that this animation index to a different kind of speed depending if you get a fly or snail but in my case iâ€™m not going to care and now i just want to get myself dot animation index is greater or equal to the length of our self dot frames and if that is the case i want to set myself dot animation index back to zero and then finally my self.image is going to be dot frames then i take the index of integer and self dot animation index and this is going to be pretty much the exact same logic we have seen a couple of times now so if i compare to the play animation we basically did this part here and all right with that we have our animation state now again we have to declare an update method that needs self and in here i want to call myself dot animation state so this would be giving us the basic animation for the fly or for the snail and let me minimize a couple of things in here so itâ€™s a bit easier to see what we are doing and all right so now i have my obstacle class and i want to add it to a group so let me go down and let me properly add my groups here and this i just call obstacle group and this needs to be pygame dot sprite dot group however now we couldnâ€™t just add each of the obstacles right away because we only want to do that when the timer ticks so this is going to happen if i go all the way down that is going to happen in this part here where earlier we just had an obstacle wrecked list and we appended stuff towards it but i donâ€™t want to do that anymore and instead i want to get my obstacle group and in here i want to add one instance of my obstacle and for now letâ€™s just call it fly and now letâ€™s try and see what happens and we canâ€™t see anything and the reason for that should make a lot of sense so if i go all the way up again when we are initiating our class we are putting our fly at position 900 to 1100 and slightly above the ground so itâ€™s outside of the screen and it doesnâ€™t move into the screen so that really doesnâ€™t help us and just to illustrate that it is working let me place it somewhere between 100 and 200 and now if you run the code again we still canâ€™t see it and the reasons for that also makes sense because when i go all the way down we are not drawing this group so what we have to do is to get our obstacle group dot draw and this needs to be on the screen and now it should work for real and there we go now we can see that whenever the timer ticks we are getting another fly which right now looks kind of strange but we can work with this so now let me get all the way back to the top and change this back to 900 to 1100 but now what we want to do is to move this fly a little bit to the left on every cycle of our game loop and literally all we have to do to make that work is to get our rectangle again so self.rect and now we need to target one of the points in my case i went with x and then we need to subtract a couple of pixels every single time our game updates so letâ€™s go for now with six and that way this entire sprite is going to be moved to the left however thereâ€™s one thing we still have to do let me go all the way down right now weâ€™re only drawing the sprite weâ€™re not updating it so we need obstacle group dot update and now we should be seeing a ton of flies and there we can see one and well quite a lot more and well now the game becomes really hard uh i well itâ€™s basically unplayable at this point but okay we are going to clean this up in a little bit so okay so with this we have our class properly now and thereâ€™s only one more thing that i do want to do that whenever our fly or our snail is moving outside of the screen it should be destroyed and how we handled this earlier if i go down a tiny bit we used this line here to remove any kind of rectangle that is too far to the left but if we have a class all of this is much easier to do because all we have to do is to define another method that iâ€™m going to call destroy and self and in here i want to look for self.rect.x and if this is smaller or equal to negative 100 i want to run self.kill and this self.kill is going to destroy this obstacle sprite and then all we have to do is in our update method called self.destroy so this way whenever this sprite goes too far outside of the screen itâ€™s going to destroy itself and we donâ€™t have to worry about it at all anymore although you canâ€™t really see it in our game itself so thereâ€™s no point in running it however thereâ€™s one thing that you are going to see that we are missing right now and if i go down a little bit further i can actually copy all of this out because we donâ€™t really want to look at it so these were the earlier sprites that we looked at and we donâ€™t need those anymore and what i want to work on right now is that we are always spawning a fly but i also want to spawn snails once in a while actually i want to spawn mostly snails so i have to figure out some kind of mechanic here to spawn mostly snails and sometimes a fly and there are quite a few different ways to make this work in my case i went with a little bit of a hack so let me explain first of all i imported besides rent int also choice and choice allows us to pick a random item from a list thatâ€™s all it does so now that i have that i can when i pass on the fly i can pass in choice and this choice is going to pick from a couple of different items and in this list i have one fly and then i have a couple more snails letâ€™s put three in there so how this is going to work is whenever we are calling our obstacle this choice method is going to pick one of these four items and since we have our snail three times thereâ€™s a 75 chance to get a snail and a 25 chance to get a fly and well letâ€™s trail of this so now we should only be seeing our sprites and well now our collision is broken but we should be seeing a fly and there we go and now we can only see our sprites and this is working pretty well cool and now let me actually hide the earlier player we created so all of this here we donâ€™t need any more and literally all we are going to need is these four lines thatâ€™s literally how we need we also donâ€™t need our obstacle list anymore and we also can comment out our game active and i think if you followed along this code might look very confusing but the main problem right now is that we are both having a sprite setup and a functional setup and this can get really confusing but if you were to actually work on a code you would only look at these two classes which is much easier to organize and the only reason why all of this became so complex is because well i went through every single step but in an actual game all of this could be deleted and you would only have the classes but in my case well the code got quite long but if you look at this here all the stuff i commented out you could just get rid of and well that would make our code significantly more readable but alright let me update the player so all the way at the top let me hide all of this when i initiate the player it is supposed to be at 80 pixels from the left so now letâ€™s run this again and now we have the same setup except with sprites and well the one thing missing now is that we donâ€™t have collisions so thatâ€™s the last one we have to add in here and this fortunately is also very easy to achieve because sprites have their own collision mechanics and the most common one is called sprite collide and what this one does is that it takes a sprite and it checks if this sprite is colliding with any other sprite in another group and if thatâ€™s the case itâ€™s going to return a list with all the collision sprites which is super useful and this we can then work with in a function and as a matter of fact we already have our collision function and let me open it and what i want to do is to somewhat copy this so letâ€™s call this collision sprite and for this one now we donâ€™t need any arguments and really all we want to do is to first check pygame dot sprite dot sprite collide and in here we are going to need three different arguments we first need a sprite then we need a group and then we need a boolean weâ€™re going to explain that one in just a second but first of all we need a sprite and in my case i want to get my player and here you have to be careful because this player is not a sprite it is a group single that contains a sprite so that can be quite confusing so this player by itself would not be enough however we can access the sprite very easily all we need is dot sprite and since this class only has a single sprite this is quite workable however in a regular group this sprite would not work you could only get a list of all the sprites you could not get an individual sprite so this is why we have group single here all right but then for the group this is much easier all we need is our obstacle group and now we have the group that we need now for this boolean here what this effectively does is that if this sprite here is colliding with a sprite in this group we can check if this spread is going to be destroyed or not and this is what the boolean here is for so if youâ€™re going to set this to true every time our snail will collide with the player the snail will be deleted and if we set this to false the snail would not be deleted and in my case i want to go with false but in our case it really doesnâ€™t matter all that much but all right now this entire statement is going to return a list and if it doesnâ€™t collide with anything itâ€™s going to return an empty list and that we can use an if statement so if thereâ€™s anything in this collision list we want to run some code and well all we really want to do is to return false and if that is not the case i want to return true and this is going to be very similar compared to our collision function so all right now all i have to do if i go down quite a bit by now we have down here our collisions i still have our game active variable and now we want to check collision sprite and well with that we should have our collisions back so letâ€™s check if this is working and there we go itâ€™s still working but now we have the same problem again that if i run the game again the snail is still in the same position so well our game would crash right away so whenever let me go all the way up again whenever this collision sprite triggers we want to delete all of the sprites inside of our obstacle group and this is very easy to achieve because all we need to do is to get the obstacle group and empty it and now if i run all of this this should be working pretty well so now if i collide with a fly the game stops and now it starts again with no sprites in there and well this is working pretty well cool so now we have our game working again so with that we have made quite some noticeable changes and thereâ€™s a ton of redundancy in our code now which isnâ€™t great but i hope you get the principle following along and iâ€™m going to upload all of the code in the proper way for the class-based approach thatâ€™s going to help understand all of this i think but if you could follow along i hope this makes sense but alright thereâ€™s only one more topping left to do and thatâ€™s to add the sound and this is going to be a super easy part and well the audio part is going to be really quick because thereâ€™s only really two steps that are both really easy we first have to import a sound and then we have to play it at certain parts in our game and all of that happens with the pygame dot mixer module and this really isnâ€™t all that complicated so i think the best way to approach this is to jump straight into our code and then letâ€™s do all of this so specifically i want to work with two sounds one is the background music and one is a jump sound so here we are back in the code and the first thing i want to do is to add the player jump sound and for that i am opening a player and when we initiate this class i want to also import the sound and letâ€™s call this jump underscore sound and now to import a sound we need pygame dot mixer dot sound and as always make sure the s is capitalized thatâ€™s really important but now all you have to do is to add a path to what file you want to import and in this case we have audio jump.mp3 and thatâ€™s all we needed to import is sound so thatâ€™s the first step and now we only want to play this sound when our player is jumping and that happens in this player input that whenever we play the button we want to jump so we could play this sound ideally in here and that would make the most sense so letâ€™s play there and to play the sound literally all that we have to do is to get our self.jump sound and then add play that is literally all we have to do so now if i run the code we can still see our game thatâ€™s a good start and now you should be able to hear a jump sound so itâ€™s really as simple as that now thereâ€™s one problem with this that i think this sound is kind of loud and annoying so i want to make it less loud and this we can also do very easily all we need is to target our jump sound again and then add set volume and in here we choose a value between 0 and 1 with 1 being the full sound and 0 being the sound muted and in my case i went with 0.5 and now this should sound significantly better but do play around with it i guess um whatever you think is perfect so thatâ€™s all we had to do for the jump sound now next up let me minimize all of this because we donâ€™t need it anymore and next up i want to have an actual game sound and let me import it right when we initiate the game and letâ€™s call this bg music for background music and this could be a really good exercise for you try to import this music and play it once once our game has started so all i want to do is pygame.mixer.sound and now the file that we are going for is this one audio slash music or wav and that is the music that we want to play and now we have to figure out two things number one is where do we have to add the code to play this music and number two is how can we loop this music so this track here is only a couple of minutes long and once itâ€™s over i want to restart it so thatâ€™s another thing we have to figure out but first let me change this to lowercase music so it looks a bit more consistent but right now i want to target my pg music again and again what i want to do is to play this music and now as soon as our game starts we are going to play the music so letâ€™s try this you can play with the ball a little bit itâ€™s up to you i am not going to worry too much and now if you want to loop this all we have to add is one argument in here and thatâ€™s called loops and in here we can tell pygm how often to loop this so for example if i were to add a six in here we would loop this track six times but in our case we donâ€™t want to loop it a certain amount of times instead we want to loop it forever and for that we need -1 and this is telling pygam to play this sound forever and once itâ€™s over to just restart and well you canâ€™t really see this in the game [Music] now with that we do have the entire game and if you have gotten this far you have basically learned all the fundamentals of pygame so at this stage you should be able to approach most 2d games now obviously you do have to practice using all of these concepts but this is essentially all the concepts you need to make them so i hope that was helpful</p>
]]></content>
      <categories>
        <category>å‰ç«¯</category>
      </categories>
      <tags>
        <tag>é™æ€ç½‘é¡µ</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/06/09/%E5%A1%9E%E5%B0%94%E8%BE%BE/</url>
    <content><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>title: åˆ©ç”¨pythonåˆ¶ä½œç±»ä¼¼å¡å°”è¾¾å¼€æ”¾ä¸–ç•Œ2dæ¸¸æˆ è‹±æ–‡å­—å¹•<br>date: 2022-6-9 17ï¼š56<br>categories:</p>
<ul>
<li>åç«¯<br>tags: </li>
<li>python</li>
</ul>
<hr>
<p>00:00:00.590 â€“&gt; 00:00:03.377<br>[Music] [Music] [Music] [Applause] [Music] in this tutorial we will be creating a zelda style rpg and it is going to involve a lot of components like sophisticated animations and graphics rpg mechanics and we are going to use tiled for the level creation and we are even going to create enemy ai speaking of ai i would like to give a shout out to the sponsor of this video ai camp if you want to learn more about artificial intelligence and build some seriously cool projects they have something for you ai camp offers either one-on-one guidance or a summer camp during which students create real world ai projects like face mask detectors sign language identifiers currency exchange automation and much more student testimonials from past summer camps are very positive and many students received either partial or even full scholarships to attend by visiting my partner link in the description you can apply for a unique scholarship opportunity to fund your time at ai camp and best of all it only takes 10 minutes and even more upon successful completion the top aicam students are hired to work for ai camp or for other silicon valley startups if you want to study ai or computer science at university or work in the field professionally this is a great experience to get started ai camp is currently looking for people to join their summer camp and i would strongly recommend you to check it out if you are interested now before i jump into the project a quick note on this setup we have one folder with four subfolders although we will only make changes to the one that contains the code and since the tutorial is quite long you can find the game files for each stage on github there are 15 in total there are also placement files to get started and to copy code it takes a bit longer to type and well thatâ€™s basically it i hope you enjoy it so here we are in the code and right now i have three different files open we have main we have settings and we have debug and all three of those are python files and if i run the main file thatâ€™s the really important one we are getting this window here plain lag doesnâ€™t do anything right now but at the very least we have a window that is all we are going to need for now and i guess before we get into the proper code letâ€™s go through this to have a solid basis now we are starting all the way up here with importing pygame and says thatâ€™s the usual stuff the more important stuff comes right below where we are importing everything from settings and settings looks like this we basically have two sections in here the first one contains the main game variables most importantly here we have width and height of our game window and those would be flexible so if the game window is too large for your window you can make these smaller i guess you could also make them larger if you wanted to and then besides that we have the fps and the tile size and i would recommend to keep those two numbers static now besides that we have our world map and the world map is for now going to be the layout of our game in this world map we have our player thatâ€™s the p then besides that we have axis and that is going to be a rock on obstacle same thing and then besides that we have a ton of empty space and that is going to be space the player can walk on so then if i go back to our main file we have a game class letâ€™s talk about this in a second but what we are doing with the class comes down here we first check if this is our main file then we are creating an instance of this game class and then we call the method run of this class so letâ€™s look at our game class and in here not much is actually happening we have our init method and in here we are initiating pi game we are creating a display surface and we are creating a clock so this is the basic setup you always need for pi game then more importantly we have our run method and in here two things essentially happen the first one is going to be this bit here and that is going to be our event loop and right now we are just checking if we are closing the game now besides that down here we are filling the screen with a black color we are updating the screen and we are controlling the frame rate so none of this should be difficult if you have any experience with pygame however if you have no idea what any of this means check out my introduction to pygame it explains all of this in quite some detail but alright so this is going to be our basic setup now thereâ€™s one more file that we have to talk about and that is debug and debug isnâ€™t actually going to influence our game instead itâ€™s as the name suggests a debug tool so itâ€™s really just there to give us information about whatever is going on in the game but itâ€™s not actually going to influence the game so you could ignore it entirely if you donâ€™t care about it and i am going to use it just to illustrate in a bit more detail whatâ€™s going on in the game and let me actually demonstrate what it does so if i go to my main file in here i can from debug import debug and then in my game loop i can run debug and print any kind of information that i think is important so letâ€™s say hello and letâ€™s see what we get now in the top left of our window we get the word hello and obviously right now not particularly helpful but later on this could be a game variable that we want to illustrate so this is very helpful all right but right now i donâ€™t want it so let me get rid of all of that now with that we have our basic setup although thereâ€™s one more thing i would like to add in here and that is that right now let me actually demonstrate in the top left of our window it says play game window and i would rather that this says zelda or something more customized and this would be a challenge for you that i want you guys to change this text to something more custom in my case itâ€™s going to be zelda but you could write whatever you want alright letâ€™s try together let me close this and we only really need one line when we are initiating all of pi game so it happens right here after i create a display surface and the line we need is pygame spelled correctly dot display dot set underscore caption and then here we have to pass in a string and in my case itâ€™s going to be zelda and now if i run this we can see zelda in the top left it really isnâ€™t going to make much of a difference but well it looks a bit nicer so with that we have our basic setup and now we can talk about the actual level and our level class is going to become incredibly important itâ€™s essentially the central part of the entire game so effectively itâ€™s going to be the container that contains all the essential game elements like the player all the enemies the level map all of the obstacles and so on it is really important and that is actually bringing us to the core concept the level class has to manage and that is that we have to take all of our sprites for the game put them in different groups and somehow manage all of this efficiently and the key concept to make that work is to use different groups to give different functionality to different sprites so let me give an example for start we are going to create two groups in our level class one is called visible sprites the other is called obstacle sprites and literally any sprite that is going to be visible will be in the visible sprites class so this is the only group that we will draw on the screen at the end of this project it will contain the player the map all the enemies all the obstacles and so on so if a sprite is not inside of this class it will not be drawn and for the obstacle group well anything that is going to be in here will be able to collide with the player and anything that isnâ€™t in here will not be able to collide thatâ€™s fairly straightforward and how this will become useful later on is that for example for our level boundary so the coastline effectively i have basically placed sprites there that will interact with the player via collisions but they are not drawn because theyâ€™re not in the visible sprites group you will see how that is going to work later on but the main thing you should understand is this that you can put sprites into different group and the sprite can be in multiple groups at the same time and depending on what group it is in it should be interacting with its environment slightly differently and that is going to become a key concept to make this entire project work but letâ€™s actually jump into our code and letâ€™s implement all of this so here iâ€™m back in the code and i want to create a new file and i will save this one as level dot pi and in here as always we have to import pi game nothing else for now though and now we have to create a class level thereâ€™s no inheritance but we do need an init method that needs self and nothing else and i guess now we can go straight to creating the two sprite groups that i just talked about so let me add a comment here and letâ€™s call this sprite group set up and in here i want to create self dot visible underscore sprites and this is just going to become pygame dot sprite dot group and now i can copy all of this and i want to create obstacle sprites so these two groups will become really important and essentially what i want to do later on in my level class is i want to give it another method that iâ€™m going to call run doesnâ€™t need any argument besides self and in here i want to essentially update and draw the game but for now iâ€™m just going to add pass because itâ€™s not doing anything and now that i have my level i can go back to my main i can import so from level import level and what i can do now is create self dot level is going to be the level and then in the game i can call self dot level dot run so we are essentially creating an instance of our level class this one here in our main game and then we are running all of this inside of our loop so really all weâ€™re doing is we are calling this method here and let me just run all of this to see if itâ€™s working and yeah itâ€™s still looking good we still canâ€™t see anything but that comes later so now we have a basic level now next up thereâ€™s one more thing i will need in the init method and that is the display surface because at the end of the game we want to draw all of our game on this self.screen so we can approach this in two different ways we could either take this self.screen and pass it in this level this would be perfectly fine although in my case in my level i am letâ€™s do it right at the top we can use a function to just get the display surface from anywhere in our code and the code for that letâ€™s call this one self dot display underscore surface all we need is pygame dot display dot get underscore surface and this is going to get us the display surface from anywhere in our code which is quite handy as a matter of fact in the debug method we are using the very same line if youâ€™re interested but that doesnâ€™t matter too much so now we have our basic level class it still doesnâ€™t do all that much because weâ€™re not drawing anything and to draw something we essentially have to go through this world.map and draw either a rook wherever thereâ€™s an x nothing if thereâ€™s an empty space or the player if thereâ€™s a p and the problem we have right now is that we neither have an x nor a player so letâ€™s create both of these in a very simple way and then weâ€™re going to cycle through this entire map to place them on the screen so back in my level well actually this should be a new file and let me save this one as tile dot pi and for now this is going to be a class that will always going to be a rock but later on we are going to make it slightly more flexible so it goes to become a tree or statue or basically any kind of object import pie game as always that was terrible spelling and from settings import everything and now i want to have a class called tile and this one is going to be a sprite so pygame dot sprite dot sprite for inheritance that is really important and now i want to create a dunder init method that needs self and now this one is going to do a couple of things most importantly we are going to need a position so we know where to place it besides that i am also going to give it an argument called groups and this is going to be the spread group it should be part of how that is going to work you see in just a second but thereâ€™s a very handy feature to assign a sprite to a group via the arguments you see in a second what i mean actually we can do this right now so these are the two arguments i need and the first thing you always eat in a sprite thatâ€™s very easy to forget is super dot init and then brackets so we initiate this class here essentially and what you can do that is super handy is if you pass the groups in here so the argument we have just declared now we are going to need two things the first one is always self.image and we need self.rect the two main things you always need for any kind of sprite and direct is the easier part we need self dot image dot get underscore rect and the top left is just going to be the position so this is the position that we get up here that we will give this tile when we create it now for the image i want to import a file so pygame dot door and in here we first have to get outside of our folder so right now we are in the code folder so dot dot then we have to go into the graphics folder and inside of the graphics folder thereâ€™s a folder called test and inside of test we have a player and a rock and for this one i want to use rock.png and really important do not forget to convert alpha this rock with that we have our basic rock or well a basic tile thatâ€™s a pretty good start and i guess what we can also do is let me copy all of this and now i want to create a new file and this one is going to become our player so let me save it as player dot pi and now i can paste all of this and change the class name from tile to player and now instead of the rock i want to have the player and the rest can stay the same although this player class later on we are going to massively change so thereâ€™s no point using inheritance between these two classes with that we have a player and a tile or rock so now in our level we can actually set some basic stuff up so we can finally actually see something but first of all letâ€™s see if things are still working and they do thatâ€™s theyâ€™re looking pretty good and i guess let me really quickly explain what we are going to do so the really important part in our settings is this world map and letâ€™s go through this thing really quickly just to explain what it is and how itâ€™s going to work so essentially world map is a list hereâ€™s the start and hereâ€™s the end and this list contains a ton of individual lists and inside of each list we have one string there could either be an x a space or a p and this we are going to translate into specific positions for example this top left x should have the top left position so this point here should be position 0 and 0. for the simple reason that itâ€™s right in the top left now the x right next to it so this one here should have the top left position let me add a small arrow to make it a bit easier to see this should have an x position of 64 because our tile size is 64 but then the y position should still be zero because itâ€™s right at the top and now for another example letâ€™s say if we want to place the player i still want to place the top left and now i have to figure out the x and the y position and this could actually be a really good exercise for you try to figure out what the coordinates of the player are supposed to be i know the player is in the column with the index two so we have zero we have one and we have two so the x position of this point here should be 2 times 64. and let me add x here and that is going to be 128 and now for the y position thatâ€™s one we havenâ€™t done so far we can use the list themselves so we know this is list number zero this is list number one and this is list number two so our player is in the list with index number two so for y we also have to place the player at 2 times 64 which is still going to be 100 so the top left of the player should be a position 128 and 128 and this sort of logic we are going to do for every single item in this entire list so i want to go back to my level and in here i am going to create a new method letâ€™s call it create underscore map it doesnâ€™t need any arguments besides self and in here essentially i have to nest a couple of for loops and let me build this up slowly first of all i need 4 row in world underscore map and now letâ€™s print what we get so print row and i guess when we set up the class we can call this method so in here let me add another section and letâ€™s call it sprite set up and what i want to do is self dot create map so weâ€™re just calling this method here and now if we run out of this we are getting an error that world map is not defined for the simple reason that i didnâ€™t import the settings so from settings import star now this should be working there we go so now we still canâ€™t see anything but now we have printed essentially the entire map that we can see in the settings so the same map we can see here pretty good start although not particularly helpful because thereâ€™s a really important thing i need to get here that for each row i need to know the index because that is going to be the number i will multiply with the tile size to get the y position so besides the row information i also need to know what index itâ€™s on and this is information i am getting with the enumerate method so enumerate and we need row index and row so now i can let me copy this i can print the row index and the row so now if i run this and close the window we can see that we have index zero then the first row index one and then the second row about the first row the row of the index one letâ€™s put it this way and this is really important information because this entire row here i want to multiply for the y position with zero times 64 which is going to be zero but for the second row or the row of the index one we want to go with one time 64. so that way thereâ€™s always going to be a 64 pixel offset between each row and all right now we have our row and our row index so that is going to give us the y position but from that we also need the x position so this is going to be another for loop so let me go back to my settings essentially we went through every single list with this for loop and we got the list and the index now what we want to do is that inside of each of the lists we want to look at each of these xâ€™s and then figure out what the information is so whatâ€™s inside of the string and what index this string is on and that way weâ€™re going to get our x position and this is going to look very similar so for letâ€™s call it call index and column in enumerate and now itâ€™s going to be the row and that is literally all we are going to need for the basic setup so this is going to cycle through every single item so every single x empty string or p inside of this world map and itâ€™s also going to give us the x and the y position and i guess just for the formula now we can get an x and we can get a y position the x is going to be the column index multiplied by the tile size and y is going to be the row index multiplied by the tile size and with that we have converted the world map into a position so now what we can do is if the column so each individual item inside of this world map so x empty space or p and use that information to create a certain kind of sprite so for example if column is going to be equal to an x then we want to create a rock and for that to work we obviously have to import the tile for the rock so from tile import tile i think i called it yeah tile and i guess what we added from player import player essentially all we want to do is if we have an x we want to create a tile and the tile has two arguments we have to figure out we need a position and the groups so let me copy them and the position we already have that is just going to be a tuple with x and y and for the groups all i want is a list with all the groups this one is supposed to be in letâ€™s say for now itâ€™s just going to be self dot visible sprites so we can see them but later on there are going to be more groups in here and with that we have the basic setup this is not looking bad at all so first of all letâ€™s run out of this to see if we get an error and we donâ€™t thatâ€™s generally a good sign so now we just have to display this visible sprites and we should be good to go and i think this could be a good exercise to see if you are still following along so try to display all the sprites inside of visible sprites i hope that was a simple exercise because all we have to do is self dot visible and then we need the surface we want to draw on which in our case is self dot display surface and now letâ€™s see if this is working and it is indeed working we can see the top part of our game we canâ€™t see the bottom part but for that we are going to create a camera later on but for now this is looking pretty good and let me make this a bit smaller so with that we have our rocks next up we also want to place the player so if the column is equal to the letter p then we want to place the player so we want to just create the player and the player is in here it also has position and groups for now so let me just copy them in here and we can actually just copy the arguments from the rock and place them in here so essentially right now the tile and the player identical but they are going to become very different very soon but letâ€™s try this and there we can see our player so with that we have our basic level setup and i guess one more thing that we can do for now is that the tile for the rock should be in two different groups it should be indivisible sprites and it should also be let me copy it it should also be in the obstacle sprites i guess let me call it obstacle sprites not obstacles sprite thatâ€™s very annoying to pronounce now you will not be able to see a difference but now whenever we create a tile this tile is going to be in the visible sprites and inside of the obstacle sprites and later on this will become incredibly helpful because essentially what we will do is we will check the obstacle sprites and the player and if there is any collision we are going to influence the player from that collision and this is actually something we could start working on right now so the next part is going to be about the player and the player is going to become quite substantial because well itâ€™s the main player of the game but for now we are going to focus on two things only the movement of the player and the collision mechanics and that is going to allow us to sort of run around the level already and i guess letâ€™s do all of this straight in the code that should be the easiest way here we are back in the code and i want to look at my player and right now our player really doesnâ€™t do all that much so we have to add a few more things here now first of all we need some kind of direction the player is supposed to walk in and this in my case is going to be a 2d vector so self.direction is usually a good name and what i want is pie game dot map dot vector 2 and donâ€™t forget the brackets if you leave them empty itâ€™s going to be 0 and 0. and this is going to give us a vector that is going to have x and y and right now by default both are going to be zero and what we want to do is to use keyboard input to change either of these numbers to a certain direction for example if we are pressing right then this zero for the x should be a one and then later on we are going to multiply this vector with a certain kind of player speed and that way this direction would become something letâ€™s say 5 and 0 and our player would move to the right at the speed of 5 pixels per frame so we essentially have to do two things number one we have to get keyboard input and number two we have to multiply this vector by a speed and well letâ€™s start with the keyboard input so letâ€™s call it just input needs self and nothing else as always and in here we need to get our keyboard input and i guess this could become a good exercise so try to get the keyboard input for up down left and right on the keyboard and see if you can figure this out so first of all i need to get all the keys that are potentially being pressed and this happens with pygame dot key dot get underscore pressed and now what i can do is if keys and we can check for specific key letâ€™s say i want to start with pygame.k underscore up and if that is the case i want to set self.direction.y to negative one and thatâ€™s all we need now we can copy this thing and change this one to down and now y should be one and now we can copy both of them although donâ€™t forget they should be alif so right now we are pressing negative one so our player is going up later on at some point now for pressing down this y becomes 1 so our player is moving downwards however now we have a problem that letâ€™s say in our game we pressed down and then we lift up the key again our player would keep on moving down because this y being 1 sticks around because we donâ€™t change it anymore and well our play will just keep on moving downwards which is not ideal but we can fix that quite easily by adding an else statement that self.direction is going to be zero so really all weâ€™re checking is is the up key being pressed if thatâ€™s the case y is negative one if weâ€™re pressing down y is going to be positive one and if we are pressing neither of these buttons the player doesnâ€™t move in the y direction at all actually i forgot direction dot y and thatâ€™s it for the y direction now i can just copy the entire thing and do the very same logic for right and left letâ€™s say we want to start with right and right is going to be x and it is the positive number and if we go with k left this should also be x and it should be negative one and then direction x is going to be zero this one doesnâ€™t have positive or negative and all right with that we have our basic input so now we can give this class an update method so update self thatâ€™s horrible spelling and for now i just want to get self dot input and now what i want to do back in my level dot pi i also want to update all of the visible sprites so self dot visible sprites dot update and now letâ€™s run all of the code and letâ€™s see if anything happens so we canâ€™t see anything right now but something is happening at least hopefully inside of our player and actually we are able to visualize whatâ€™s happening by using our debug function but first of all back at my level when i created the player i also want to put this inside of self dot player player and the reason for that is that iâ€™m going to use this software player quite a bit and this way i can target it directly but it is still going to be inside of this visible sprites and well now what i can do is right at the top i can from debug import so this function here and now in my run method i can call debug and i can call self dot player dot direction and now if we run out of this we can see in the top left we have 0 and 0 right now and thatâ€™s our direction and if i press to the left we get negative 1 for x or positive 1 if i press to the right and if i press up we get negative one and if i press down we get plus one for the y and that way i can press in a different directions and we get different numbers so this is already going to give us the keyboard input and all we want to do is to multiply this with a certain kind of speed and that is also going to happen inside of the player so now besides direction i also want to give my player self dot speed at least for now and letâ€™s put it at 5. although be aware later on this speed is going to disappear because we will replace it with a proper dictionary of all the player attributes but for now we can work with it quite well and besides that i want to create a move method and this one itself and itâ€™s going to need the speed and in here we are going to move the player all we have to do is self.rect.letâ€™s say center plus equal self.direction multiplied by the speed and that is all we need so now i can run in the update method self.move and the speed is going to be self.speed and letâ€™s actually try this and see what happens so nothing happens if i donâ€™t press a button but if i press to the right or to the left or up and down our player is moving so this is working quite well although well you can see that the overlap with the different rocks doesnâ€™t work at all right now and we have no collisions but we can at least move around obviously we also donâ€™t have a camera so if the player moves outside the window it just disappears but that comes soon although before we get to that thereâ€™s one more thing i do want to work on and let me illustrate what the problem is right now if i just move left or right or up and down we have a certain kind of speed however if i move to the right and down we are moving significantly faster i think itâ€™s quite good to see and the reason for that is trigonometry essentially that if we apply two different directions we are moving slightly faster and this we have to account for and essentially what we have to do in this player so this direction here we have to normalize it and what normalizing means is that we are changing the length of a vector to 1. and that way if we multiply by the speed itâ€™s always going to have the same speed no matter what direction we are going in and well doing that is actually super easy all we have to do is if self dot direction dot magnitude 2 thatâ€™s how you spell that so magnitude essentially is the length of the vector and if that is different from zero then i want to get myself dot direction and simply get self.direction.normalize so first of all we are checking if our vector has any kind of length and as soon as it has a length we are setting the length of the vector to one that way it doesnâ€™t matter which direction itâ€™s going in itâ€™s always going to be one which down here instead number 3 is going to result in the same speed in all directions now the reason why we need this if statement is because a vector of 0 cannot be normalized pygame would throw an error this is why we need this if statement but now if i run main.pi i can move left and right still works but now if i move down now we can see in the top left we get 0.7 and that is because of the normalization but well you can see in the game now the movement looks significantly more constant so thatâ€™s a pretty good start and you might have one question that in the player why do i add the speed as an argument instead of just writing self.speed now this would work but the reason why iâ€™m not doing this is later on for the enemies we want to use the same move method so what iâ€™m essentially going to do is iâ€™m going to later on remove this move method from the player and put it inside of another class along with a couple of other methods actually and then both the player and the enemies are going to inherit from that class and that way iâ€™m going to keep things a bit more flexible so both the enemy and the player can inherit from them and use all of these methods so just keep that in mind if you want to use self.speed but okay with that we have our basic movement so next up we have to work on the collision and collisions generally can be a bit finicky to work with for the simple reason that in pygame all we can really check is if two sprites are overlapping but pygame doesnâ€™t tell us where theyâ€™re overlapping so let me put two sprites on the screen right now we have one sprite and one sprite slightly to the right and the bottom now these two obviously overlap but do they overlap from the right or from the bottom thatâ€™s a really important thing because what we want to do if they overlap we want to place the colliding rectangle either to the right or to the bottom of this other sprite so the problem we might have is that if we get a collision from the right pie game might get confused and place the sprite at the bottom of the other sprite and in the game this would look like our players teleporting around and it might even break the entire game but fortunately it can be fixed fairly easily all we have to do is to apply each direction individually letâ€™s say weâ€™re going to start with the horizontal movement so weâ€™re going to move the player in the horizontal space check for collisions and if there is a collision we are going to move the player to the point of that collision and once all of that is done we are going to work on all of the vertical movement and collisions that way there cannot be a confusion between what kind of collision is going to happen and well that is all we need to get started so letâ€™s go back into our code and letâ€™s have a look at this here weâ€™re back in the code and i have my player class open now what i would like is to have all of the collisions inside of this class the problem is that this player doesnâ€™t know where all of these obstacle sprites are so we have to pass them into the player and this is going to happen by simply giving the player another argument and letâ€™s call this one the obstacle sprites and then in the init method i want to get myself dot obstacle sprites itâ€™s just going to be obstacle sprites and now when we create the player at the end it is going to get self dot obstacle sprites be aware here we are placing the player inside of this group and then we are giving the player this group here but just for the collisions the player itself isnâ€™t in that group that is a really important distinction all right with that we can actually create let me create the collision method in here so letâ€™s call it collision it needs self and i want to give it a direction essentially what we are going to do first of all we are going to check the direction and this one could either be horizontal and then we want to do stuff and i guess letâ€™s be a bit specific so if direction is going to be vertical then we want to do other collision stuff and letâ€™s work on the horizontal one first essentially what i want to do i want to look at all of the sprites inside of my obstacle sprites so for sprite in obstacle sprites in self dot obstacle sprites and now for all of these sprites if sprite dot wrecked dot collide wrecked and self dot rect so we are essentially checking the rectangle of the sprite with the rectangle of the player so this information is going to tell us if there is a collision between these two but we still donâ€™t know if this collision happens on the left or on the right but this we can also get quite easily because we know the direction of the player so for example if this is our player and our player is moving to the right then it would be pretty unlikely to have a collision on the left side that would be a little bit strange instead we can kind of predict that we are always going to have a collision on the right side if the player is moving to the right and then the same thing for the left side if weâ€™re moving left all of our collisions are going to be on the left as well i guess important to say here all of our obstacles are going to be static so that should make it much easier all we have to do is if self dot direction dot x letâ€™s say is greater than zero so if that is the case we are moving right and if we are moving right we need self.rect.right thatâ€™s not how you spell that is going to be sprite dot wrecked dot left so now essentially whatâ€™s happening here if we have our player so this again is our player our player is moving to the right and now our player is colliding with some kind of obstacle and they are overlapping right now what i essentially want to do is to move the right side of my player so this side here to the left side of the obstacle we have been colliding with so that way it looks like the player is always on this particular side and theyâ€™re not overlapping and that is all we have to do with this line here so now next up we have to do the very same thing for the other side so if self.direction dot x is smaller than zero then self.rect.left is going to be sprite dot direct dot right so the exact flip side of the upper line this is then all we need for the horizontal collisions now next up we have to do the very same thing for the vertical ones and this i think could be a really good exercise for you so after looking at the horizontal collisions try to do the same thing for the vertical ones so you want to check for the up and the down movement letâ€™s try together now but first of all i want to add proper comments so this is moving left and now let me just copy the entire thing now the first two lines are still perfectly fine but besides that i now want to look at direction dot y so if direction dot y is greater than zero we are moving down and if that is the opposite way so we are smaller than zero we are moving up so if we are moving down we want to place the bottom of the rectangle at the top of the sprite so essentially what we are doing if this is our player again right now our player is moving down and if now we are colliding with any kind of obstacle the bottom of our player should be at the top of the obstacle so this line here and then we have to do the same thing for the up movement so the top of our rectangle is going to be at the bottom of the collision object and all right with that we have our collisions actually not all that bad so let me minimize this and now we have to work in this move method and essentially we have to take this method here and split it apart into the x and the y movement so self.direct self.rect.x plus equals self.direction.x multiplied by the speed and then we can do the same thing for the y so if i just left it at this and ignore the collision method entirely we shouldnâ€™t see any kind of difference and things are still looking pretty identical cool good start but now what i want to do after we are moving our player letâ€™s say on the x after we have done this i want to call myself dot collision and i want to check my horizontal collisions and letâ€™s just use one of them to see what is happening so now if i run my main file i can move to the left and i have proper collisions although if i move from the top nothing is going to happen and pie game is getting a bit glitchy but this we can fix quite easily because all we have to do is call self dot collision and now we want the vertical collisions so now if i run out of this we get very nice working collisions and everything is working just fine cool this is looking really good there are no bugs as far as i can see this is working very nicely now the problem is i can actually demonstrate this i can move outside of the window no problem so this is not ideal also the game doesnâ€™t look as good as it could because there are no overlaps so for example if iâ€™m on top of a rock my player stops where the rock begins but ideally there should be a tiny bit of overlap to give the illusion of depth which is what we are also going to need so letâ€™s work on these two bits now to achieve both of these things the camera and the overlap we essentially have to create our own group or at the very least we have to take a spread group and change some key functionality and that is very neatly going to bring us into a bit more of an advanced concept inside of pygame so far if you follow this channel we only ever used a group to place a sprite in there to update them and to draw them but you can totally take a sprite group and rewrite some core functionality but to do that we first have to understand what a group is actually doing and fortunately it really isnâ€™t all that complicated essentially all that the spread group really does is that it stores a ton of different sprites then it can call the update method and all of these sprites and we can also draw all of the sprites and all that is really going to happen inside of a draw method of a group is that we are going to call blit with the sprite and the rectangle of whatever sprite we have inside of that group so with that knowledge we can totally override key parts of a group or give it extra functionality here iâ€™m back in my code and i want to go to my level and i want to change this visible sprites class to a custom made group and letâ€™s create that class in the same file i think that makes sense and iâ€™m going to call this new class y sword camera group and itâ€™s going to inherit from pygame.sprite.group and the naming here has two key parts number one the more obvious one the camera group so this spread group is going to function as a camera and thatâ€™s the part we are going to work on in just a second the other part the y sword means that we are going to sort the sprites by the y coordinate and that way we are going to give them some overlap now in here we are going to need a couple of different things first of all as always we need a dunder init with self and nothing else and let me start with a general setup of all the stuff we are going to need now first of all as always like with the sprite we need super ideally spelled correctly that tends to help dot init no arguments are needed now once we have this we can actually replace our visible sprites with this group so why sort camera group and since we havenâ€™t replaced any functionality yet and weâ€™ve initiated the original class this should still work letâ€™s try it and we still get the very same functionality everything works as intended so at the very least we didnâ€™t break anything yet but with the setup we can make some simplifications for example what we could be doing let me actually go to the display surface and let me copy this line here just to illustrate what we can do a very simple example now with our display surface inside of our class so now i can create a new letâ€™s call it custom draw and itself and nothing else for now and really all we need to create our custom draw is for sprite in self.sprites and donâ€™t forget the brackets and now we can get all of the sprites and now all we have to do is self dot display surface dot blit and we need sprite dot image and sprite dot rect so this is essentially what a normal sprite group is going to do and now in our run method we can replace our draw from the original group with custom draw and now we donâ€™t need any arguments because we already have the display surface and letâ€™s run this and itâ€™s still working just fine except now weâ€™re using a custom draw that is going to give us significantly more power and i guess what i can do we can get rid of this debug it isnâ€™t useful anymore now we want to use this for two specific purposes number one we want the camera number two we want some overlap between the different sprites in the y direction and letâ€™s start with the camera thatâ€™s the more important bit and the logic to make the camera work is actually surprisingly simple and all of it happens in the custom draw but by default we are always drawing this bright image in the same position as the sprite rectangle but we donâ€™t have to we can totally give this bright rectangle a certain kind of offset and this is what we are going to use for the camera so really all thatâ€™s going to happen in practice when we are calling blit on the surface we are still going to keep our sprite dot image but now for the sprited rect we are going to add a vector to give them a certain kind of offset and this vector is essentially going to be our camera because itâ€™s going to give us control where the sprites are going to be drawn and then really all we have to do is to get the offset from our player and connect this to this bright rect vector and once we have that we are good to go essentially we are going to give the offset of the world to wherever the player is going to be and well i think this makes much more sense once we actually implement it so letâ€™s go back into the code and here we still have our y sword camera group and what i want to achieve is that the player is always right in the middle of the window but thatâ€™s going to come in just a second first of all let me illustrate what i mean with the offset essentially all thatâ€™s going to happen is weâ€™re going to create a vector letâ€™s call it offset and this offset is going to be pygame.math.vector2 needs to be capitalized and by default is going to be 0 and 0. and this vector we are going to add to our sprite rectangle so all we have to do in here let me create a new letâ€™s call it the offset rectangle and this offset rectangle is going to be the sprite dot direct dot top left and then plus self dot offset and that way we are going to get a new position itâ€™s not a rectangle anymore but well high game is happy with a tubal so this is still fine so now we can do is put this offset rect actually let me call it offset position thatâ€™s going to make more sense so offset position and now anytime we have any kind of offset we are going to add this to our rectangle now right now this is going to be zero so we should not be seeing any kind of change so letâ€™s run main.pi and we still get the same outcome but what we are now able to do is if i give this vector some starting positions letâ€™s say 100 and 200 now if we run out of this our entire game is slightly offset so this is the offset we have just given it so what you can see here is that this distance is 100 and this distance is 200 so essentially our game itself didnâ€™t actually change any kind of position we are just drawing all of the elements in a different spot and the distance to that spot is determined by our offset so this is working really well now next up what i have to figure out is how to connect this offset to my player and since i want the player to be exactly in the middle of the screen i first need half the screen width and half the screen height and we can do this in the init method so letâ€™s call this half with and all we need to get this is self dot display surface dot get underscore size and for x we need zero and we want to floor divide this by two so we are getting an integer now we can do the same thing for the height and all we have to change is from the tube we get from get size we need the first one and thatâ€™s going to be the y one so now we know how much distance we want from the left and from the top so all we have to do in our custom draw i want to get another argument and that is going to be the player so when i call custom draw up here i want to pass in self dot player so now i can access the player and get the player position and let me add another comment here and letâ€™s call it getting the [Music] offset and in here i want self.offset.x and then dot y so now we have to figure out these two positions and unfortunately we couldnâ€™t just add player.rect.center x and player.rect.center y although it would be nice and simple actually letâ€™s try and see what happens if we just use those two numbers so now back in my main file now if i move the player we get something but looks a bit weird but we do get something thatâ€™s at least a start and essentially all we have to do is from this number subtract either self dot half with and self dot half height so now we are getting some kind of weird outcome and i might be able to see the player i could see her there for a bit so now the camera movement is a bit weird and the reason for that is that this plus here should be a negative and now letâ€™s try this again it should work and there we go this feels significantly better and with that we have our offset and if youâ€™re really interested in the math here i would recommend to go over the geometry a couple of times it is a little bit weird but once you go over it it should make sense and probably just draw it out a couple of times eventually it starts to make sense but that is literally all we needed for the camera movement so now we have covered the first part we have a proper camera movement so i guess now we can start working on part number two the overlap and this one consists essentially of two things the first one is a hitbox for all of our sprites so right now for example for our player the hitbox is the entire image but i donâ€™t want that to be the case i want the hitbox of the player to be slightly smaller than the original image and these parts are going to be the overlapping parts but this by itself wouldnâ€™t be enough because our group right now doesnâ€™t know what elements to draw on top and what element to draw on the bottom this is going to be another part we have to make ourselves itâ€™s not actually that difficult but itâ€™s something we have to implement but i guess letâ€™s go through it step by step and letâ€™s first of all start by creating all of our sprites a custom hitbox so here we are back in the code and i want to start with the tile thatâ€™s going to be the easiest one and right now we have our rectangle so this is always going to be the full size of our entire image i want to give it another attribute and that is going to be self dot hit box and the hitbox is going to be essentially the same as self.rect except now we want to change the size and this happens with inflate and what inflate essentially does is it takes a rectangle and it changes the size so in my case really all i want to do is if this is my original rectangle then i want the hitbox to look something like this so we have the same width the same center but the top and the bottom are a bit shorter and that way later on the player could be standing behind this for example and thatâ€™s really the entire idea of all of this and inflate needs two arguments one for x and one for y now my x can just remain zero but for my y i want to have a specific number and letâ€™s say just to get started letâ€™s go with negative 10. oh and by the way this is going to keep the center point at the same position so let me draw all of this again this is our original rectangle and now our hitbox is going to have the same center but now on the top and the bottom we are going to have a 5 pixel because we specified negative 10 up here and negative 10 makes the entire thing shrink by 5 pixels on each side and now we have to do the very same thing for the player and let me do it right below the rectangle so self dot hitbox is going to be self dot wrecked dot inflate and for my player letâ€™s say for now i want to go with 0 and since the player is a little bit taller i want to go with negative 26 and now letâ€™s run the code and well this shouldnâ€™t make any difference for now but at least the code isnâ€™t crashing so thatâ€™s a good start but now essentially what i want to do i am not going to move the rectangle anymore instead iâ€™m going to move the hitbox and iâ€™m going to move the hitbox and check collisions on that hitbox as well and after all of that is done iâ€™m going to put the center of the rectangle where the hitbox is going to be so that way the rectangle always follows the hitbox and that way i can get all the collisions with the hitbox and have some overlaps but then draw the player in the correct position so essentially what we have to do letâ€™s go with move first and letâ€™s get rid of this comment we donâ€™t need that one anymore so instead of self.rec.x we want to move self.hitbox and we want to move both x and y and at the end of all of this we want to get self.rect.center is going to be self.hitbox.center and now what we can do that instead of checking the rectangle of all of the sprites we want to check the hitbox so this should be hitbox and weâ€™re also not going to check the rectangle of our player but the hitbox of our player and this is going to happen for basically all of the rectangles we are going to replace them with the hitbox so this should be hitbox this should be hitbox this should be hitbox hitbox hitbox and finally hitbox and now letâ€™s see if this is going to work so now we can indeed see some offset so right now our player is behind the rocks and this is looking really really good the problem we have now is that our player is always below the rocks so no matter where we go oh except here because these rocks were created earlier in the level setup so these rocks are behind the player because they created earlier in the code but these were created after these were created after and further down here all of these rocks are above our player so this is going to look kind of silly but we are very nearly there so we are making some definite progress thereâ€™s only one more thing that we need so right now we have a custom hitbox for both our player and for our tiles now the last thing we have to do in our ysort camera group we have to order our sprites so we have to tell it when to draw each of these sprites and right now they are being ordered by the time of when they are being created this happens here some of the tiles were created before the player but some tires were created after the player was created so those tiles would be on top of the player whereas the titles created before the player was created they would be below the player and in most situations this really doesnâ€™t matter but in our case we donâ€™t want to order our sprites by that logic instead we want to order our sprites by the y position and essentially the sprite that should be drawn on top should be the one with the highest y position because if the sprite is a lower wide position than another sprite then the sprite that should be behind or high up on the screen should be behind that other sprite in godot for example this is just being called y sword and this is basically what weâ€™re implementing ourselves manually right now and the way we are doing it is by using the sorted function and letâ€™s do this straighten the code so here right now we are just going through all of the sprites but this i donâ€™t want to do anymore instead i want to go with for sprite in sorted and sorted essentially takes two arguments first of all it wants a list of what we want to sort and this we do have itâ€™s just self dot sprites and again donâ€™t forget the brackets itâ€™s very easy to do and next up it wants some kind of key and the key essentially going to be by what kind of metric we are going to sort all of the sprites now in our case this should be the y position of each of the sprites and to get that we basically need a lambda function so lambda and i want to look at this sprite and all i want to return is sprite.rect.center y i guess let me know if you want a specific video on the sorted function once youâ€™re nested lambdas itâ€™s actually pretty simple but now we have overlaps so let me run the code again and now we are still behind the rocks but now if i go a bit further down now we are on top of the rocks but if we go behind them we are well behind them and all of our collisions still work just fine and all of the overlapping works really nicely and this is going to make our game look really good so cool this is working exceptionally well nice there are no bugs so anything this is all working good cool and with that we have a basic top-down game with a camera collisions overlaps and all of the good stuff now i guess for the rest of the game we are just going to add more and more visual detail and enemies and extra stuff to it to make all of this into a proper game but at this stage you already have the basic logic you need to really create any kind of top down game i guess next up we can start working on importing the actual map to make this entire thing look significantly better now for the graphics we are going to need quite a few different things for now we only had our world map and we spawned either a rock or player which really wasnâ€™t ideal but to get the actual graphics of the entire game we are first of all going to need significantly more data and that is going to be way more data than i could assemble by hand so we have to use a program and the program that i am using is called tiled which is super useful completely free and it allows you to assemble graphics and let me actually show how this looks so here we have the tiled editor and right now you can see our entire map and this thing i essentially created from these tiles on the right so here we have all our floor tiles here we have the details we have flowers and we have trees so i could for example literally just pick a tile and draw over this thing and expand it and i have made an entire tutorial on how to use tiled so for this video i am not going to go over it and i will keep the map i have already created so this thing took about an hour possibly a bit more to assemble as a whole actually letâ€™s go through the entire thing layer by layer and then i can explain how this comes together so right now we have nothing and the bottom layer looks like this this is going to be our ground and on top of that we have some details they will be integrated into the ground as well and essentially what iâ€™m going to do i am going to export this entire thing as one image and this one image will be below all of the other objects so even below the player and then if we move this map it looks like our player is moving on top of an actual surface but in reality we are just moving an image now on top of that something we canâ€™t see but thatâ€™s really important is floor blocks and flow blocks if i make it visible is going to be our constraint that our player cannot walk outside of the map so all of these red squares are going to be obstacles that the player cannot cross and they are blocking the entire map so the player cannot leave it and in the game they are not going to be visible so letâ€™s hide them now on top of that we have our entities the blue p is our player and besides that we have all of our enemies now then we have grass and the grass is well the grass and finally we have the larger objects and those are of the statues the trees the rocks all of that kind of stuff and importantly all of the objects the grass the entities and the flow blocks have to be placed by going over the entire layer so we have to circle through the entire layer like we have done for the world map and place all of these elements and to make that work in our game we will later on have to import quite a few different things for example we have to import the graphics for each individual tree and rock and statue into pie game same for all the enemies same for the player and there is going to be a lot of importing and also when we export these data sets we get a csv file which stands for comma separated value which effectively is a long list with numbers and these numbers tell us where stuff needs to be and those numbers we also have to import and all of that gets quite complex so this section will be quite heavy on managing all of that data but i guess letâ€™s go for the step by step and letâ€™s start with the easier bit and that is going to be the floor and for that we are just going to be importing an image and placing it below every other element and then we are good to go here we are back in the code and i want to go to level and all of our drawing is happening in this section down here so essentially this part here draws all of our elements and we kind of want to draw our floor in there as well the problem is that the floor is slightly different from all of the other elements so we couldnâ€™t just add the floor to the sprites and call it a day for the simple reason let me actually draw this that right now we are drawing all of our elements by their y position so this is essentially how our drawing is going to work so the greater of a white position an object has the higher up on this thing is going to be drawn and we are looking at the center of the y position now the problem with that is that our map is always supposed to be on the bottom so our map is always supposed to be here it needs to be below all of the other elements otherwise it wouldnâ€™t be a ground or a floor so we have to place this in here anyway and if we didnâ€™t do it it would end up somewhere letâ€™s say here and since itâ€™s a giant image it would essentially cover up the entire field and we wouldnâ€™t be able to see anything so we have to make sure itâ€™s below all of the other elements so what we are going to do to this group we are going to add a surface and a rectangle for the floor specifically and that is not going to be a sprite but then in this custom draw we are going to draw it and i guess let me implement this straight away so in here creating the floor and for this i need two different parts first of all i need the actual image of the floor so self dot letâ€™s call it floor surface and this is just going to be an image so pygame.image.load and this i need to go up i need to go to my graphics in my graphics thereâ€™s a folder called tilemap and in tile map we have ground dot png and this we also want to convert but we donâ€™t need convert alpha this time and next up since we do want to place it i also want to have self.floor underscore rect and let me call it surf instead of surface so things are lining up a bit nicer and this is just going to be self dot floor surface dot get underscore rect and the top left for now is going to be 0 and 0 but this doesnâ€™t actually matter all that much since we are going to change it well right now and really what we have done so far in our custom map we have created an offset position and the offset position came from the top left of the rectangle and the offset and the offset we got from the player so now what we want to do is the exact same thing except now we only want to do it for the floor surface and not for all of the sprites and this could be a pretty good exercise for you so try to implement the offset for the floor and then draw the floor before the for loop for the sprites now first of all letâ€™s add another section and letâ€™s call this one drawing the floor and first of all we are going to need a floor offset position and this we get in the same way that we have used just before so we want self dot floor rect dot top left and then minus self dot offset and that is going to be all that we need so now we can run self dot display surface dot blit and self dot floor surface and i call this one floor offset position and that is literally all we needed so letâ€™s run this and see what happens and there we go now in the top left of our world we have oh well below our player we have the entire world map now right now we canâ€™t really walk over it and we can well we can kind of walk over it but you get what i mean but right now all of the rocks donâ€™t line up at all anymore so we have to make a few more changes but at the very least for now the basics are working so this is quite nice and now next up we have to work on all of the other objects and this one is going to need a little bit more work but i guess we can start with by removing the old stuff and just placing the player somewhere in the middle of the screen and this is going to happen in our level and let me minimize our camera group so we can focus on this a bit more so right now we are using all of this stuff here to set up our world and this worked so far but now we want to get rid of it so let me comment out essentially all of this except i want to copy the player and now i want to place the player somewhere on the map letâ€™s see what works letâ€™s say 400 and 300 and that might be a good position yeah okay i probably need larger numbers letâ€™s say 2000 and 1500. we are almost there letâ€™s say one thousand four hundred thirty because that way we should be on the path and we make sure we are not going to hit any other tile so our player isnâ€™t going to collide with anything by default but now we can move around our entire map there are no collisions yet but well we have a much better system so now essentially all we have to do is to reintroduce all of the layers and then work with them although they just might be a little bit oversimplifying things so letâ€™s go through what we are going to do first of all we have to make our tile a bit more flexible because so far the rocks are the only tile we could have but in this section we have many more and many more differently sized tiles and we also have some tiles that shouldnâ€™t have any graphic whatsoever for example the tile for the collisions that limit our player they donâ€™t have a graphic but since they are also sprites they will need some kind of surface so essentially our tile class needs to be able to accept any size graphics and also be able to accept no graphics at all and i guess letâ€™s implement this and all of this is going to happen in our title class or well the tile file and this is going to get two more arguments the first one i want to call sprite type because later on we do want to have a bit more control over what kind of sprite we have and besides that i also want to pass in a surface as an argument and this could then be anything but if we donâ€™t pass in any surface this class should generate its own surface so as the default argument here i want to have pygame dot surface so this is just going to give us a black surface that we can work with and the size of that should be tile size and tile size so by now since our tile size is 64. the one we determine here if we donâ€™t pass in the surface as an argument we get a tile size of 64 by 64. and then for the image this is then going to be what we get and besides that i also want to get self.sprite type is going to be sprite type and this later on for example could be an enemy or could be invisible or it could be any of those things and thatâ€™s going to allow us to target in a bit more detail whatâ€™s going to happen to any of these so we are using both groups and the sprite type to determine what a sprite is going to do in the game for example later on if the player attacks grass the grass should disappear immediately but if we attack an enemy we should just reduce the health of the enemy but both of those are going to be in essentially the same groups this is for now all we need for our title class now we can go back to our level and what we first of all have to do is to import all of the layouts because right now let me open them in the folder so in our project we have a map folder and in here we have six different files we donâ€™t need all of them so map floor and map details we could just ignore but floor blocks we do need to import and by default we couldnâ€™t work with a csv file so we have to figure out how to import this kind of file and then convert it so it looks more or less like this world map so that we can work with it and this i still want to do in my create map and since we have a couple of different files i want to turn this into a dictionary and in here letâ€™s start with the easiest one the boundary so this is going to be what limits our player and in here essentially what i want to store is this kind of world map except for all of the boundaries so i have to write a function like import csv layout and this one should then get the path to my csv file something like this so what we have to do is to actually write this function and this since we are going to be using it quite often i put into a separate file so letâ€™s create a new file and i save this one as support dot pi and in here we want to define import csv layout and it needs a path and nothing else and just to demonstrate what iâ€™m doing while weâ€™re doing it letâ€™s call this function and letâ€™s see what it does so right now if i press pass we run this file nothing is going to happen because pass doesnâ€™t do anything now the first thing that we have to do is to figure out how to read a csv file and fortunately python has a module just for that but i donâ€™t want to import all of it instead i want from csv import reader and this is allowing us to read a csv file and now to use it we first have to open the csv file so with open and we pass the path in here and then python wants a name for this file and i called it level map and all of this so far could work for any file so this could also be a text file and unfortunately right now you wouldnâ€™t really be able to see anything so if i print my level map all you would get is something in our memory not particularly helpful but this thing we now have to convert with our reader to something actually readable and the reader needs two arguments first of all the file we want to work with which in our case is level map and besides that it also wants it delimiter and a delimiter in our case is a comma and what it means is what separates each individual entry in our file this could also be a space for example now this information is going to return another value that iâ€™m going to store as layout now unfortunately still if i print the layout now we get a csv reader object so at the very least i guess we know we have a csv object but thatâ€™s about it but now comes the actual part where we get to see something because now what we can do is for row in layout we can print the row and now we can see the actual files so in here we can see a whole lot of negative ones but all the way at the top you can already see we now have a list so here the list starts and the list is ending here and wherever we have a negative 1 there is no tile however if we have 395. so any of these numbers here there should be a constraint for the player so the player wouldnâ€™t be able to move over this tile and itâ€™s really hard to see right now but if all of these tiles were on the same line they would in my tiled editor have the same shape as this red line here but in our case since the line isnâ€™t wide enough this is really hard to see but now all we want to do is to put all of these lists into a separate container which is going to be another list so letâ€™s call this one terrain map and this one is just going to be a list and now for each row that we get from the layout i want to append this to my terrain map so this could just be row although just to be sure i want to convert this row to a list and now the last thing we are going to need is to return that terrain map and now whenever we get this import csv layout we can put all of this for example in a print statement print it and now we get a list that contains a whole bunch of other lists that give us the layout of our map so that is going to be quite useful and now letâ€™s actually go straight ahead and use it so in my level dot pi i now have the boundary for my floor blocks as i called it which is just going to be my boundary now i actually want to place them in the same way i have used it earlier with the tile map but what did i call it my world map so now my boundary has the same kind of layout as this thing except itâ€™s significantly larger so letâ€™s work with it and since itâ€™s so similar we can reuse all of this code except thereâ€™s going to be one modification i want to place all of this inside of another for loop and what the other follow-up is going to be letâ€™s call it style and layout in layout letâ€™s call it layouts that makes a bit more sense dot items and donâ€™t forget the double colon so essentially the style is going to be boundary right now and the layout is going to be this csv map and right now we only have a single one of these so it doesnâ€™t make too much sense however later on we are going to add more and more data in here and then this follow-up is going to make significantly more sense so that way our code is nice and scalable but now we are still looking at the y position we get the x position and we are converting all of this into an x and y position so now we can use this quite well and all we have to do now is if the style is equal to boundary then we can create a new tile so we can now create a new tile group and let me copy all of the parameters place them in here and letâ€™s go for them one by one actually or actually even better try to figure this one out yourself to place in all the proper arguments for each of the parameters to place the boundary for the world map all right letâ€™s go through it one by one first of all position that should be the easiest one because in here we just want to get x and y and thatâ€™s just going to be what we created up here and actually this should be indented one more line next up we want our groups and for now letâ€™s place let me copy from the player i want the visible sprites and i want the obstacle sprites then we need the sprite type and the sprite type i have called invisible because theyâ€™re not supposed to be visible later on and then finally we have our surface and this one we can just ignore since itâ€™s then going to use the default argument and all right that is then going to be all we need for the boundary and letâ€™s actually see what happens so we donâ€™t get an error we do get an error and the error weâ€™re getting is import csv layout is not defined that is an error i tend to make very often fortunately itâ€™s quite easy all i did was i forgot to from support import star so that this function is another file and we didnâ€™t import that file now letâ€™s try this again and now i made another mistake the obstacle sprites are not defined and that is probably because i forgot the self there we go and now if i run the code we can see something strange so at the very least we get some kind of collision although something is definitely gone wrong here and i think i can already tell the problem so right now when we are calling this boundary our boundary is slightly different compared to this map here because for boundary there is no empty space we get a negative one actually in my support file let me open it again so let me copy this one and letâ€™s call import csv layout and letâ€™s print it so what we can see here is the number 395 a whole lot of time and besides that a lot of negative ones and what pygame did it always put a block where we have a negative one but we only want to block at 395 and that was different from our world map so let me get rid of this one again so what we want to do in here when we go through the column we want to add another if statement that if our call is different from the string negative one and only if that is the case we want to do anything in here and negative one in a tiled export means thereâ€™s not supposed to be anything so this negative one would work for any kind of layout so now letâ€™s try this again and letâ€™s see what we get we still get a giant block that seems like something is going wrong with the position so letâ€™s investigate what the problem is and i just realized the problem is i am very very stupid well so in here we are still using the world map we are not actually using the layout so that may have been a problem so now letâ€™s try this again that should fix the issue so now if i go to the right at some point there we go now we have the black coastline that we canâ€™t walk over and we still get our overlap that one works pretty well cool and now we are not able to leave this game anymore but we can still use something like a bridge and we can move on this tiny island and obviously right now we donâ€™t want to draw any of these black tiles and to get rid of them at least in terms of visibility we can just remove the visible spreads group and now letâ€™s run this again now we canâ€™t see them anymore however we can still not move over into the water so this is all working very very nicely this is a very nice upgrade cool okay that took way more time than i expected but well here we are all right so for now we need two more objects we need the grass and we need the objects so all of the trees and the statues and stuff like that and for that first of all we have to import two more csv layouts and let me just copy them thatâ€™s going to save me a bit of writing so one is called grass and the other i have called object so essentially what we need to do with those two is if this style is going to be grass let me just add a comment create a grass tile and if the style thatâ€™s not how you spell that if the tile is object then we want to create an object tile and we do have most of it but we donâ€™t have the most important part we donâ€™t have the graphic for either the grass or any of the objects what we have right now is two folders one with three different grass images and another folder with like 20 different objects and right now those really arenâ€™t usable and i really do not want to import every single one of these images individually so i want to create a function that does all of this for us and this is also quite easily done let me add a path in here so python doesnâ€™t throw an error and in my support file besides import csv layout i want to create another function and i call this one import underscore folder it also needs a path and this one is going to go through a folder import all of these images as a surface into pygame or well into our python code and thereâ€™s one module that we will need for this it is called the os module and i donâ€™t want to get all of os instead i just want to get the one thatâ€™s called walk and walk just allows you to walk through the file system thatâ€™s really all it does and letâ€™s actually check out what it is doing so for data in walk and now we have to add a path and let me use the path for the grass objects that one is looking like this and now letâ€™s just print our data and now letâ€™s run import folder oh i made a mistake the import grass should be what we pass into the function and then walk gets the path from the parameter that looks much cleaner now letâ€™s run this and now we are getting three different bits of information first of all we get the folder name the first bit here in our case we just donâ€™t care about it and we already have it anyway so this one we could just ignore next up we have an empty list this one here and if there was any folder inside of this folder this list would contain the names of these folders in our case we just donâ€™t care about it now finally we have the list of the images or well the files inside of this folder and this is what we care about essentially what we want to do let me clean this up a bit basically what i want to do is i want to combine this path here with any of these names so these three names and that is going to give me a whole file path to that image from my code wherever i run it in my setup and once i have that i can just import this file as a surface so i would just loop over all of these names turn them into a full file path and then import all of this as a surface and that is what we are going to do so first of all let me rename the data and split this into three different parts now for the first one before the name iâ€™m going to use an underscore since i donâ€™t care about the information for the subfolders i can use a double underscore because i donâ€™t care about this either now finally i have the letâ€™s call it the image files this is what i actually care about and this is still going to be a list so i want to split this up so i need another for loop so for image in img files and now if i print each individual image we get the list ideally of our grass images so grass one two and three and now what i can do with them is i can turn them into a full path so right now all we have is strings that we can combine quite easily and what i want to do is to get my path on that iâ€™m going to add the string of a forward slash and to that iâ€™m going to add my image so if i print this full path i have a nice path to my image that i can use to import this image so literally all i want to do letâ€™s call it my image surface i want pygame.image.load i need my full path and donâ€™t forget convert alpha and spelling this correct also helps and this is then going to be our image or our surface now finally we want to return this entire list and right now we canâ€™t really do that so what i usually do is i just create a surface list that by default is empty and then as soon as we create this image surface we get our surface list and we append this image surface and at the end of all of this we are returning the surface list and that way let me print what import folder gives us ah we get an error pi game is not defined because we need to import pygame and i suspect we get another error aya right now we havenâ€™t initialized pygame.display because weâ€™re only running this file by itself so i canâ€™t really show this right now but fortunately when we are running our level we have initiated pi game this happens in the main file so this happens here as a consequence we donâ€™t have to worry about this error youâ€™re gonna see in a second what this means actually letâ€™s import all of the graphics that we need and since we have more than one i want to put this into a dictionary as well so we have graphics itâ€™s going to be a dictionary and in here for now we only have the grass and for the grass i want import underscore folder and i have called it this one here and now we can actually print our graphics so letâ€™s run all of this we get our file no error and now we can see in the dictionary we have grass and we have three surface files inside of a list thatâ€™s exactly what we wanted so all right you can get rid of this and now we can actually work out our grass tiles and essentially what i want to do i want to pick a random image from this folder or from this list and then create a tile with that random image and this could be a really good exercise for you so try to create a tile with the grass and the sprite type should also be grass and see how far you get all right so first of all let me get rid of all of this and the first thing i want is to get a random grass image so we want to pick one item from the list and to do that we need the choice method which we get from random import choice so now in here we can just call choice and get our graphics and i want to get the grass list and once we have that we can just create another tile now the x and y position is still going to be x and y that one didnâ€™t change but now for the groups we want self dot visible sprites and self dot obstacle sprites because the grass is supposed to be visible and collidable and finally i gave those a type of grass and now this should be working and oh yeah i know what i forgot so we can see something but we have a problem and look at this for a second and just think about what i forgot the important thing i forgot was the actual graphic so random grass image now letâ€™s try this again there we go this is much better so now we have our grass image and they are collidable they are very much visible and this is working really well so now we have our grass this is working really nicely i think down here we have quite a few more there we go this is coming together quite well cool so with that we have the grass and then finally we need the larger objects and we already have up here the object in our layout and besides that we are also going to need the graphics and this one i called objects and then here we just want to get the import folder and the file path towards it i have called this and with these two things we have a layout and we have the graphics so we can start working on actually creating these tiles here but now we do have a bit of a problem because for the grass tiles we could just select a random grass tile from the list for the objects we cannot do that because each of these objects is one specific thing that we couldnâ€™t just randomly pick now fortunately that isnâ€™t too much of a problem and let me open tiled again to explain why so here we have tiled and all of the objects are in here and if i click on one letâ€™s say this tree stump this is the id of zero if i go to the next one itâ€™s the id of one then two three four and five and so on and essentially what tiled is exporting is this id and this is really useful because we can use this id to import the index of the image in that folder so when we import the images they are in the list so they can be indexed and the way weâ€™re importing them right now is by the name and since you can see it in the image the name is 0 1 2 and so on so the naming here lines up quite nicely with the file name and that way we can use the id as an index and this means all that we have to do to get our surface we have to get our graphics and in here we want to get the objects and this is then going to return a list and from this list we want to get the index and the index we get is this column here so this is the column we want to use for indexing now right now this column is going to be a string so we want to turn this into an integer and now we can just use this surface so i can just copy the tile we again need x and y then we also want visible and obstacle sprites so i can just copy them and for the type i call this one object and finally for the image we want the surface and that is all we needed almost at least so now if we run this we can see some trees so this is coming together very nicely the problem is this isnâ€™t working perfectly so for example here you can see the flower and the column on top of each other and i think further here that this oneâ€™s actually working quite well um i guess if i go in here you can see a couple of overlapping things that donâ€™t look as good as they should be oh especially down here you can see some problems and the problem is this in our tile.pi right now we are basically assuming that all of the files or all of the images are 64x64 pixels but the larger objects really arenâ€™t that and let me explain this issue entitled now here we can see the thing that we just saw doesnâ€™t work in code and the problem is this that in tile we always assume we have a 64 by 64 tile grid and this works for most of the objects like the grass for example where it doesnâ€™t work is with these larger objects so this column here for example is much larger than 64 pixels and we are always placing the top left of this column but since this is larger than 64 pixels we are placing this column somewhere here on this line so we are placing it here as a matter of fact all of these larger elements are a bit further down than they are supposed to be but thatâ€™s something we can fix quite easily so let me go back in the code and when we are placing the rectangle now we have to adjust things a tiny bit and essentially what i want to check if this bright type is equal to object because those are the only things that are going to be larger than that and these we get from object here and weâ€™re placing them in here and that way we do have access to them and if they are an object we want to do an offset but if theyâ€™re not an object we just want else else and do the thing we have already done and the rest can stay exactly the same now if we do have an object we still want to get self.write and we still want to get self.image.get underscore act and we are still placing the top left but now we are still placing it x and y as well and the x stays exactly the same so this is going to be position zero so we are splitting apart this position into the first and the second integer and now for the y we have to make a tiny adjustment i guess we still want the first index but now we have to reduce a tiny amount from that and here our life is going to be made a tiny bit easier because all of these larger objects have twice the height of all of the other elements so really all we have to do is to subtract the tile size from it here is a normal tile itâ€™s 64 by 64 pixels and the larger tiles look either like this where we have 64 by 128 or we have even larger tiles that look something like this well we have 128 and 128 and the problem that we faced is that all of these tiles are being offset over here so the position we want to place is actually this one instead of this one so what we want to do is to just move any of these larger objects a little bit further up and since theyâ€™re always the same height with 128 pixels we can just move them up by 64 pixels or exactly the tile size which is making our life significantly easier and all right thatâ€™s all we needed so now letâ€™s run this we donâ€™t get an error and that is looking quite good i canâ€™t see any overlaps this is also looking really good and yeah i think we have a pretty nice looking map that is coming together very much so all right with that we can get rid of these old comments and we can get rid of in our settings of the world map we donâ€™t need it anymore so i guess with that we can start working on a better looking player so we have the different kind of animations and that is going to be the next section so letâ€™s talk about the player animation and to make our player animations work we have to figure out what our player is doing at any given time so what the status of the player is and at the end of the day there are going to be 12 different states our player can have we can either walk in any of the four directions we can be idle in any of these directions or we can be attacking in any of these four directions so itâ€™s going to be 4 times 3 and thatâ€™s how we get to 12 different states and in the most basic sense all we really have to do is whenever there is a certain kind of state we are going to play a certain kind of animation thatâ€™s the easiest way to think about it but thatâ€™s still quite a bit away first of all we have to import all of these graphics and we also have to give our player the ability to attack and to cast magic and i guess we should work on those two first here we are back in the code and i only want to work on my player we donâ€™t need anything else right now as a matter of fact let me minimize the functions so itâ€™s a bit easier to see what we are doing that makes a bit more sense first of all in my input here we are getting the input to move around and i want to get a few more and let me actually add a few more comments so this here is the movement input and down here we have the attack input and then a bit further we get the magic input and for the attack input we can still use our keys so if keys and in my case i use pygame dot k underscore space so the spacebar means that we are attacking and for now if we are attacking let me just print attack and now we can do the same thing for the magic i can just copy all of this and and for magic i use the left control which is triggered with lc tr so left control and if that is being triggered i want to cast some magic and now if i run this we donâ€™t get an error if i press space we get attack if i press ctrl we get magic so thatâ€™s a good start but there is a bit of a problem right now let me run the game again so if you press attack we attack multiple times same for the magic and the reason for that is that our game runs at 60 frames per second if we press space once pygame checks for this multiple times a second and it finds the bar being pressed for longer than a few milliseconds thatâ€™s why it triggers it multiple times so for these two if statements we have to add a timer that can only be triggered every few milliseconds so in our player let me add another section or itâ€™s our first section here actually and letâ€™s call those um i guess we can call them movement letâ€™s just give it a movement and we can put them up here and in here i also want to create a few more variables or attributes first of all the first point is called attacking and by default itâ€™s going to be false next up i want to have a self dot attack cool down and letâ€™s put this one for now at 400 i think is a good number and finally self dot attack time and by default this is none or could be zero doesnâ€™t really matter and these three numbers we are going to use to create a timer so what i want to do whenever we call keys for attacking and for magic we also want to check that our player currently is not self dot attacking and this we want to do for both magic and attacking and those two get the same variable for the timer because i want that to be an offset that the player canâ€™t cast an attack and magic at the same time or really fast after each other now once we are calling either of these i want to set self dot attacking to true and let me copy it to both and now what we should be seeing is that we can attack or cast magic once so let me press space for attack and now i keep on pressing space or control nothing happens and there shouldnâ€™t be anything happening because now attacking is true so this if statement cannot trigger anymore but obviously eventually we do want to attack again so we want to create another method that i am going to call cool downs needs self and nothing else and in here we are going to have all of our cool downs and let me explain the logic so i explained this a couple of times but the problem is that high game by itself doesnâ€™t have a timer function so we couldnâ€™t just tell pygame to do something in half a second it just doesnâ€™t have that and also i should check my spelling so instead we have to create our own timer which we can do and essentially what we want to do so here we have the timeline of our game so this is time 0 and this is time x this is the maximum time once we close the game and we want to check two things we want to check when our attack has occurred so let me use this in a different color letâ€™s say our attack occurred right here at around letâ€™s say milliseconds at 700. and now from this point we want to continuously measure our time so as the game goes on we want to check what the time is so for example here we could have 800 here could be 900 here we could have a thousand and here we could have 1100 and what we basically want to check let me write it so 1100 now what we basically want to check is this distance here and that is going to be our timer i have actually made a video specifically on timers but really all we are checking is one point in time and then we continuously check the time and if difference between our current time and our starting time is greater than our cooldown in this case then we want to trigger whatever code we have so i hope that makes sense we need to get our current time and stored in the variable and to get our current time we need pygame dot time dot get underscore ticks so this is going to continuously measure what our time is and the other thing we need is when the attack actually occurred and this we can get up here so what we want to do in here is self dot attack time this is going to be pygame.time.getticks as well now a really important thing here is that this sketch is only called once and once only because this if statement is only going to be run once however this get ticks down here will be run basically infinitely because thereâ€™s no restriction on it and weâ€™re going to put this cooldown in the update method in just a second so to get ticks down here is being run multiple times they get ticks up here is only run once thatâ€™s how these two functions differ okay but now all we have to do is letâ€™s say if self dot attacking because thatâ€™s the only reason why we reject this if our current time minus self dot attacking time is greater or equal than self dot cool down should just be cool down did i make a typo again oh i put this down as attack cooldown so letâ€™s call it attack cooldown and if that is the case self dot attacking should just be false again and that is a very simple timer and later on we are going to add a few more timers in here for example when the player is vulnerable or when the player is switching a weapon but this is the most basic one and now all we have to do letâ€™s put it right on the input self dot cool downs and now letâ€™s try this again i can press space we only get it once but if i keep on pressing it it only happens after about half a second and this also works oh um magic is still a bit different so letâ€™s have a look ah the problem for magic is we didnâ€™t set the starting time so this is what we need now letâ€™s run this again and now both magic and attack work much better so now our player has the ability to move around up here and to attack and cast magic at least in theory so now we can actually import all of the animations to show what the player is doing and that is going to become quite extensive so let me minimize all of the functions and put all of this in a new method and letâ€™s call it import player assets needs self and nothing else and then here first of all i want to get my character path to the folder this shouldnâ€™t be capitalized and the path to my folder is going to be one fold up then graphics and then the player and then forward slash donâ€™t forget that because in this folder there are a couple of subfolders and now we need all the different states that our player can have and this i want to put in a dictionary because this will get quite extensive and let me just copy all of this itâ€™s going to look like this and thereâ€™s a bit much white space like this so this is what i talked about earlier we have the animation states for the player walking in all the four directions the player being idle in all the four directions and the player attacking in all of the four directions so these are all the possible states the player can have and if you look at the folders they are named in the exact same way and that makes it really easy for us to use the names of these dictionary entries to import all of the graphics so what i can do now is for animation in self dot animations dot keys letâ€™s say if i just print it to illustrate what iâ€™m getting so animation and in the init method i want to call this so letâ€™s put it right at the beginning in here and letâ€™s call it a graphics setup and self dot import player assets and now if i run the game we can see we have all of our different states the player can have thatâ€™s working quite well and keep in mind those are names for folders we are not working with images yet but basically what i want to do i want to combine this player path here with all of these different subfolders and that is actually going to look really similar compared to our support file here so to what we have done with this and then once i have the full path i want to use my input folder function and fill the list for each of the states with the graphics from each folder and this might be a good exercise for you try to figure this out yourself that you go through every single animation you create a full path you use the input for the function to fill each of these folders with the associated images so try to do this yourself first of all we are going to need our full path and the full path is just going to be the character path plus the animation and now for each self dot animations and we can target the animation i want to set each of these lists to my import folder and this import folder i have to import into my player so from support import import folder and now my input folder just needs a path and that is going to be my full path so at the end of all of this let me just print my self dot animations and letâ€™s see what we get letâ€™s open certain error that looks good in here you can see for example we have up so thatâ€™s walking up and there are a bunch of different surfaces in there next up we have down more surfaces then we have left at some point we have right then we have right idle and all of the different states are in here which is exactly what we wanted so now we have effectively imported all of the assets for our player so now we can minimize this method and not worry about it anymore with that we have covered the first part that we have figured out how to get the resources into our player now next up we have to figure out how to actually play all of these states and for that we have to talk about state management and essentially what we are going to do our player is going to get an attribute called self.status and this self.status is going to correspond with one of the keys in self.animation so for example it could be up down left right up idle left idle left attack up attack any of those and for example if it is up we are going to pick all the surfaces inside of the up folder and play those repeatedly so with that we have to figure out our state management and really what this one comes down to is we are going to look at our player direction and our player input and see what kind of movement the player is doing for example in our direction vector if we have something like 1 and 0 we know our player is moving to the right and just now from the timer if self.attacking is true we know the player has just been attacking so we want to play the attack animation and really all we are going to do is figure out the right condition for each of the 12 possible states and once we have that we can display an animation and be done with it so letâ€™s try to figure out some states here we are back in the code and letâ€™s put it under graphic setup self.status and letâ€™s say by default this is going to be down and now we also want to create another method and i call this one get status and itself and nothing else as always and in here we have to figure out how to get all of the different states and letâ€™s start with the easiest one the idle status and this one is actually fairly easy all we want to check is if self.direction.x is equal to zero and self.direction.y is equal to zero but now we have a problem and let me actually illustrate this by drawing so here is our player and right now we know our player is not moving so we want to play the idle animation now the problem that we have is that we donâ€™t know what direction our player was working so we have four different idle statuses we have down left up or right but right now all we know is that our player is idling we donâ€™t know in which direction he or she is idling and that is something we do have to figure out and i guess there are two ways to figure this out one way we could look at the direction before the player stopped moving so for example the direction before we stopped was positive one here the player was probably walking to the right but that would involve quite a bit of extra code that would be a bit annoying to work with so instead what iâ€™m going to do iâ€™m going to check the current status so for example right now itâ€™s down which means the player is walking downwards and all iâ€™m really going to do is to add towards this and idle so that way i keep my downwards movement but now instead of walking itâ€™s going to be idle and really what we are doing i think the best way to think about this is if i show the animations so here we have up down left and right and then for idle we have right idle left idle up idle and down idle so to move from up to up idle all we have to add is underscore idle and the naming here is very intentional itâ€™s the same for attack so if we are moving right and we are attacking we just have to add underscore attack to up and we go from walking to the right to attacking to the right so basically all iâ€™m going to do is instead of overwriting self.status i am just going self dot status last underscore idle and now what we can do in the update method letâ€™s say after cooldowns self dot get status and i guess what we can do we havenâ€™t used our debug method in a while i still have it i donâ€™t uh letâ€™s do this in the player so in here right now we have our run method and i want to call debug or myself.player.status just to see whatâ€™s going on because right now we donâ€™t have an animation we just have the status so letâ€™s see what itâ€™s doing so right now you can see the problem that we keep on adding idle to it and we also donâ€™t get updated down not working too well yet and i guess i jumped a little bit had with the idle here because we first want to figure out the walking directions and this happens in the input method because we know if we are pressing up our player is going to move up so what we can do in here itself.status is going to be up and we can do the same thing for down and we can do the same thing for right and then finally we have left so this way we are just determining the directions and let me minimize input again and letâ€™s comment out get is for now just so not be confusing so now main.pi we have down we have right left up and down so this is working pretty well and even if i stop moving it still says right left down and up so these directions are working really really well the problem is right now i have no way to separate between our player walking and our player idling and that is what we have to work on and this is what all of this code here is for i should have planned that a little bit better sorry about that so now if i uncomment this method here what we basically get is if we are moving things are well but now if i stop moving we keep on adding idle and well itâ€™s not particularly helpful oh and what is annoying me i donâ€™t want to print self.animations all right now the problem is we donâ€™t check if our status already has idle in there so we have to add another if statement that if not idle in self dot status so what we basically do we first of all check if our direction for x and y is zero thatâ€™s this part here so then we would assume if we are not moving we are idling now next up we are checking if our status doesnâ€™t already contain the idle part and only if that is the case we are going to add underscore idle to our status and that way we are only adding idle once and not multiple times at least hopefully letâ€™s check this now so we have down idle we have up idle left if i stop moving that looks pretty good so now we have some nice upgrades although if i now attack it doesnâ€™t change anything but the animation i want to play should be left attack or down attack so thatâ€™s the next part and that is just going to be another if statement so if self dot attacking first of all i donâ€™t want the player to be able to move and attack at the same time so if we are attacking self.direction dot x should be zero and the same for y and now basically what we want to do is copy this line here and let me actually just copy the entire thing and i first want to check if we donâ€™t already have attack in our status and if that is not the case i want to add attack to my status and this is i guess kind of going to work letâ€™s try so now we have down idle up this is the working and now if i press attack we get left idle attack and right idle attack and well itâ€™s kind of working but the problem we have is that we only want left underscore attack we donâ€™t want the idle in there so what we want to do for attack is that we donâ€™t want to just attach a tag we want to remove idle if it is in there and the same thing here that if we are attacking we donâ€™t want the player to play the idle animation or to add the idle tag and this is just a matter of another if statement or well a longer if statement so for example for the status if not idle and self.status and not attack in self. status so now we are checking if the player isnâ€™t moving and we donâ€™t already idle or we are attacking and only if neither of these are true then our player is going to idle now at the same time for the other if statement we first want to add another if statement so in idle in self.status so if that is the case we want to overwrite idle but if that is not the case then we can just add attack to the status but now we want to overwrite the idle and this is done with self dot status is going to be self dot status dot replace and here we have idle and we want to replace it with underscore attack and that is technically all we need so now letâ€™s move up down left and right that is still working now if i stop we have left idle right idle up idle and down idle and now if i attack with down attack left attack right attack and up attack but the one final problem we have is that you can still see it in the top upper tag still sticks around so what i want to do after self.attacking is over up attack should automatically switch back to up idle and thatâ€™s going to be the final bit and this is going to still happen in get status and this could also be a pretty good exercise so one self.attacking is false i want to remove the attack and self.status so try to figure this out yourself all right so we know this if self.attacking is only going to run if self.attacking is true so if we had an else statement at the bottom here we are checking if self.attacking is going to be false and in here all we want to do is self.status is going to be self.status.replace and now we want to replace underscore attack with an empty string although this by itself might throw an arrow because python might try to remove attack if thereâ€™s no attack in the string so this needs to have another if statement that if attack in self dot status so now this should be working and i guess with that we have our player status letâ€™s try so down idle up idle attack we go back to idle we have left right i can attack i go back to idle this also works with magic and yeah this is working really good cool so this is then going to be our get status now i can minimize this and now we come to the finally good part where we actually animate our player so letâ€™s really briefly talk about the logic for the animation it really isnâ€™t all that difficult essentially all we have to do right now we always have the same image for our sprite and for an animation all we want to do is to loop over a list of different images for example if our player is moving to the right we have five different images to loop over for the animation and once we have that we are well we are good to go it really isnâ€™t that complicated so all that we have to figure out in our code is how to quickly loop over different sprites in our animation frames and letâ€™s do this straighten the code that should be the easiest here we are back in our player and i want to create a new method letâ€™s put it all the way down here and i call this one animate we need self and no other arguments and first of all i want to have an animation and the animation is going to be self dot animations and then we get the key from self dot status so if i open the play assets again our player status can only be any of these 12 states so if we pick any of these keys we are going to get a list with the right animation that we want to loop over so thatâ€™s the first part now next up we have to give our player a couple of extra attributes and letâ€™s put them all the way up here first of all we need self dot frame underscore index which by default is zero and then self dot animation underscore speed and in my case this is going to be 0.15 now let me minimize this again and essentially what we are going to do now is that we are going to loop over the frame index so really what i want to do is self dot frame index plus equal self dot animation speed so this is going to give me a continuously larger number and let me actually draw this so weâ€™re going to start at zero and then weâ€™re going to get larger and larger numbers and letâ€™s say eventually we want to pick one we want to pick two we want to pick three we want to pick four and so on but the problem we have right now is that our animation so this thing here has a finite number of frames so we want to make sure that once we reach the end of this list we want to go back all the way to zero and this we can do simply by checking if self dot frame index is greater or equal than the length of our animation and if that is the case self dot frame index is going to be zero all we are doing is we are increasing a number and once the number is larger than the length of our animation frame index goes back to zero so that way we continuously loop over our list so that should be a pretty easy part now next up we want to actually set the image and all we have to do here is to create a new self.image and the image we want to get is from our animation and in here we want to get self dot frame index however right now pi game or python in general for this indexing expects number like 0 or 1 or 2 essentially an integer the problem is our animation speed is 0.15 so a floating point number hence if we passed this number in here python would be very unhappy so we have to convert this frame index to an integer which we can do very easily with the end function and we are good to go although thereâ€™s one more thing i do want to do that if we are changing the image we also want to update the rectangle again so self.image.get and the center is going to be where our self.hitbox.center was in the last frame the reason here is that different images of our player have different dimensions so if we didnâ€™t update the rectangle the player might shift by a couple of pixels around it would make it look slightly weird but thatâ€™s really all we needed so now after get status self dot animate and letâ€™s see how this is going to look so now the player can move up left right and things are looking good so now if i attack we get an attack animation now the sword and the magic attack are the same but well doesnâ€™t really matter however thereâ€™s one last thing i do want to fix because right now let me run the code again so if i attack i can move to the left i think itâ€™s good to see now and i donâ€™t want the player to be able to change direction mid attack essentially i donâ€™t want a player to do any keyboard input during an attack anyway so what i want to do let me minimize animate and go back to input i only want to do all of this if the player so if not self dot attacking and now i canâ€™t do anything during an attack i guess with that we can also remove these lines here because they are not necessary anymore so now letâ€™s try this again still feels pretty good and yeah is working really well so with that we have player animations and for the next part letâ€™s add some weapons and essentially all that we are going to do whenever the player presses attack weâ€™re going to create a new sprite with any of the weapons we have quite a few different ones actually and that way we can already see the weapon the only thing we really have to do is to work with the position and then destroy weapon one self.attacking of the player is over but thatâ€™s basically it essentially what we are doing is we are creating a sprite for a short period of time and that sprite shows the weapon of the player and later on we will have to add a bit more to make the weapon actually do anything but that comes later i guess for now letâ€™s actually show the weapon and the first thing we will need is some data so letâ€™s start working on that straight in our code here i am back in the file and i want to keep my data broadly in settings and right now it doesnâ€™t actually have that much so i want to import oh well not import but rather paste one dictionary that looks like this and this one has our weapon data so in here we have our sword our lance our x our repair rapier whatever itâ€™s called and our sigh and each has its own cooldown its own damage and its own graphic that we are going to show later in the ui and now that we have that i want to create a new class but let me first close debug and tiled so you can see all of the tabs i guess we can also close support we donâ€™t need those anymore so now i want to create a new file that iâ€™m going to save as weapon dot pi and then here we are going to need the usual so import by game and then we have to create a class that iâ€™m going to call weapon and this one is going to be a sprite so we need pygame.sprite.sprite and then we have our init method for now weâ€™re just going to go with self and then as always we need super dunder in it and now we have to figure out well we have to figure out two major things the first one is self.image and the second one is self.wrecked and let me actually draw what iâ€™m hoping to do this square here is our player and our player is facing to the right and essentially what we want to do with our weapon is to spawn another sprite that essentially starts at the right side of our player and then stays roughly here so for now what we have to figure out is what is the direction of the player and from that how can we use that direction to spawn the weapon to that side of the player and i guess just to keep things simple for now our self.image is just going to be pygame dot surface with uh letâ€™s say 40 and 40. so for now itâ€™s just going to be a black square but later on itâ€™s gonna be a proper graphic so we have to figure out the rectangle the problem is to figure out the right position we need our player since our weapon is supposed to be right next to the player so we have to import letâ€™s say the actual player and i guess while we add it we can also add groups to know where the groups are supposed to be and for now just to have something letâ€™s say our rect is going to be self.image.get underscore rect and the center is going to be just on top of the player so player dot rect dot center and to spawn that weapon we need a two-step process first of all in our level this is where our weapon has to be let me actually minimize all of this so itâ€™s a bit easier to see so right now in our level class we have all of our well sprites all of our everything so my weapon has to be in here as well and that way itâ€™s later possible to interact between a weapon and an enemy or between the grass so our weapon has to be available inside of the level the problem is we are getting the attack input from our player so from this line here so our attack happens inside of the player but we want to sort inside of our level thatâ€™s the main problem we have right now so we have to get around that and that fortunately is quite easy essentially what we are going to do in our level class we are going to create another method and letâ€™s call it create attack needs self and nothing else and what we want to do in here is to create our weapon and for that we also have to import it so from weapon import weapon and now let me copy the parameters again so we can figure out the arguments so our player we do have we created this in create map so our player is stored right now in self. player down here so i can literally just copy this one and paste it in here and let me minimize this again that makes our class significantly easier to read now for the groups for now i want this thing to just be in self dot visible sprites and well that is it for this method at least for now now next up what i want to do in my create map when i create a player i want to pass this method in here so self.create attack and really important here we are passing the function into this method we are not calling the function so there should not be brackets let me actually cross it out so these brackets here should not be there if they are there you are going to get some weird result because this function we want to call from inside of the player so inside of my player let me minimize everything in here as well there we go so now in our init method for the player we have another argument that we called create attack and letâ€™s put this under i guess movement works so self dot create attack itâ€™s just going to be create attack and now we have this method here available inside of our player and now what we can do in our input method we can call under create input instead of attack we can call self dot create attack and now we have no arguments so it should be fine by itself so letâ€™s run this and letâ€™s see what happens so now if i press space we can see a black square on top of our player and that is going to be our weapon cool so this is working already so now with our level and our player we have the ability to create a weapon although granted itâ€™s not particularly helpful right now but thatâ€™s something we can work on and there are two things we essentially have to figure out the first one is where to place the weapon and the second one is how to figure out the graphic for the weapon because each direction is going to be different and since we already talked about the direction letâ€™s talk about with the placement of the weapon but let me actually separate this so here we want to talk about the graphic and then a bit further down we want to talk about the placement now in either of these cases we need the direction of the player because if the player is moving to the right we want to place the weapon to the right and also show the right image of the weapon so we have to figure out letâ€™s do it all the way at the top letâ€™s call it direction and this i think could be a pretty good exercise so try from the player to get our direction so our player has a ton of different attributes that he could be using try to figure out one so he can reliably tell which way the player is facing i guess there are two ways you could approach this you could either look at the status of the player or at the direction they both would work but in my case self.status i think is the easier one so thatâ€™s the one i am going to use so really all iâ€™m going to do is player and status and what i want to get essentially is let me illustrate it here so i want to have these four directions so up down left and right my problem right now is that i have to get rid of these other directions so right idle would be kind of annoying but this is fortunately quite easy to get rid of because for that we have the split method and split method needs two arguments the first one is at which character we want to split things in my case at the underscore because back my player the up for example is split from the idle by the underscore so if we split this string by the underscore we get up and idle so thatâ€™s then the first thing iâ€™m caring about and you could also pass in a second argument that tells you how many times you could potentially split the string but in my case that shouldnâ€™t matter and now letâ€™s actually print what we get thatâ€™s probably the easiest way to illustrate this so now when i run this again i press space now we get right now down and idle now if i move up we get up we get left and idle right down left this is working pretty good now what you do notice if we only stand and we have up and idle then python splits this but if we are moving and we only have up then we only get a single element but in both cases this is working really well so essentially this split method here if it doesnâ€™t find an underscore itâ€™s just going to ignore whatever it has but now we have a list of our directions and if the player is idling or not now the information if the player idles i was attacking i donâ€™t care about so iâ€™m just going to pick the item with the index 0 because our string is always going to start with the direction which is the only part i really care about so with this simple line we already have the direction of our player so with that we can start figuring out the positioning of our weapon so if direction is equal to right i now have to figure out a different kind of rectangle and again let me visualize what i want to do and let me draw it a little bit larger so here we have our player and the weapon should be if weâ€™re moving to the right should be right here and i would invite you to think about how we could place the weapon in the middle of the player to the right of the player so that theyâ€™re right next to each other and do think about this for just a second basically what i am going to do is our player has a mid right position of the rectangle so thatâ€™s the position we are going to use for the player and then when we are placing the weapon we are going to place the mid left so letâ€™s call this one ml and this one is going to be m r so if we place those two points in such a way we would have both of these right next to each other when my player is walking to the right i want to place the mid left of my weapon and the position where i want to place it is at the mid right of my player and for now letâ€™s just add an else statement so we have something so self.rect is self.image.get underscore rect and center is going to be [Music] layer.rect.center so we donâ€™t get an error but now if weâ€™re running the game and weâ€™re moving to the right our rectangle should be spawned to the right of the player so letâ€™s try this and if i move to the right we get indeed something that almost works so we have our rectangle of the weapons pointing to the right of the player but if we look a bit closely and during the attack animation our playerâ€™s hand is a bit too low and the reason for that is that the player hand is a bit below the middle part of the sprite so we donâ€™t actually want to spawn our weapon right in the middle of the player we want to give it a tiny offset and this we can add quite easily actually so this position here right now is a tiny bit too high but really all we have to do to change it is pygame.math.vector2 [Music] and we donâ€™t want to move it in the x position but we do want to move it down by 16 pixels so now letâ€™s try this again and now we have a weapon exactly where the hand is supposed to be so with that we have one direction now all we have to do is figure out all of the other directions so l if direction is equal to left and for this one i can just copy paste the right direction and change mid left to mid right and then mid right to mid left and the vector can actually stay the same that oneâ€™s perfectly fine so now if i move right still works if i move left name left is not defined letâ€™s have a look ah should be in quotation marks so now letâ€™s try this again so right is still working and left is still working so cool now we already have two directions that work just fine okay now next up we have l if direction is going to be down and i guess let me copy the line again except now we want to place the mid top of our weapon and we want to place this at the mid bottom of our player and now for the vectors we do have to make a slight adjustment so in this case we do want to move the x position but not the y position so letâ€™s try this and we have right we have left and now we have down this one also seems to work so the one thing left is up and this we could put in the else statement so in here we want to place the mid bottom of our weapon and it should be in the mid top of our player and then we want to add this vector to it now we should have the placement of our weapon so down all directions look pretty good so i canâ€™t see any problems with this nice so with that we have the placement of our weapon obviously right now doesnâ€™t look very good because we have to figure out the actual graphics of the weapon now fortunately this is quite simple and let me show you the folder setup so here we have all of our folders and the one i care about right now is weapons and inside of weapons we have our five different weapons now if i go inside of sword we can see down full left right and up and the full sword is the one thatâ€™s going to be in the ui but all the other directions we are going to actually display in the game and notice here down is exactly named like the direction or the status of our player so we can use the string of our player to select a specific weapon inside of this folder which is exactly the idea here although before we can actually select any direction we first have to select the weapon we actually want to use so we have to tell our player what weapon is currently selected and that is the first one we have to work on so let me do it straight back in the code so here weâ€™re back in the weapon code and right now we want to pick one image of the weapon but to pick the right weapon we need to know what weapon the player has selected and this i want to keep in the player so let me minimize this one again the input as well so in the movement let me actually add a whole new section here and letâ€™s call this one uh letâ€™s call it a weapon i guess that works and then here we can actually put create a tag as well that works a bit better now what i want to do in here is self dot weapon index and right now itâ€™s zero and later on this is the number we are going to change to select different weapons and how that is basically going to work is iâ€™m going to get my self.weapon and this is going to cycle through this weapon data list here and we are already importing all of the settings so i can just use weapon data so i want to get one specific key from this weapon data and to get that we need a couple of different things first of all right now we only care about the keys so in our weapon if we have a sword allowance an x or any of the other weapons and from this i want to get myself dot weapon index so for example if our weapon index is zero i want to pick the sword if my weapon index was 1 it would be the lance but right now this would not be working because what keys returns isnâ€™t the list that you can index from apparently so we have to turn it into a list and now we can just pick from this list with a different index and let me demonstrate so print self dot web pin and in theory now if we start the game we should be getting sword so letâ€™s try it and windy gets sword so this is actually working nice so now we know what weapon our player is supposed to have with that information back in my weapon i can now get a full path to that weapon and that is going to become an f string and first of all we have to go up to the graphics folder and inside of the graphics folder we have to go to weapons now inside of weapons we have to get the specific kind of weapon our player has selected fortunately the naming of the variable is the same as the folder so we can just go with player dot weapon now next up we want to select the right direction and this we get with direction and finally all we need is dot png so now we have the weapon and the direction so really all we have to do now is use pygame.image.load and import the full path and as always donâ€™t forget to convert alpha all of this and technically this is all we needed so now letâ€™s run this and now if i press to the right we get an error and you can see down here we have graphics swords weapons sword right essentially i forgot one slash so back in my weapon after weapons there should be forward slash so now letâ€™s try this again and there we go we have a sword that works in all the different directions and thatâ€™s a pretty good start although you can see the problem right now our weapon does stick around which is not ideal although itâ€™s kind of looking funny but okay cool this is working pretty well so the last thing we have to figure out is how to despawn the weapon once itâ€™s supposed to end and this i am also going to do in my level.pi file and in here let me minimize everything again i just want to create another method that iâ€™m going to call destroy weapon and in itself and nothing else and now i want to first check if this weapon exists in the first place now right now we canâ€™t really do this because we have no way to identify if this thing exists so i want to store it in its own variable so in my init method iâ€™m going to create letâ€™s put it actually even better letâ€™s add a whole another section and letâ€™s call it the attack sprites because thereâ€™s going to be a bit more later on but for now i just want to have self.current attack and itâ€™s going to be none by default and then when we create the weapon itâ€™s going to be stored in self dot current attack so now in our destroy weapon all we have to do is if self dot current attack exists then we want to get self.current attack and kill it and i guess just for good form we can also set self.current attack back to none and now all we have to figure out is how to call this method here and i think this could be a pretty good exercise for you so try to figure it out and itâ€™s going to work in a very similar way compared to create a tag so let me minimize the init method again and in my create map i have already put self.create attack in there and now besides that i also want self self. destroy weapon oh i just realized the naming here isnâ€™t ideal letâ€™s call it destroy attack and destroy attack and here as well that way our naming is a bit more consistent okay and then in our player we now want self dot destroy attack as well and that one is just going to be destroy the tag and this one then is going to be another parameter so now we can call destroy tag inside of our player we just have to figure out when to call it and the answer in my case is in my cooldowns because we know after this cooldown our playerâ€™s attack is supposed to be over so we can attack again so what we can do in here is self dot destroy attack and that is all we needed i believe so now i can attack in each direction and we can see the weapon so this is actually coming together really nicely and on top of that our weapon is also obeying the drawing order so itâ€™s drawn above or below different sprites so all of this is working super well now i guess thereâ€™s one more thing that we do have to implement because right now we cannot switch between different weapons or well i guess we can if we go to my player and we change weapon index letâ€™s say to a free letâ€™s see what we get if i now press now we get the whatever this weapon is called but itâ€™s definitely working so we have to figure out in code how to change this weapon index from inside of the game and well letâ€™s do this in the input so in here we already have quite a few different things and i just want to add another if statement and in my case if keys now in my case the key i am using to switch the weapon is q so pygame dot k underscore q and in the most basic sense all that this one is supposed to do is get myself dot weapon index and add 1 to it unfortunately by itself itâ€™s not that easy for the same problem that we have seen with the attack and the magic input that if we didnâ€™t add a timer in here pygame would press or would trigger this code very often because the normal button press for normal human being is going to be letâ€™s say half a second long now for pygame half a second is a lot of frames in our game and for each of those frames this button would be pressed so if we press this button once python would update weapon index with plus 1 probably about 10 times so instead we have to create another timer like we have done earlier and now this timer has to be independent from the attack and the magic one because the player should be able to switch weapons at basically any time so i want to create another timer and the first we have to do for that is letâ€™s say in my weapon i think it makes sense there and what i want to create in here is going to look very similar compared to these lines here so first of all i want to create another variable that i called can switch underscore weapon and by default this one should be true and then besides that i want to have self dot weapons switch time and this by default is going to be none so thatâ€™s the equivalent of our attack time now finally we need to cool down duration and in my case itâ€™s going to be the same thing for the weapon and for the magic switching so we can call this one self dot switch duration cooldown and this one i put at 200 so now we have all we need to create a basic timer so now back in this line here i only want to trigger the cue press if we press the button and if self dot canâ€™t switch weapon is true and if we have pressed it then self dot canâ€™t switch weapon should be false and just like we have done up here we also want to get the time that we press this button so self dot i think what did i call it weapon switch time so weapons which time is going to be dot time dot get underscore ticks and only once that is the case we want to update our weapon with plus equal one and let me just check if iâ€™m starting at weapon zero yep so now in the game secondly we should be able to switch our weapon once letâ€™s try so right now if i press the attack we get our sword now if i press q we still get our sword and i think i know why so back in my player we are updating our weapon index but if i go up to the init method we have changed right now our weapon index but what we have not updated is our actual weapon so this was only set in the init method but itâ€™s not being updated when we press the button so thatâ€™s what we have to do as well and let me just copy the entire list i think thatâ€™s the easiest way to approach this so after iâ€™ve updated the index i also want to update myself.weapon and this happens basically with the same line well exactly with the same line so now letâ€™s try this again so sort now if i press q and now we get the lance although since i donâ€™t have a timer to react to weight my canâ€™t switch weapons we canâ€™t change it again but that we can do now and thatâ€™s going to happen down here in cooldowns and i would actually recommend you to look at our cooldown for the attack animation and copy it so we can switch weapons and have a timer for that what i basically want to do is if self dot can switch weapon and i want to check if this is not the case because we are setting this thing up here to false so only if this is false we want to run the timer and if the time is running i want to get my current time and subtract self dot weapon switch time and if that is greater or equal to self dot weapons which what i call it again we start to have a lot of variables switch duration cooldown there we go so down here switch duration cooldown now if that is the case we want to set self dot can switch weapon back to true and now letâ€™s try this again so now my weapon still works now if i press q we get the lance if i press it again we get the x press it again different weapon and a different weapon but now i press it again and now we have list index out of range and this happens if i go to my player that we are always updating this number by one but we only have five weapons inside of our list so at some point this number is going to exceed the length of that list but that we can fix fairly easily and really all we have to do is if self dot weapon index is more than the length of the list of our keys so this thing here and only if that is the case we want to add plus one to our weapon index now if that is not the case we want to do something else and what we want to do is to set our self.weapon index back to zero so once weâ€™re exceeding that number we are going back to zero and that way i donâ€™t have to implement a backwards mechanic for this button but you could totally do that if you wanted to but with that logic we have the weapon mechanic so letâ€™s try so now i get sword lens x next one next one now if i press q again we still get an error okay not great letâ€™s have a look ah and what i just saw this should be length minus one because we start counting from zero so now letâ€™s try this again different weapons different weapons and answer again now weâ€™re back to sort cool so now this is working so this is a common thing in python that the length of our list was one too large because of the way weâ€™re counting the length of the list but well now we have our proper weapon mechanic so all right with that we have a weapon although right now you canâ€™t really see the weapon so next up we are going to work on the ui and i guess while weâ€™re at it we can also implement the health bar the energy bar the experience or the souls and then the magic we currently have selected so we have all of the stuff in one place so i guess letâ€™s talk about how to approach the ui thatâ€™s going to be the next section i guess in the most basic sense the ui is going to consist of two different elements number one is our player is going to have a ton of different data for example what our current weapon is thatâ€™s one we already have but besides that we also need health energy experience our magic and i guess thatâ€™s it and these are the things we have to add to our player now once we have all of them we can actually start working on the ui elements that are visible and this is going to involve a couple of different things for example we have to show the health bar and the energy bar and both of those for example are just rectangles and the width is determined by the amount of health as a proportion of our full health or our full energy so weâ€™re not really going to do anything sophisticated weâ€™re just creating different rectangles and the weapon and the magic are just the images with some background rectangles one has a color one only has an outline and if we combine these different elements we basically get some nice looking ui that i think came together really really well and i guess this part is best explained when i actually implemented so letâ€™s start with number one and letâ€™s give our player a couple of key attributes to actually create a game here i am back in my player and let me go down and add another section here and letâ€™s call this one stats and what iâ€™m going to paste in here is just going to be a dictionary so we have our health our energy our attack our magic and our speed and i guess if youâ€™re confused right now we have attack here and for each weapon we have damage and what iâ€™m going to do later on is our ultimate damage of the player is the base attack plus the weapon damage so these are going to be our base stats but we need a few more things so right now our health is at 100 and this would be our current maximum but now imagine we run the actual game and an enemy hits us then we have to lower this amount but we still have to know what our maximum amount is and for that i want to add self.health and by default itâ€™s going to be self.stats and just health so by default our self.health is going to be the same as the maximum we can have however later on in the game we can actually lower this amount and then we can have a different between the maximum and our current health and we can do the same thing since weâ€™re going to need it anyway is our energy and this is just going to be self.stats and in here our energy and thereâ€™s one more thing that we do need for the ui and that is self.exp and this one doesnâ€™t have a stats entry because itâ€™s well just the experience and letâ€™s say just so we have a number letâ€™s go with one two three and actually while weâ€™re here we can also now determine self dot speed is going to be self dot stats and speed so now we can go up a tiny bit and get rid of this speed here because later on we want to be able to update this and i guess it should be five by default so we keep the same speed okay now our player has some stats and some current stats that we can work with so now we actually have to create the ui and what i want to do is to create a new file that iâ€™m going to save as ui.pi and in here as always we need import pygame and from settings import all of it and now i want to create a new class called ui and then here as always we need our init method with self and nothing else and for now letâ€™s just add a pass in here and figure out how to call this thing in the first place and i want to call this from the level because in here we are drawing all of it and let me minimize all the methods so itâ€™s a bit easier to see letâ€™s say we can minimize this one as well now in my level class i want to create another section and letâ€™s call this one the user interface and what i want to do here is self.ui is going to be ui so the class we have just created this one here and for that to work we have to do from ui import ui so now we can actually use it and pretty much what i want to do in my run method on top of everything else i guess i can get rid of the debug one i can run self dot u i and essentially i want to give it one method that i call display and to get the information from the player i want to pass self dot player in here and that is pretty much all we have to do in our level now we can just work in our ui and all we need is one method that was called this play and we need self and the player as the arguments so now we can go pass and now we have a class where we have access to the player and we can call it from the level itself or well we are always calling it and now letâ€™s run this we donâ€™t get an error so at the very least itâ€™s working cool so now we just have to figure out all of the ui elements and there are quite a few different ones so letâ€™s go through this thing step by step first of all we need a couple of general bits of information so letâ€™s call this general and first of all i want to have access to the display surface and this we get as always with pygame dot display dot get underscore surface now next up we also have some text so i want to create self dot font now we do have a font that we can just import and i also know the font size but for my ui design i have quite a few parameters like the bar height the width of all the elements the box sizes of the weapon and magic items and i want to store all of this in my settings so before i import the font let me go to my settings and in here i want to add another sections that i called the ui and in here i have a couple of parameters that look like this and these are all the elements i will need to well make the ui work and actually while we are here there are a couple more and these ones are going to be colors so we have our general colors we have the water the uibg color the border color and the text color and then we have the health bar color the energy bar color and then if we select something youâ€™re going to see how those look later on but for now all of these are just very simple variables that donâ€™t really store anything complicated so all right now we can use them so first of all i want to import my font and this is going to happen with pygame.font.font and in here we need the font we want to import which in my case is i called this one ui font so ui underscore font and then we need a font size which in my case is stored in ui underscore font underscore size and now we have to choose which element to start with so we can either do the health and the energy bar the experience or the weapon or magic and letâ€™s say weâ€™re going to start with the health and energy bar iâ€™m going to add another tab here and letâ€™s call it for now the bar setup and right now i want to create some general rectangle where the health and where the energy bar is going to be and this is just going to be a rectangle and iâ€™m going to call this health bar rect and this is going to be pygame dot rect and now for this one we need the left the top the width and the height now the width and the height we do have in here so we have a health bar width that we can put in here and the bar height is identical so itâ€™s just called bar height so bar height now next up for the left and the top i just went with 10 and 10 which is in the top left now besides that i also want self dot energy bar rect and this one is going to work in a very similar way so pygame direct and now again we need to left we need the top we need to weft and we need the height and now the height we already have is just the bar height for the width we have energy bar width in our settings so within here and i want this one to start on the same x position but the top is supposed to be a bit further down i went with 34 and now once we have that we could actually already try to draw something so letâ€™s see if this works in the first place so i just want to use pygame.draw.rect and in here we need a surface we need a color and we need a rectangle and for the surface we have self dot display surface letâ€™s say for the color for now itâ€™s going to be black weâ€™re going to change this anyway and for the rect letâ€™s go with dot health bar rect so now letâ€™s try this and we can indeed see a health bar in the top left and this one stays in a nice position so this is working very well cool but i donâ€™t want to draw this element right here so let me add a pass in there again instead i want to create a function that is a bit more flexible so just a function that can take a current amount a max amount a background rectangle and a color and then display either health bar or energy bar so we can use it for both and well letâ€™s implement this one so i call this one show bar and in here we need a couple of different arguments so first one we need the current amount then we need the max amount then we need the background rectangle and then we need a color so for example what i essentially want to do i want to call self.showbar and then in here i want to pass in player dot health and player dot stats and health so thatâ€™s our max health then i want to pass in this rectangle and this is going to give us the position of where the health bar is going to be and then finally i want to give this thing a color and a color we get from our settings we have health color although granted itâ€™s just red so in my ui i can pass this in here and where this system is really useful now we could just copy all of this and change health to energy and then this health should also be energy and our health color should be the energy color although again the energy color is just blue all right now we have a function to create the health and the energy bar we just have to write it first of all we have to draw the background that is what i basically wrote just a second ago so again pygame.draw.rect and here we again need self.display surface then we need a color and in my case the color is the ui bg color so i can paste this here and then weâ€™re going to need our bg rectangle and i guess quite important this color here is not supposed to be this color up here so thatâ€™s not the case right now we are just drawing the background of our bar weâ€™re not drawing the bar thatâ€™s supposed to indicate the health right now that will come in just a second but now actually this should already work letâ€™s try this and yeah now we can see our two bars for health and energy in the top left and they are working perfectly fine and now that we have that we can start working on drawing the bar although now we do have a problem and let me illustrate what the problem is so right now we have one bar letâ€™s say it has a length of something like this and i know from my settings so the health bar width for example that this entire thing right now is 200 pixels wide and all of that so far worked pretty well now the problem is that my health is not in pixels so this player health here at the current maximum would be 100. so this would be our full health the problem is inside of this thing we have to convert this 100 to a 200 and this should then obviously be flexible so we have to figure out how much is 100 health in terms of pixels in our health bar so we need a bit of math to convert our health into pixels and let me actually add another section to that so converting stat to pixel and first of all i want to figure out a ratio and that is going to be my current amount divided by my max amount and that is going to tell me how much of my max amount do i actually have and this is already getting us really close to a pixel measurement because i know for example for my health my max amount is going to be 200 pixels wide so what i want to figure out next is my current width from that and all i really want to do in here is get my background rectangle and get the width from that so that is my max width in pixels and this i just want to multiply by the ratio and letâ€™s do some numbers just to illustrate how this is going to work so our current health right now is 100 and our maximum is also 100 so if you divide one by the other you end up with one now our b direct for our health is going to be 200 pixels wide and if our ratio then is one we are going to get a pixel width of 200 for our entire bar so this is then working quite well now letâ€™s say we have different numbers so instead of 100 we get 50. now our result is going to be 0.5 and if we multiply 200 with 0.5 we donâ€™t get 200 we get 100 which is exactly half of the width of our background rectangle all right so now we have to use that information to create a new rectangle so letâ€™s call it current rect and since i already have in my background rectangle most of the information i can just copy this one and now for my current react dot width iâ€™m going to set this to my current width so this way i have a rectangle in the same position with the same height but with this line i give it a different width so all we have to do now is to draw this rectangle so pygame.draw.rect now we still need self.display surface next up we need the color and that color we are getting from the parameters so we donâ€™t have to worry about it and finally i want to draw my current rect and now letâ€™s try this there we go now in our top left we can see our health and our energy bar and what i can also do so letâ€™s say in my player just to illustrate let me multiply our health by 0.5 and our energy by 0.8 now if we run this you can see that we have half of our health and most of our energy so this way we can change the health and the energy of the player and it updates automatically so this system works super well now thereâ€™s one more thing i did add to this and that is basically a border around the health bar which does make it look a bit nicer and this is just pygame.draw.org self dot display surface now for the color we have in settings a ui border color so thatâ€™s the one iâ€™m going to use here and then besides that we have the current rectangle so right now we are just drawing a rectangle on top of the other rectangle which wouldnâ€™t be very helpful but now if we are giving this another argument this would be the line width in my case itâ€™s free and once it gives something in line within pie game the fill disappears and we only have the line let me actually demonstrate now it looks like this oh when i did make a mistake right now we are just drawing a bar around our actual health which is not what i want instead i want to draw around my bg rect so we are covering the entire bar with an outline so now letâ€™s try this again and there we go this is looking quite a bit better itâ€™s a touch hard to see but if you look at the left of it it is definitely there so alright with that we have our health bars wasnâ€™t actually that bad so now i can minimize my show bar and never worry about it again so with that part covered we can start working on the experience and that part should be really easy basically what i want to do iâ€™m going to call another method and this oneâ€™s going to be called show exp so letâ€™s create that method show underscore ex and this one besides self also needs letâ€™s call it the exp and now what i want to do first of all i want to create a text surface and the text is going to be the experience and essentially this means i want self.render and in here we need the information we need anti-aliasing and we need a color and letâ€™s go through them one by one letâ€™s start with the easiest one anti-aliasing in my case itâ€™s false because i have pixel art and this one shouldnâ€™t be in the earliest and besides that for the color i can go to my settings and in settings i have a text color so thatâ€™s the one iâ€™m going to use and then finally we have our information and this is supposed to become the axp and right now exp is going to be in our player and it is this number here an integer now the problem is that python for this one needs a string so this one wouldnâ€™t work by itself but we can fix that fairly easily by using the string method and thereâ€™s one more thing i would like to do and that is that i want to convert this number into an integer now why do i want to do that because right now our experience already is an integer essentially this is to make sure that our numbers donâ€™t get too long so if by some weird math we end up with a floating point number with 10.0001 this would look very strange in the experience and converting this experience to an integer avoids that problem entirely so next up we have to figure out how to place this surface and i did that with a rectangle and really all we need here is the text surface and get rekt and since i want to place this thing in the bottom right let me actually draw it really quick so if this is my entire game window i want the experience to be down here ish and to place it down here i think the best point would be the bottom right so letâ€™s place that one actually i think this could be a pretty good exercise so try to place the text rectangle on the bottom right of the window wherever you think it looks good and then draw the text on the display surface first of all i need bottom right thatâ€™s the point i would like to place and for this one i need x and y so i have to figure out what the dimension of these two variables are going to be and letâ€™s do them in separate variables so itâ€™s a bit easier to see what iâ€™m doing now what we have to be aware of here if this again is our entire window and we are placing our experience down here with this origin point the thing i have to figure out is the maximum width of my window so this distance here and this would give me the right side of the window and now what i have to figure out from here is how far away i want to get from there and this would then give me my origin point on the x-axis and the same for the y we essentially first have to get the entire height of the window and then from that point subtract how high we want the experience to float from the bottom of the window so what that means in practice is we first have to get the dimensions of our window and this we can get with self dot display surface and get size and this is going to return as a tuple of x and y and for x we only care about the first one that is the x dimension now we can copy all of this and target the first one so with these two points our window would be right at the bottom right of the screen but i want that to be a tiny offset and in my case for x i went with 20 and for y i had the same number so now our text rectangle is in the bottom right of the window now all we have to do is call self dot display surface and blit and pass in the text surface and the text rectangle and we are almost done the one thing we havenâ€™t done yet is in show xp we have to pass in the experience and this we get from player and that is still the player we are getting from the argument of the display method but player right now isnâ€™t good because we want the experience of the player so i want player.exp i believe i called it so in here yeah player.exp and now this should be working so letâ€™s try to run all of this and there we go in the bottom right of the window so all the way down here you can see the experience so not a bad start although also not a great one because you can barely read it but this we can fix quite easily because we can use the text rectangle to draw a background and a frame around this box so letâ€™s do that and first of all the background has to be behind our text and all i really need to do in here is to call pygame.draw.rect and in here i need my display surface so self.display surface then i need a color which in my case i called u i b g color the same as the health bar and finally a rectangle so our text rectangle and now this is already looking quite a bit better although not ideal because i would like the box to be slightly larger than the text but this we can also fix so this rectangle i want to be slightly larger and this we can also do with the inflate method thatâ€™s the same method weâ€™ve seen earlier to create the hitboxes and earlier we passed the negative numbers to make the rectangle smaller but if we pass the larger numbers letâ€™s say 20 and 20 now our rectangle is going to become larger and that is exactly what i wanted so with that we have our background but i also want to draw a frame around this box and for that i am just going to copy the draw method and now i can add another argument and that way we get a frame which in my case has a width of three and then we also need another color and i call this one ui border color and now letâ€™s have a look and there we go the effect is fairly subtle but i do think it does make it look a little bit better but all right now we can show our experience so now let me minimize the experience method and now thereâ€™s only one more element we have to cover and that is the selection box for the weapon and the magic and this i want to work kind of like the health and the energy bar that i have one method that just creates a box and then i can give this box different arguments to display different player statistics although this one has to become a little bit more complex since weâ€™re displaying an image but itâ€™s not that bad i guess letâ€™s work on it straight in the code now first of all i want to create another method that i have called selection underscore box needs self as always and then we need a position and i call this left and top and that is all we are going to need for now although there is going to be a change later on and this selection box is essentially going to give us the background box for our weapon so this is the box and then later on we are going to paste an image of the weapon in here so this selection box gives us the box and the position where to place this surface youâ€™re going to see a second what i mean now first of all we need a rectangle and i call this one the bg rectangle and for this one we want to create a rectangle so pygame.rect and for this one we have to figure out the left the top the width and the height and left on top we already have that part is literally the arguments we are getting from the function itself so those two we donâ€™t have to worry about now width and height are also very simple because in my settings i have an item called item box size and this one is supposed to determine the size of this box and since we are creating a square itâ€™s the same dimension for both x and y so now we have our background rectangle and what we can do already is draw it so pygame.draw.rect we need self dot display surface then ui bg color and then bg wrecked we can already call it just to see whatâ€™s going on so selection box and letâ€™s say for the left i will go with 10 and for the height letâ€™s say 1150 so now letâ€™s try this and we canâ€™t see anything ah for the simple reason that this number is way too high it should be more like 600 letâ€™s try now there we go now in the bottom right you can see the rectangle i guess letâ€™s put it a tiny bit further down letâ€™s say 630. oh yeah this feels much better so now we have a rectangle cool now what we can also do is copy this entire thing give it a border radius and now call this ui border color and with that we also have the frame around this box which is already making it look better nice and this is basically all we are going to need for the overlay for either the weapon or the magic so essentially what iâ€™m going to do is call this twice the first one is for the weapon and the second one is for the magic and for the magic box i went with 85 and i put it a slight bit further down i think 35 is what i used so letâ€™s call it and there we go now we have our two boxes and they are slightly overlapping which i think looks pretty good actually letâ€™s give it a bit more of an overlap letâ€™s turn this to an 80. and there we go i think this looks really nice cool so with that we have our selection boxes now what we have to figure out is how to pass the weapon or the magic image in here and i realize we donâ€™t have the magic yet weâ€™re gonna work on that in the next section but for now letâ€™s figure out the weapon and iâ€™m gonna put this in its separate method and letâ€™s call it the weapon overlay and since this method has to know what weapon the player is using i also want to get what i call the weapon index and this weapon index is going to be this weapon index in our player file or player class and iâ€™m going to use that to figure out which surface we want to draw now first of all i want to call this selection box method from inside the weapon overlay and for that i can just copy all of this and paste it in here that already cleans things up and instead of calling this method i can call weapon overlay and i guess what we call the method i can also place in the argument so player dot weapon index so right now there shouldnâ€™t be any change and there isnâ€™t so now we are already drawing our background but this is only one thing i want from this because what i really want from this background is the position where my surface is supposed to be placed so ideally what i would like to do is to take this background rectangle and somehow get it inside of my weapon overlay and then place my surface of the weapon inside of that rectangle and that i can just get by returning the bg rect at the end of this method so now in this other method i can get letâ€™s just keep calling it be direct and i can get rid of the comment i suppose so now we have our bg rectangle available in our weapon overlay and i can minimize selection box we donâ€™t need it anymore and now essentially what i want to do i want to get myself.display surface and blit and i want to get a weapon surface and a web pin rect the weapon surface iâ€™m going to get from settings and in my weapon data itâ€™s this graphic here and my weapon rectangle is going to be just a rectangle and the center of this rectangle is going to be in the center of this bg rectangle and that way our weapon is inside of our background i hope that makes sense so we have to figure out two things first of all we need the weapon surface and for that we have to look at our settings and in here we want essentially get this information although right now this is slightly difficult to get because this is a dictionary and we only have an index so instead we have to convert this dictionary here into a more usable list and that i want to do in the init method so let me add a comment here and letâ€™s say convert weapon dictionary and really all i want to do i want to have self.weapon weapon graphics as a list and i also want to spell this correctly and in this list i want to have all of the surfaces of my weapons so essentially what i want to do is for weapon in my settings i want to get the weapon data so in weapon data and i donâ€™t really care about the keys i only care about the values so what i essentially get now is another dictionary and inside of this dictionary i only really care about graphic so letâ€™s save this one in path and we get this one in weapon and graphic i think graphic or graphics just graphic and now what i can do is get my weapon and just pygame dot image dot load and i need my path and as always i need my convert alpha and once i have that i just want to add this weapon to my weapon graphics so append and my weapon so now i have all of my weapons in an accessible list and what i can do with that in this weapon surface down here in my weapon overlay i can just get self dot weapon graphics and pick the one with the weapon index and that is literally all i needed now i have the graphic and now i can get my rectangle and this is just going to be my weapon surface dot get underscore rect and i want to place the center at the center of my bg rect so dot center and now we should be having a weapon letâ€™s try and there we go we can indeed see a weapon and now if i press q we also get different weapons depending on well what we have selected so this is working very very well attacking also still works with the same result nice now thereâ€™s one more change i would like to make and that is when we change the weapon i want the frame of this box to be highlighted in yellow so we get some indication of what we are doing and thatâ€™s just adding some visual niceties to it it really isnâ€™t anything major and all this really means in code is that this border color should have a different color while our player is switching the weapon and we know when the player is switching the weapon because in my player i have can switch weapon and essentially if this one is false i want to have the border color of this one differently and well for that we have to pass a couple of arguments through so letâ€™s start with the selection box thatâ€™s the first one down and in here i want to add another argument and letâ€™s call this has switched and now i can add an if statement that if s switched is true then i want to do something but if that is not the case so else then i want to keep on doing what we already have done by drawing this border color however if it is the case that we have switched i can copy this and just draw this frame in a different color and the different color we have itâ€™s ui border color active although this one is just gold iâ€™m very lazy with colors okay now we have border color active cool so now we have to figure out how to get this hair switched inside of our weapon overlay so in here our selection box also need has switched which we canâ€™t get right now because we only have the weapon index so i need to give this one another parameter and i guess we can keep on calling this as switched and now finally when we call this method weâ€™re getting our weapon index and now we have to figure out an argument and we know itâ€™s going to come from the player but now in my player we have can switch weapon but if i just pass it in here actually letâ€™s try this but first of all we have to comment this selection box out otherwise we get an error so now if i run this we get the golden border by default and if i switch my weapon it disappears for a second so we have to do the exact opposite because by default this attribute here checks if we can switch the weapon but what we want to check in here if the player has switched the weapon is the exact opposite and well all we have to do is add a not before that and now we should be good to go so now weâ€™re checking the inverse of that variable and now if i press this we are getting the right selection so this is working pretty good nice and i guess to get the magic in there as well we actually have to give our players some magic abilities and i guess letâ€™s work on that and once we have the magic weâ€™re going to finish the ui and the magic is going to work kind of like the sword at least in terms of data and the player so we have a dictionary with lots of data we give our player a timer and the ability to switch between different kinds of magic and then once we are casting magic we are doing something although that something is going to be slightly more complex than just spawning a sprite because our magic is going to be a bit more complex so for now we are going to skip this part and we are still going to just print at our players doing something the reason here is that to actually make the magic work we need particle effects that we donâ€™t have yet and that are really really important hence we canâ€™t really do this but weâ€™ll come back to this later but for now letâ€™s do at least the basic magic so we can finish the ui and there really isnâ€™t anything new so letâ€™s jump straight into the code and here we are back in my main file and i want to go to settings i need another dictionary for my data and this one is for my magic and if i paste this we essentially have two spells we have flame and we have heal and this dictionary works very similarly compared to the weapon data and for the ui the important one we care about is this file here or this string to an image and i guess for the player we also have a strength and a cost but really nothing particularly complicated so now we have to figure out in my player how to use this and i guess we need a couple more attributes and letâ€™s put it right below weapon it makes the most sense there and first of all i need a magic index that by default is going to be zero and that is the same idea we had for dot weapon index so those two are going to be the same as a matter of fact we are going to copy quite a bit from here since our weapon and our magic at least in terms of data are very similar so the next thing i want to do actually i can copy this entire thing and paste it in here so now i want to get myself.magic so the magic i currently have selected and for that i want to get my magic data dot keys and self dot magic index so this information essentially gives me either of these two strings which is the key for this dictionary then besides that we also want can switch magic to select it for the ui and by default this should also be true and then we need self dot magic switch time and this by default is going to be none essentially what we have done in these four lines here is the same we have done earlier for our weapon so nothing new although thereâ€™s one more thing that we do need and for our weapon we have self.create attack and we are going to need the same thing for our magic and i guess just to keep the symmetry letâ€™s put it right at the top so self. letâ€™s call it create magic and this one is going to be create magic and this create magic we have to get from our parameters so here create magic now in my level let me minimize all of the methods besides create attack i also want to define create magic and this create magic is going to need a few more parameters first of all i want the style of magic iâ€™m using then i want the strength of that style and finally i want to have the cost of that style and in this method later on we are going to have a system to select different kind of magic spells but well thatâ€™s quite a bit off for now weâ€™re just going to print this style weâ€™re going to print the strength and weâ€™re going to print the cost so at the very least we can tell whatâ€™s going on and besides that what we need is when we create the map and we create the player actually let me add a bit of a few more lines here so we can actually tell whatâ€™s going on with the player okay this is much easier to read so now finally i want to add create magic and as always make sure youâ€™re not calling this method youâ€™re just passing it into the player and all right now in our player we have to create magic method and we have all of the attributes we need i hope i didnâ€™t forget any so for the next step let me actually minimize all of the methods for the player so itâ€™s a bit easier to see now the next thing i want to do is in my input right now we have one way to cast magic and what we have done so far we just printed magic but now i want to self dot create magic and for that create magic i need my three arguments i need my style i need my strength and i need my cost and letâ€™s put those three in the separate lines so itâ€™s a bit easier to see so we need a style we need a strength and we need a cost and this is information we will get from this dictionary here and we know which of these to target by using our in the unit method by using this magic index and i feel like this could be a pretty good exercise so try to use the magic index that when we are pressing the magic button we are calling this create magic in the proper way alright letâ€™s start with the easiest one this style and we first want to look at the magic underscore data and what style is supposed to be is a string that either says flame or here so we need the keys of this dictionary so magic data dot keys and this i want to turn into a list with list so we can use indexing on it and once we have that all we really need is self dot magic index and then we are good to go that is actually all we needed so next up we want to do something fairly similar so let me copy all of this and now we want to figure out the strength so letâ€™s look at the dictionary again now we actually want to look at one of the values for these dictionaries and from this dictionary we want to get the one that is called strength that has the key strength rather and that is actually kind of simple as well so now instead of keys we are looking at values so this list here would be a list of all of our values and if we pick one we end up with one dictionary letâ€™s say this line here if it was zero would be giving us this dictionary and once we have that all we need is to pick one element from this dictionary and i want the key strength is what i called it i think yes strength and now for the cost all we have to do is copy this thing and now instead of strength we are looking at cost and i guess just to check if this is even working letâ€™s try this in our game so letâ€™s run my game and letâ€™s press ctrl and we get flame 5 and 20. so this is actually working nice although thereâ€™s one change i would like to make that right now my strength is just from the settings this strength here but essentially what i want to do is to give my player also a magic ability actually my player already has that this magic here thatâ€™s basically the in build magic power of the player and weâ€™re gonna add this to the magic damage so for the strength i want to get the strength of the spell plus myself dot stats and i call this one magic i think yeah magic so this self dot stats magic here so that way we can level up our spells and we make them stronger so letâ€™s try this again and now we get five plus four is nine so this is working really well so with that we can call our magic and next up we have to be able to switch between different kinds of magic and thatâ€™s going to look very similar compared to this weapon switching mechanic so i suppose what we can do is just copy the entire thing and then letâ€™s work from there first of all on the first line instead of q i want to look at e and then canâ€™t switch weapon should be can switch magic now the next line canâ€™t switch weapon is false should be can switch magic and for the time it should not be weapon switch time it should be magic switch time then next up we donâ€™t want our weapon index in any of these so this should be magic and then the list we are looking at shouldnâ€™t be weapon it should be magic but everything else is still the same this weapon should also be magic and then finally self dot magic should be our list with not weapon data or the weapon index it should instead be our magic index and now this should technically be working so letâ€™s try this in the game so now i press ctrl we get flame 9 and 20. now if i press e now we get here 24 and 10. if i press e again we should go back to flame and we are not it sticks to heal so letâ€™s have a look here we have our entire if statement and i think i just figured out what the problem is that for our weapon we have a timer that reactivates the weapon whereas for the magic we donâ€™t have a timer so once can switch magic goes to false it never turns on again we can actually test this so at the end of this if statement i want to print magic and now if i call this we get flame if i press e we get magic but if i press e again i donâ€™t see anything so we only ever update or we only ever call this one here once and the reason we can only call it once is because further down in our cooldowns thereâ€™s no cooldown for the magic but we can create one quite easily by just copying the weapon switch mechanic so if can switch magic i want to get my current time then my magic switch time is what i called it and if that is greater than my switch duration cooldown thatâ€™s the one that can stay constant or well the one that doesnâ€™t change between the weapon and the magic and if that is the case mike can switch magic should be true so now we have the cooldown now letâ€™s try this again so i get my flame 9 and 20 i press e we get heal i press e again now weâ€™re back to flame and i can keep on pressing this it always works nice and with that we have our basic magic obviously it doesnâ€™t do anything right now but that will come later i guess what we can do now is work on the ui to display the magic and this is going to work in essentially the same way that we have done for the weapon overlay so letâ€™s actually implement it straight away although if you want to do this as an exercise i would recommend you to try this out in my case letâ€™s call this one magic overlay and here we need self we need the magic index and we again need has switched and if that is the case actually let me copy all of this again since itâ€™s going to look fairly similar so magic overlay might be direct is now going to have these two numbers so these two numbers and i actually also want to call self dot magic overlay with my player dot magic index and then not player can switch magic i believe i called it so those two methods are basically identical except weâ€™re using different data and the bg-rack still works but now we need a magic surface and a magic rectangle and for the magic surface we need our magic graphics and our magic index oh and i just realized we donâ€™t have our magic graphics yet let me cover this one in just a second first of all for magic rectangle i want to get my magic surface and the rest can stay the same and now i want to replace weapon with magic okay we are nearly done the one thing i did forget is that in the init method we also have to get the convert magic dictionary so kind of the same thing we have done for the weapons that we create a list with all of the surfaces and i want to do pretty much the same so self dot magic graphics by default itâ€™s an empty list and now for magic in magic underscore data dot values i guess for this one we can go straight to the magic surface and i want to get pygame dot image dot load and the path is going to be magic and graphic and as always for this one we also need convert alpha and then self dot magic graphics dot append magic i guess if you were to do all of this by yourself i would recommend to combine these two imports into one function so you can reuse them itâ€™s a bit more elegant and i guess you could also combine these two functions here in a bit more detail but i guess there are so few lines in my case i donâ€™t really mind that much but alright now we have our import graphics and this magic overlay also works and i think weâ€™re done letâ€™s try so i can see my magic and i can see my weapon if i change my weapon it still works if i change my magic it also works cool so now i can change between my different magic and weapons and we can still use them in the game as well so this is working really well so with that we have the ui all covered next up i guess we can actually start adding some enemies to make the game a bit more interactive and the enemies have to be able to do quite a bit because they are nearly as complex as the player so there are a couple of things that we have to implement here and thereâ€™s one more thing i would also like to cover that since our player and our monsters are fairly similar they can share a couple of methods with each other in my case the methods they do share is the move and the collision method they essentially move in the same way the only difference is that our player gets the direction from the input whereas the enemies get the direction from what the player is doing so if the player is very close to them theyâ€™re moving towards the player and if the player is further away they donâ€™t move at all but once we do have a direction they are basically going to work in the same way so what we have to do for now first of all we have to import a bunch of data for the enemies to actually display the very basics of them then we have to split some methods from our player and create a new class called entity and then both our player and our enemies are going to inherit from that class and once we have all of that we can actually start implementing some enemy functionality so i guess letâ€™s jump straight into the code and letâ€™s have a look at this so here iâ€™m back in my code and first of all i need some data and all of that is in the settings and in here i want to add yet another section that i called enemy and in there i want to import another dictionary that looks like this so in here we have our enemies for example we have letâ€™s say the raccoon we have a health experience damage their attack type and their attack sound and then at the end we get quite a few more like speed resistance attack radius and notice radius and all of these things are going to determine how they are going to operate but that is literally it besides that the classes are going to be identical and i guess really quick to go through what each of these pairs do health should be fairly obvious itâ€™s how healthy they are experience is how much experience they give and damage is well how much damage they do to the player attack type is purely for the particle effects so when the enemy is attacking the player this is going to be what will be displayed on the window and besides that at the end speed should be fairly obvious resistance basically means if the player is hitting the enemies so letâ€™s say this is our player and this is our enemy and if the player hits the enemy then our enemy is supposed to go a little bit backwards and the distance by how much the enemy is being pushed back thatâ€™s the resistance then we have attack radios and notice radius and essentially what they mean letâ€™s say that this here is our enemy and the enemy has two radiuses the first one is the attack radius and letâ€™s say this one is going to look something like this it is literally a radius around the enemy and if the player is inside of this radius letâ€™s say right now our player is here if that is the case then the enemy is supposed to attack the player and that is the attack radius and you see itâ€™s 80 and 120 or very small numbers they basically mean if the enemy and the player are very close to each other then the enemy should attack now besides that we have our notice radius and the notice radius is substantially larger it essentially is something like this let me draw it out and if our player is inside of this radius then the enemy should only move towards it but it should not attack so that way once our enemy is close enough to the player it starts moving towards the player and then once the enemy is close enough to the player so the players inside of the attack radius then the enemy is going to attack and if the player is outside of that so here then the enemy isnâ€™t going to do anything so i hope that makes sense and all right with that we have the data for our enemy they do get fairly substantial now next up in my player let me minimize all the different methods so itâ€™s a bit easier to see now right now the move and the collision method we want to reuse for the enemies as well so what we could do is make the enemies inherit from the player but that feels kind of weird so instead iâ€™m going to take these two methods out and put them in a separate class and let me for that create a new file and letâ€™s call this one entity dot pi and in here we have to import pi game and then i want to create a class that i called entity it has to inherit from pygame.sprite.sprite and once we have that i want to give this thing a done there init method in itself and groups and then in the super dot init method weâ€™re going to pass in the groups now once we have that we can from the player get this move and this collision method so let me just copy them paste them in here and now our entity has these two methods so what we can do now in the player i can literally just delete both of these methods and now the player isnâ€™t supposed to inherit from sprite anymore instead we want to inherit from entity and for that to work we have to from entity import entity and now technically nothing should change and this is still looking very good cool we can still do all the stuff yep that looks very good this is then what we can use for the enemies as well itâ€™s going to make our life a bit easier and on top of that we can actually add a few more things in here so we could for example add the self dot frame index with a start of zero self.animation speed could also be in here so 0.15 and self.direction is going to be pygame.math.vector2. these basic attributes are going to be shared across our player and our enemies anyway so having them in here seems to make a bit more sense so now in my player i can get rid of frame index and animation speed and from direction and just to make sure things are still working letâ€™s try and seems to be all good and working so with that we have a basic setup for our enemies and with that we can start creating the actual enemy class but first of all let me clean this up a bit so we donâ€™t need our ui anymore and we also donâ€™t need the weapons and if i close them we have a bit more space and now let me create a new file and iâ€™m going to save this one as enemy dot pi and in here as always we have to import pi game then from settings import everything and donâ€™t forget from entity import entity and now we can create our class and me and this one is supposed to inherit from entity and that way we already have all of this available so we donâ€™t have to rewrite it but we are still going to need an init method needs self first of all then i do want a couple of different things first of all i want something like a monster name and this monster name is going to be used in a bit to pick either squid raccoon spirit or bamboo so we get different monsters then besides that i also need a position so i know where to place it at the beginning of the game and donâ€™t forget we also need the groups now besides that letâ€™s start with a general setup and in here the first thing we always need is the super done the ended method and in here we have to pass in our groups and thereâ€™s one more thing that i would like to add that is self.sprite underscore type and in this case itâ€™s just going to be enemy and this sprite type let me open my tile again it was in here so this is our tile class for all the inanimate objects this one also has a sprite type although this one is a tiny bit more flexible because we have different types of tiles but for our enemy we are always going to have our enemy and the reason here is that these are supposed to react differently that if our player attacks an enemy for example then we want to reduce the health or kill the enemy if the health goes below zero however if our player attacks a tile that is a grass for example then we want to destroy the grass immediately the grass doesnâ€™t even have any kind of health and then if we have something like a tree or a statue they are not supposed to react to the player whatsoever and for that reason we need different kinds of sprites and i guess you could organize this with different groups as well but i feel like using this system is a little bit more straightforward but there are different solutions to this all right now we have our spread type now next up we have to work on the graphics setup and i guess for now letâ€™s just place the enemies on the map and then improve them continuously so what i want to do for now is create a self.image and a self.wrecked and that way we can just place them on the map and then improve on them and for now for the image i just want pygame dot surface letâ€™s say 64 and 64. weâ€™re going to change that anyway and self.image dot get rekt and the top left should be the position and with that we have our enemies now if you remember all the way back in our level we made this thing here and we are still going to use it to place the enemies and for that we first have to import the csv file which fortunately is very easy so in here i want to create my entities and this is going to be both my enemies and my player and we again want import csv layout and in there we have one more string that we didnâ€™t import so far and let me just copy it in here it looks like this itâ€™s in the same folder as all of the other csv files we just didnâ€™t import it earlier because we didnâ€™t need it but we always had it and all right so now this for loop is going to get another csv layout so what we can do is add another if statement in here so if the style is equal to entities and there are a few different kinds of enemies we have to be aware of so this if statement will get more complex but for now we only really have two different kinds of tiles we either have the player that oneâ€™s actually right here and then we have our basic enemy class that for now is just black image and how this is going to work is if the column is a certain number for example the player in this list is number 394 and if that is the case i want to create my player in that if statement and let me just indent things properly so itâ€™s a bit easier to see uh this player also works yes okay now i think you might be confused where do we get this 394 from and the best way to see this is if i just open tiled youâ€™re going to see it in a second alrighty here we are entitled and this is our entire map and we got this map from this tile set here and let me open the tile set by itself and here we have the tile map and if i just click on the random tile letâ€™s say this one here let me add an arrow to make this a bit more visible so this tile here has an id of 252 and if we export this tire set that is the number we get and now if we click for example on the player it says 394 exactly the number i used to import the player and if you clicked on different kinds of enemies we get 390 91 92 and 93. so basically where this number comes from is on this tile set tiled orders each tile from 0 all the way to the end so we have 0 1 2 3 4 5 6 and so on so if you ever have to double check the numbers thatâ€™s where they are coming from so now we are importing our player and later on we are going to have more if statements with the different numbers for the enemies as well but now we can also update the position of our player it should not be this random position i gave it it should instead be x and y and those are the numbers we created ages ago all the way up here so weâ€™re just reusing those and i guess for now letâ€™s just see if this is working in the first place and there we go now our player is starting in a slightly different position but besides that nothing has changed but at the very least we know it is working so now back in my level i can for now just add an else statement and what i want to create in here is an enemy although for that to work i have to import the enemy class so chrome enemy import and me and now we can use it in here and i guess let me copy the parameters and paste them in here so itâ€™s a bit easier to work with now for the monster name letâ€™s say for now we can just say monster doesnâ€™t really matter for the position we keep on using x and y and for the groups let me copy it from the player so we definitely want the enemies to be in the visible sprites but besides that since the player isnâ€™t supposed to be able to collide with the enemies thatâ€™s all we need for now so now we technically should be having all we need to create some basic sprites and there we go this is actually working well i guess kind of at the very least we canâ€™t see where the enemies are supposed to be so thatâ€™s at the very least a start so i guess now we can just flesh out our enemy class and add more and more to this to make it actually work and i guess the first thing we can start with is the graphics setup so we can actually see whatâ€™s going on and to get our graphics i want to import something and this i would like to keep in its own method so letâ€™s call this import graphics and since we have different kinds of data so in my settings i for example want to import all the data for this squid for that i will need the monster name and this iâ€™m going to add in the import graphics so in here we are going to add monster name and i guess letâ€™s create that one so import graphics self and letâ€™s just call it name and this import graphic is going to be kind of similar compared to what we have done for the player so if i go back and here we have import player assets we had a character path and then we had different kinds of animation states in a dictionary and i want to do something similar for the enemies so the first thing i want to do letâ€™s call it self dot animations and this is going to be a dictionary with only three different value pairs we have idle then we have move and finally we have attack and these three states correspond to what the enemy is supposed to do so if the player is really far away itâ€™s supposed to idle if the player is kind of close itâ€™s supposed to move and then move towards the player and play the move animation and then if itâ€™s close enough itâ€™s supposed to attack and if you look at the folders there is a folder for each enemy that corresponds to this name so for example the squid has one folder for idle one for move and one for attack and this is going to work exactly like we have done for the player so what we can do we can create a main path and this is going to be an f string and in here i want to go up a folder i want to go to graphics then i want to go to monsters i called it and now we want to go to the specific subfolder for our enemy and this is going to be the name and now donâ€™t forget we want to go into different subfolders so we need one more forward slash so this path is going to lead us to each individual enemy and letâ€™s call it main path and now all i have to do is for animation in self dot animations dot keys and in here self dot animation and animation sorry this should be animations so essentially we want to get this dictionary and go for every single key of this dictionary so right now we want to get the idle and for this idol i want to import a couple of graphics and what is i need again my import folder function so from support import letâ€™s just say star so now i want my import folder the one we created earlier and then here i just want to create my main path plus the animation so just to explain whatâ€™s happening here this main path is what we have created up here and then the animation is what we get from the for loop and this for loop could for example be idle move or attack and we are just combining them and that way we get a whole path to a specific folder and then weâ€™re using the import folder function to import every single image inside of that folder and turn it into a surface and that way we can use them in our dictionary so with that we have our import graphics now next up in my init method i want to set self.status and for now this is going to be idle but later on we are going to work with this to make a change depending on how far away the player is so this could be any value inside of this dictionary could be idle move or attack and depending on the status the enemy is then going to do different actions so now we have a dictionary and we have a status pretty much the same thing we had for the player and with that we can actually start setting the image and i think this could be a good exercise to see if youâ€™re still paying attention the video is getting quite long so try to use the imported graphics so self-dot animations and the status to pick out one image for each monster i want first of all to get myself.animations so i want to get this dictionary here and from the dictionary i want to pick one of the animations depending on what my status is and right now my status is idle so i want self.status i guess could be anything but right now it is idle so this would give me a list but image wants a surface so from this i have to get self dot frame index and you might be asking yourself where do we get this frame index from do we have to create it in this class and the answer actually is no because in our entity we have the frame index and this frame index already works in the player so in this player we have no frame index but the animations still work just fine somewhere down here so frame index comes from the entity and we donâ€™t have to declare it so we donâ€™t have to worry about it but there is one thing we do have to worry about and that is the different kind of monsters so in my level we always call it a monster but that wouldnâ€™t be accurate because in my settings i have squid raccoon spirit and bamboo and for now letâ€™s just use this squid those i think look the best and now this would actually work with the import and now letâ€™s try this and there we go we can see some enemies they donâ€™t do anything right now and theyâ€™re all the same but at the very least it is working also we canâ€™t detect them but that comes later so for now we have some enemies now obviously we have different kinds of enemies and thatâ€™s something we have to work on now and essentially what i want to do i want to create a monster name variable and now i want to create some if statements to check what kind of name we are going to get and this could for example look like if the column is going to be 390 then my monster name is supposed to be bamboo then l if if my column name is equal to 391 then my monster name is supposed to be spirit thatâ€™s not how you spell that now next up if that is not the case and my column is 392 i am really bad at typing today if that is the case my monster name should be raccoon and if neither of these is the case so else then my monster name should be squid and let me indent them all properly python tends to be a bit annoying if you use if statements on the same line oh well sublime is a bit weird but with these couple of lines we now select the right kind of monster for the specific monster name and now letâ€™s try this again and we are getting an error that we have list index out of range and the error here let me close it all is simply that when python looks at this file here for the raccoon i misspelled it it should be spelled with a double c and because of that misspelling when we imported the folder python couldnâ€™t find it and try to loop over it and well that didnâ€™t work but now letâ€™s try this and now we can see different enemies so in here all of this is working really nicely so this is then giving us a ton of different kinds of enemies that we would like to have and i guess thereâ€™s one small downside here let me actually open it again so our enemies have very different sizes these bamboo ones are 64 by 64. same for the squid and same for these little flames but the big raccoons are quite a bit larger and you could give the larger ones an offset but in my case iâ€™m not going to worry because theyâ€™re basically in the right spot but thatâ€™s something you could work on but it doesnâ€™t really matter that much alright now we can place our different kinds of enemies and we can actually see them in the game i guess now we can start working on their movement and let me add a separate section to it and letâ€™s call it movement and then here we already have the rectangle and besides that i also want to give them self.hit box and this is going to be self.rect and letâ€™s go with 0 and negative 10. and this hitbox we are definitely going to need because in our entity we are moving the hitbox not the rectangle so our enemies are going to need a hitbox and besides that we are also going to need self dot obstacle sprites and thatâ€™s just going to be obstacle sprites and again this is going to work just like we have done for the player so in our entity we are looking through self. obstacle sprites so our enemy has to have this attribute as well and well this one we are going to get from the parameters so this is obstacle sprites and then on our level for the argument just like the player we need obstacle sprites and that way our enemies also get collision mechanics with the rest of the level it would look very silly if they didnâ€™t have that so now they have the ability to move but they well donâ€™t move at all right now so thatâ€™s something we do have to work on and to make them work we first of all need an update method and this one itself and nothing else itâ€™s the usual sprite update method and in here i want to add self.move and now this move method will need some kind of speed and i want to pass in self.speed in here and to get that kind of speed in the init method i want to give the enemy some stats and actually while weâ€™re here we can add a couple of different stats and let me just copy them it is quite a few so this is going to look like this so we get the monster name and thatâ€™s just going to be the monster name then we get some monster info and that is then going to give us the health the experience the speed the attack damage resistance attack radius notice radius and attack type so all of this is basically this dictionary here just now converted into attributes and that way we can use them significantly easier and in here we have our speed so now they could be moving and although if i run the game they are not going to move for the simple reason that they donâ€™t have any kind of direction or well they do have a direction but each of their direction is zero and zero so i guess you could say theyâ€™re all moving except theyâ€™re moving in the same place so well kind of pointless and that means we have to give them another method to check where the player is and this is done in another method that i called get status and this one itself and we have to know where our player is and all we really want to do in here is we want to get the distance to the player so in here letâ€™s just add a question mark for now because this one gets a bit more complex but letâ€™s just imagine for now that we have the distance all i really want to do is if the distance is smaller or equal than our self dot attack radius then i want to set self.status to attack then l if if my distance is small or equal to self dot notice radius then self.status to move and if neither of these is the case then self.status should just be idle so really all weâ€™re doing in here is here we have our enemy so this is our enemy then we have one radius around it and we have a larger radius around it and if our player is inside of the yellow circle then we want to attack and if the enemy is inside of the blue circle then the enemy is supposed to move towards the player and if the player is outside of that then the enemy is just supposed to idle and not do anything and thatâ€™s really all we need we have to make some more refinements in here later on but for now this is good to go so now we have to figure out whatâ€™s the distance to the player and in here i want to create an extra method because we essentially need two bits of information let me actually draw them actually let me just redo the entire circle iâ€™ve just done and letâ€™s say our player is here right now and i want the enemy to move towards the player now for that to happen i need two bits of information first of all i need the distance so how far the player is from the enemy but to move the enemy towards the player i will also need the direction so i need to know what angle this arrow is going to be so that i can move the enemy in this direction but once i have this direction i can just move it with my speed and then use the move method and then my enemy would be moving basically what all of this means i want to create a method itâ€™s called define that is going to get player distance and direction and this one itself and the player again and what this method at the end of the day is really all supposed to do is to return a distance and a direction direction so now we have to get both of these things and this might be a good exercise to check your vector math so try to figure out the distance and the direction between the player and the enemy although donâ€™t worry if you canâ€™t do it yourself all right letâ€™s do some vector math first of all i want to get some vectors letâ€™s call it my enemy vector and my player vector and essentially all that means is i want to use pygame.math.vector2 and pass in self.rect.center so that way we are converting the center of our enemy into a vector and that makes it much easier to work with and i want to do the same thing for my player so pygame.math.vector2 and then player.center so now i have two vectors and thatâ€™s going to make my math significantly easier and thatâ€™s already bring us to the first variable we want to get the distance and really all we want to get is the distance between these two vectors and the first thing we have to do for that is get our player vector and subtract the enemy vector from that so this is going to give us another vector that shows us the relation between these two vectors but importantly this is not a distance right now itâ€™s just another vector and let me illustrate this this can be a bit confusing so right now this is our entire game window and letâ€™s say our player is here and our enemy is here and each of those have their own separate vector and remember a vector is essentially an arrow so the vector looks like this for the player and like this for the enemy so weâ€™re going in x and the y direction to get to our player or our enemy and when we subtract these two vectors from each other we are getting this vector here and letâ€™s say just for some numbers this could potentially be something like for the x itâ€™s going to be positive so x could be letâ€™s say 100 and for y possibly a bit less letâ€™s say 80. so this would be the vector that shows us the distance between our player and our enemy oh well not the distance just the arrow to get from the player to the enemy but importantly this is not a distance we couldnâ€™t really use this by default to understand how far away the enemy is but this we can change quite easily all we need is dot magnitude and this is converting a vector into a distance and this we can actually use so with that we already have our distance and i guess with that we can also work on the direction and this one isnâ€™t all that much more difficult itâ€™s actually very similar so we again want to get my player vector and subtract my enemy vector from that so again now we have our vector let me actually again bring it up again so now we have this vector but the problem we have now is letâ€™s say we have this vector and we want to multiply it with the speed letâ€™s just call it s to move our enemy towards the player the issue we have now is that this vector is going to be way too large so if you just multiply it with s being 5 then this arrow here wouldnâ€™t go towards the player it would go all the way to something like this so our enemy would just move way past our player since the original vector is way too large so essentially what that means is we want to reduce the length of this vector to one so we keep the direction but we reduce the length of this thing to make it exactly with a length of one and that way we can multiply it with the speed and have a proper movement and what that basically means is we have to normalize it and that way we will get a proper direction that we can actually use fortunately that is a very easy thing to do because all we have to do is pass in normalize afterwards and we are basically good to go although we do have to be careful and this is something we have seen with the entity earlier so in the move here we had to first check that the magnitude of our vector isnâ€™t zero and only then could we normalize because you cannot normalize a vector that has a length of zero so essentially we have to check if the length of this vector is greater than zero and only then can we normalize it now fortunately we already know how long this vector is going to be itâ€™s just our distance so we can use the distance in an if statement and just check if this is greater than zero and only if that is the case we want to get this vector and this distance could actually be zero if our player and our enemy are in exactly the same spot remember thereâ€™s no collision between the enemies and the player and i guess what we can also do is if that actually happens so if my player and our enemy are on the exact same position we know in that case the direction could just be pygame.math.vector2 with 0 and 0. so if our enemy is right on top of the player we can just give it a vector of 0 and 0 and not move it at all and well with that we have our proper function that gives us a distance and the direction so now let me copy it we can paste it in here make sure to call it and pass in the player and right now we only really care about the first one so we only care about this distance here for now we donâ€™t care about the direction that will come very soon though but now we have another problem that i want to get myself.get status but now i have to get my player in this update method unfortunately this update method is going to run for every single way to have it every single visible sprite and passing in an extra argument to all of these seems kind of inefficient since only the enemy is going to need a player in the update method so instead hereâ€™s what iâ€™m going to do let me minimize all the methods in my level and in my ysort camera group iâ€™m going to give this another method and iâ€™ve got this one enemy update and only in here we get self and we get the player and essentially what i want to do in here i first of all want to get all of my enemy sprites and this weâ€™re gonna get in just a second and then for enemy in enemy sprites i want to call sprite dot enemy update and then in here i can pass in the player and then in my run method besides the regular update i want to call self.visiblesprites.enemyupdate and this one is going to get self dot player lay here so that way we can separate the enemy with the update method and i guess that means i want to copy or cut out all of this and give this enemy the enemy update method that is going to work very similar compared to the update method except now itâ€™s for the enemy only and this one gets self and player so now we have access to the player so the last one we have to figure out is how to actually get all of the enemy sprites and essentially what i want to do is i want to get my sprite or sprite in self.sprites so this would give us literally all of our sprites and i only want to select the ones with the enemies from that so this is going to be an if statement and here it becomes important that each of our tiles or each of our classes has a sprite type so our enemy has a sprite type and our tile has a sprite type and our player should have one as well not sure if i gave him one but doesnâ€™t really matter the player doesnâ€™t need one so what i want to check if sprite dot sprite underscore type is equal to enemy because in my enemy my sprite type is enemy now this can be a tiny bit dodgy because if a sprite doesnâ€™t have a sprite type attribute weâ€™re gonna get an error so what i want to check first is another if statement that if has attribute now has attribute basically just checks first a class and then we can check for a specific kind of attribute which in my case is sprite underscore type so we are first checking if the sprite has a sprite type attribute in the first place and once we have that we are checking if that sprite type is going to be enemy so that way it doesnâ€™t matter if the player has a sprite type or not or if we just forgot it for some other tile or maybe if you want to add more tiles later on this would basically save you alright so now we should be having a distance to the player i guess let me run the code nothing should happen yet we get invalid syntax letâ€™s check it out ah the problem here is this should not be an if statement so we only need one if statement and then we can combine the different if statements so now letâ€™s try this again and now we have name sprite is not defined oh and the reason here is i call this enemy i didnâ€™t call it sprite so next attempt and we get now name in our enemy name get player distance direction is not defined i think i know where this is coming from exactly here this should be self so now the next attempt and now things are working again although still nothing is happening but at the very least we are not getting an error so whatâ€™s happening now is we are getting the status but we are not using that to move the enemy but letâ€™s work on that now then we can actually see whatâ€™s going on so i want to create another method and letâ€™s call this actions and then here we need self and we again are going to need our player and in here i want to check my status so if self.status is equal to attack then i want to do a certain thing for now letâ€™s just print attack then i want an l if statement if myself dot status is equal to move i believe i called it letâ€™s double check yeah move so if this move is the case letâ€™s say weâ€™re going to work on this in a second letâ€™s call it pass for now and if neither of these is the case i well donâ€™t really want to do anything but letâ€™s just say self direction is going to be pygame.math.vector2 this line here is important if our player let me draw it actually so if this is our enemy and this is the circle that attacks if the enemy is supposed to move towards the player if the player is inside of the circle then our enemy is going to move towards the player but i also want to make sure that if the player moves out of that circle then the enemy is supposed to stop moving so this is what this line essentially ensures that once the player is leaving the circle the direction of my enemy gets back to zero so it stops moving all right the actually interesting one is this one here i want to make my enemy move towards the player once the player is getting closer and this is again going to be in self dot direction and in here we need self dot get player distance direction it needs the player and now we care about the second element being returned so index one which is the direction so this is what we are getting now and now in my any update i can call self dot actions pass in the player and now letâ€™s try this so now we can actually see something moving so now the enemies are coming towards us if we are close enough on the cache you see if the enemy is overlapping we get attack in the bottom left so now we can actually do something so this section was probably one of the more difficult parts of this tutorial because there are lots of steps that need to be taken together so if you struggle to come along i would really recommend to double check each of these methods and see what they are doing there wasnâ€™t really any easier way of doing all of this but all right i guess now what we can work on is to animate the enemies and in here we basically want to do the same kind of animate we have done for the player let me just have a look actually letâ€™s minimize all of the methods here and i kind of want to do the same thing iâ€™ve done for the player to animate the different kinds of states although for the enemy itâ€™s going to be a tiny bit different so we couldnâ€™t put this animate in the entity and also apply to the enemy although it is arguably somewhat similar but letâ€™s go for it step by step so first of all i want to get myself dot frame index and add plus equal self dot animation speed so these two parameters we are getting from the entity they are all the way at the top and now i want to check if self dot frame index is greater or equal than the length of self dot animations and then myself dot status and if that is the case i want to set self dot frame index back to zero so this is pretty much the same thing we have done in these two lines except i guess the animation we have set for the player in a separate variable makes it a bit easier to read letâ€™s do it here as well so now length of our current animation so so far those two are pretty much identical and for now they will continue to be identical because now we can set self dot image is going to be my animation and i want to get my integer of self dot frame index and importantly here what we have done for the player as well we have to update the self.rect so let me copy it actually and now we are setting our rectangle in the center of the hitbox because remember we are moving the hit box we are not moving the rectangle so if we didnâ€™t add this we wouldnâ€™t display the enemy in the right position but now we can in the update method actually called self dot animate and letâ€™s try this now and we actually get animation and they donâ€™t really have a good attack animation i think this one is an attack animation yep there we go so now this thing has an attack animation and i guess the proper attack animation comes with the raccoon and there we go this is working not badly although now we have a problem and let me actually stand here i want to make sure that my enemies have a proper attack animation so for the raccoon for example itâ€™s supposed to play the entire thing and not be stuck in the attack loop which i think looks a bit silly so that is something we have to work on in our enemy and i think itâ€™s a good idea to minimize all the methods in my enemy itâ€™s getting a bit longer and in my init method i want to add another section and letâ€™s call this one player interaction and for now on here i want to have one method thatâ€™s called self.can attack and by default this should be true and then in my get status i only want the enemy to be able to attack if the player is close enough and if self dot can attack is true and now in my actions once the player has actually attacked i now want to restart the timer to make the enemy not attack anymore but now we have a problem so this entire graph is the entire length of our attack animation for the enemy and for the sake of simplicity letâ€™s say it has just a couple of frames so we have zero one two three and four and each of these is a frame for the different cycles of the attack now if we set dot can attack defaults in here then we would only get to the first step and then our attack would stop so we would not actually see the attack so what we want to do is we want to set self can attack only to false after the animation has finished and this is then going to happen in my animate would i put it down here animate function so what i want to do in here is if self dots self.status is equal to attack so right now weâ€™re checking if our current frame index is longer than the animation and if we are attacking and only if those two are correct then we can set self dot can attack back to false and that way the player only stops being able to attack after the attack animation so now we have a proper method here so technically now the enemies should only be able to attack once letâ€™s try this with the raccoon so there you could see our raccoon could attack once but not again so this is working reasonably well so now what i want to do i want to create a timer that the enemies can attack again after a certain period of time and this i think could be a pretty good exercise so check the previous cooldowns we have created and try to make a similar one for the attack animation of the enemies alright first of all we need two more attributes we need self dot letâ€™s call it attack time by default itâ€™s going to be none and we are going to need some kind of letâ€™s call it attack cool down in my case iâ€™ve set this one to 400 itâ€™s identical for all of the different enemies although this you could also put into this dictionary if you really wanted to but mine is already getting quite long so i didnâ€™t worry too much about it now let me minimize all of those methods and letâ€™s put it down here i want to create a timer for the attack cooled down and in here i first want to check if not self dot can attack because we only want to check this timer if this one is wrong and here we have to get our current time with pygame.time dot get underscore ticks that was atrocious spelling all around this one should work now and now if my current time minus myself dot attack time is greater or equal than myself dot attack cooldown and if that is the case self dot can attack should be set back to true now the one thing i havenâ€™t done is to get my attack time and this is going to happen in my not in my animate itâ€™s going to happen in my actions so in here besides print attack i want to get self dot attack time and it should be pygame by game dot time dot get underscore ticks and now letâ€™s try this and we get invalid syntax in the enemy ah because for attack cooldown i forgot the self now letâ€™s try it again and there we go so now we get attack okay thatâ€™s a bit hard to see so the animation still doesnâ€™t seem to work perfectly letâ€™s see what went wrong ah and i believe in my get status in this line here after we have just attacked i want to check if self dot status is different from attack and if that is the case i want to set self.frame index back to zero so we essentially always want to be able to reset the animation once we switch to different animations maybe that helped nope also didnâ€™t make a difference so thereâ€™s something else i missed sorry the code is getting very long itâ€™s a bit hard to plan this oh and i think iâ€™ve just realized the mistake that this attack cooldown we donâ€™t actually call so self dot attack cooldown and while doing this i realized we have one attribute called the tag cooldown and the method is called the same so letâ€™s just call it cooldown our enemy only has one anyway so now letâ€™s try this again so letâ€™s go to the raccoon and this is looking much better cool there we go so now we have proper attack animations and once we add particles this is going to look even better but now we have the basic enemy logic and i guess this was a really long section so letâ€™s finish this one for now and for the next one we are going to start with the interaction between the player and the enemies so letâ€™s talk about that and this has to go two ways on the one side our player has to be able to attack the enemies with the weapon or with magic and on the other side the enemies have to be able to attack the player as well now the logic for the enemies attacking the player is actually quite simple we already made most of it all we really have to check is if the enemy is close enough and then triggers an attack and if that is the case we can just call a function to reduce the playerâ€™s health now the other way around is a bit more complicated because we have to check if the player weapon actually collides with an enemy and hereâ€™s how we are going to do that we are going to create two more sprite groups one is called attack sprites the other is called attackable sprites and whenever we create a weapon we are going to put it into the attack sprites and magic is also going to go in there and all of the enemies or anything that can be attacked will go into attackable sprites and then in our level weâ€™re going to check the collision between any sprite and attack sprites with the attackable sprites and if there is any kind of collision then weâ€™re going to check the tile type and trigger a certain thing for example if we have grass weâ€™re going to destroy the grass if we have an enemy we are going to lower the health of the enemy and thatâ€™s pretty much the entire logic there are a couple of visual things we are going to add but letâ€™s implement the basic logic first here we are back in our main file and i want to go to level and in here we already have quite a few different methods and i want to go to my init method and add a bit more here and i guess we can put this under attack sprites it doesnâ€™t really matter where you put it so here we have attack sprites and this is just pygame.sprite.group then i can copy it and letâ€™s create another group thatâ€™s called attackabilt sprites so the basic logic is we are going to spawn our weapons and our logic inside of this group all our enemies will be in this group and then we can check the collisions between these two groups and check if we hit anything but for that to work we actually have to assign things to the different groups so letâ€™s start with the enemies in create map so in this section here actually in this section here we are creating all of our enemies and right now the enemies are just invisible sprites but they should also be in self-dot attackable sprites and i guess for this one let me put the enemy on multiple lines so itâ€™s a bit easier to see whatâ€™s going on because enemies will get a few more lines of code and iâ€™d like to keep it a bit more readable now next up when we are creating an attack so in this method here we have our weapon and right now this one is also only invisible sprites and it should also be in self dot attack sprites so now we have well different kinds of sprites and thereâ€™s one thing i forgot because the grass is also supposed to be attackable and that could be a good exercise so try to figure out which group the grass should belong to should be really easy so in my grass right now i have self.visible sprites and self.obstacle sprites and i want to add a third group that is self dot attack a bill sprites attack bill sprites there we go and since grass is also getting quite large letâ€™s put this on multiple lines so itâ€™s a bit easier to read so now we have a couple more groups although if i run the game nothing is going to change but now in my level let me minimize the create map function again itâ€™s getting a bit large i want to create another method and letâ€™s put it right at the end and letâ€™s call this one player attack logic and we need self and nothing else and in here we basically want to cycle through all of the attack sprites and then check if any of those are colliding with any of the attackable sprites and be aware for now we only ever have single attack sprite whatever our weapon is but later on once we have magic there could be multiple sprites inside of that group so just be aware of that so first of all letâ€™s use an if statement to check if anything is in attack sprites in the first place because if not we donâ€™t have to bother anyway now once there is something inside we can check for attack sprite in self dot attack sprites and now i want to use pygame dot sprite dot sprite collide and in here we need a sprite we need a group and then we need to do kill argument and letâ€™s go through what this one means and sprite is the easiest one itâ€™s just going to be a sprite letâ€™s say it is this sprite here then we are going to check this sprite if it collides with any sprite inside of a group so letâ€™s say we have our group here and inside of this group we have a bunch of sprites it doesnâ€™t really matter how many you have itâ€™s completely relevant and this method basically goes through if this sprite is colliding with any of these sprites and then the do kill argument determines if the yellow sprite is gliding with the purple sprite are we going to destroy that sprite and thatâ€™s literally all that sprite collide does so in my case i donâ€™t want to kill any of the sprites for the sprite i want to check my attack sprite and for the group i want to look at itâ€™s going to be self dot attackable sprites and this then returns a list of all the sprites that have been colliding so we can store it in letâ€™s call it collision sprites so what we can do now once we have that we can check if collision sprites exists so if we have any kind of collision and then once we have that we can cycle through that list and letâ€™s call it for target sprite in collision sprites and now we finally have the sprite that have been colliding with our weapon so what we can do now is check different kind of things but i guess for now we can just check if this is working so letâ€™s say target sprite dot kill so we essentially destroy any kind of sprite we are attacking and we have to make sure weâ€™re actually calling it letâ€™s call it right after the enemy update so self dot player attack logic and now letâ€™s run it we donâ€™t get an error itâ€™s good start and now i can attack the grass it disappears i can attack the enemies they disappear and this seems to be working quite well obviously not ideal so far but at the very least something is working the problem now is we donâ€™t just want to destroy the target sprite we want to do something else and to figure out what we have to do we have to figure out the sprite underscore type so for example for my grass the sprite type would be grass thatâ€™s the one we set here so this is basically then an if statement so if the target sprite is equal to grass then well if that is the case we just want to destroy the grass anyway so in here we actually do want to get target sprite dot kill and letâ€™s try this now so i can attack the grass this one still disappears and if i attack the enemies they also disappear so something has gone wrong here letâ€™s check oh and i realized that this argument here should be false because i do not want to destroy the sprite so you have just seen that because this one was true we are destroying any kind of sprite so we basically never got across this line so now it is false letâ€™s try it again now so we can still destroy the grass but now the enemies we canâ€™t destroy anymore now itâ€™s working and right now this destroying here looks kind of boring but later on once we had some particles it does end up looking significantly better but step by step now besides that if weâ€™re not attacking grass i guess i can just add an else statement because we only really have one other thing we can attack and thatâ€™s the enemies although each of our enemies also has a sprite type so you could be more specific if you really wanted to but now we can again target our spread type and now i want to give them a method and letâ€™s call it get damage and for this one i need a couple of arguments so first of all i want to know what the player is doing and besides that i also have to know with what attack we are hitting the enemy so are we using a weapon or are we using magic so i basically want to know the attack sprite dot sprite type so this is the attack sprite we got from all the way up here that we are going to pass in there and let me just make sure that our weapon actually has a sprite type so we can reopen our weapon and right now this one doesnâ€™t have a sprite type so we have to give it one and letâ€™s do it right at the top so self.sprite underscore type is going to be weapon so now we can use it and let me close it again so we donâ€™t have too much random stuff and all right now in our enemy we have to create this method and i guess let me copy it so we can work on the parameters so back in my enemy let me minimize things in here i want to create get damage and we will need the player and besides that we are also going to need letâ€™s just call it the attack type and essentially what i want to do in here is if the attack type is equal to weapon then i want to set self dot health negative equal and now i have to figure out by how much i should lower the health and for that i have to know what is the playerâ€™s damage and this iâ€™m gonna get with another function and from the player i want to create a new method letâ€™s call it get full weapon damage so this is basically a getter function and letâ€™s copy this one and now we can go to my player in here letâ€™s minimize things as well and now we can add another method in here itself and nothing else and in here really all we want to do is want to get our player base damage we can get this from this dictionary here so our base attack is going to be this one and then besides that we also want to get our current weapon so the one we have basically up here and we basically want to get these two together and that is our full damn mitch so weâ€™re just adding those two numbers together so in this function letâ€™s first get the two different kinds of damage we have so we have our base damage and we have our weapon damage and all i essentially want to return is my base damage plus my weapon damage so all i have to figure out is what these two numbers are going to be and actually letâ€™s do this as an exercise so try to figure out from the player what is the full damage so what is the base damage plus the weapon damage for the base damage we essentially want self.stats and in there we have what is called attack we are essentially looking at this dictionary entry up here and then besides that i want to have my weapon damage and for that i first have to get my weapon data so in settings i am essentially accessing this data here and i want to get one of those keys letâ€™s say right now my weapon is a sword and then i want to get this key and this is information i can get from self.weapon what i can do here is weapon data and then self.web pin and once we have that i can just pick another entry because now we have this dictionary for the sword and inside of this dictionary we have damage and well all i have to do is add this to damage oh and while we are here i realized i forgot something because in our settings we also have a weapon cooldown and i didnâ€™t include that one in our player cooldown so in my player in cooldowns here we have the attack cooldowns and this is my base cooldown and to watch this i also want to add the weapon cooldown so in here we can basically do the same thing so we still use our weapon data letâ€™s copy the entire thing but except now instead of damage i want to add cool down and that is going to be this cool down here all right but now we have our get full damage so with that we can return to our enemy and now we have something i guess later on what weâ€™re also going to do is else letâ€™s add a pass in here but this is going to be magic damage itâ€™s going to work slightly differently and right now i guess this would work but we would never be able to see it because well our enemies donâ€™t have anything to well react to so i want to add another method again and this is just going to be check def needs self and nothing else and all weâ€™re going to check in here is if self dot health is smaller or equal to zero and if that is the case i just want to run self self.kill although right now this logic isnâ€™t going to work but i guess letâ€™s just try the entire thing and see if things are working so we can still destroy the grass enemy get damaged doesnâ€™t work so letâ€™s have a look should be here in my player attack logic so we have self the player and the tech sprite so this one seems to be working so in our enemy iâ€™m pretty sure i know what i forgot and what i forgot itself so now letâ€™s try this again letâ€™s attack an enemy and we can see that nothing has happened and this happened because in my enemy iâ€™m not calling check def so in my update method we can run self.jackdev you could also call it in the enemy update it doesnâ€™t really matter so now letâ€™s try this again and there we go now we have something that maybe a tiny bit weird that all of our enemies die in one hit so even the bigger ones they just die immediately and this happens even though they should be having quite a bit of health so in my settings for the monster data the raccoon for example has 300 health but all of our damage is like 15 or maybe 30. and the problem here is that get damage runs on every cycle of our game so we think weâ€™re hitting the enemy once but pygame just sees a collision and it runs this get damage every time it has this collision which in our case is 60 times a second and that way we are essentially multiplying our damage by 60 which kills anything instantly so itâ€™s not really fair and essentially what we have to do is to create a timer that enemies can only be hit after a short amount of time so essentially all that means is we have to create another timer and letâ€™s put it all the way down here so here we have letâ€™s call it the invincibility timer and letâ€™s add something like letâ€™s call it vulnerable by default this is going to be true then we have self dot hit time by default this is none and let me spell it properly and then self dot invincibility [Music] duration letâ€™s say itâ€™s going to be 300 but again this number you could also put into the settings to have different kind of enemy behavior in my case well it wasnâ€™t really needed so now we have the basis for another timer but first of all letâ€™s implement that our enemy can only be hit once in a while and this is going to happen in my get damage so in here i want to check is if self dot vulnerable and only if that is the case i want to run all of this and by the end of it once we have run everything else i want to run self dot vulnerable is going to be false and i guess now letâ€™s try this so now the enemies shouldnâ€™t disappear anymore and they donâ€™t cool so seems to be working but obviously we do want to be able to attack the enemies so what we also have to get is self dot hit time is going to be pygame dot time dot get underscore ticks and with that we have all we need to get another timer and i guess this cooldown letâ€™s call it cooldowns and now in here we can check if self dot vulnerable if that is the case then we want to run this timer and i guess i can run the current time outside of this function so we have it available everywhere and then here we just want to check if my current time minus self.hit time is greater or equal than myself dot invincibility duration and if that is the case self. vulnerable is going to be true and i forgot this should be not self.vulnerable and now letâ€™s try this so i probably have to hit the enemy a couple of times but it does disappear eventually letâ€™s look at this one so i hit it once i hit it twice there we go this looks pretty good okay those ones are going to take longer so i just assume itâ€™s going to work but all right so with that we have the ability to damage our enemies the problem right now is the enemies arenâ€™t really being pushed back so our attack is well kind of pointless because the enemies can attack us right away anyway so i want to get them some kind of hit reaction that they are being pushed backwards and that is going to be another method letâ€™s call it hit reaction and basically what i want to do in here i just want to check if not self. vulnerable so if my enemy has just been hit then i want to set myself dot direction and multiply it with myself dot resistance and this number should be negative so think of it like this right now this is our enemy and this is our player and our player has just attacked the enemy essentially what i want to achieve is that my enemy is being pushed back in the same direction and the distance by how much the enemy is being pushed back should come from the self dot resistance and this self.resistance we are getting from somewhere in the enemy so i believe it is there resistance so thatâ€™s kind of all we are going to need and this i just want to call in my update letâ€™s call it right before move so hit reaction that way itâ€™s going to happen early on but now i also have to make sure i actually get the right direction so in my get damage all the way at the top i want to set myself dot direction and in here self dot get player distance direction i want to pass in the player that i already have and then just get the value with number one so this is the direction and really all weâ€™re doing here is we are working with the direction of the enemy and just moving it in a different direction so i guess letâ€™s try if this is working so there we go theyâ€™re being pushed back and this is making all of this feel much better and letâ€™s use different weapons this also works cool so now we have well a better get damaged method although thereâ€™s one more thing i would like to implement and that is that my enemies are flickering once they are being hit actually they should apply both to my enemy and my player so essentially i want some kind of indicator that they are being hit and usually in games this works by flickering and to achieve that i have to work with the visibility of both my player and my enemy and that is something we can kind of put inside of the entity although since our player and our enemy are animating slightly differently we do have to put this in kind of different ways but let me actually implement it so in the enemy for my animate i want to add a bit more at the bottom to make them flicker once they are being hit and essentially what that means is if self dot vulnerable and again this should be not because weâ€™re checking once the enemy is being hit then we want to essentially flicker and if that is not the case so else then i just want to get myself.image and set the alpha to 255. so when you set the alpha you set a transparency of the layer and 255 is the full value so all of this basically means if the enemy is not vulnerable anymore this one then we are setting the full alpha but if that is not the case i want to get a specific kind of alpha and this we are going to get from somewhere else and this can either be a 0 or 255 so invisibility or full visibility and then self dot image dot set underscore alpha with the alpha so now we just have to figure out a function that toggles between 0 and 255 and the same thing we are going to need for the player so iâ€™m going to create this in my entity and let me minimize all the other stuff in here we are not going to need it so in here letâ€™s call it a wave value l u we need self and nothing else and let me explain what we are going to do and we are going to use a sine wave in here and let me explain how itâ€™s going to work so letâ€™s say this is going to be a graph we have here our time and on the y axis we have the well y axis and a sine wave kind of looks something like this except in beta drawn and we can check each point of this value in time and pretty much what i want to do is if this curve is positive so if we are here we are going to return 255 and if we are below that curve so we are down here then we are going to return zero that way we are switching between those two numbers actually pretty simple but first of all for that to work we need from math import syn and now all i want to get is my value and i need to get my sign value and in here i have to pass in some kind of x which in my case is going to be the time and the time i get with pygame the time dot get underscore ticks and now if this value is greater or letâ€™s say equal to zero then i want to return 255 and if that is not the case i want to return zero and letâ€™s add proper indentation and there should be return and thatâ€™s all we need for this method i can go back to my enemy now and self.wave value and no arguments are needed and now this should actually be working letâ€™s try so now this is working beautifully cool makes the game look significantly more responsive nice now if you wanted to do the same thing with a white color instead of invisibility you would probably want to work with a mask but in my case thatâ€™s a bit of an overkill but i have made a whole tutorial on how to use a mask you could totally use that one as well but alright now i want to give my player the ability to flicker as well so in my player i want to minimize all the different methods again and look at my animate and in here i want to add flicker now unfortunately to actually implement this we well we need to know if the player has been hit or not which we donâ€™t know just yet so letâ€™s first implement the enemies hitting the player and then we can work on the flicker and fortunately this isnâ€™t all that difficult the only real limitation is that we have to figure out how to get from our enemy back to the level so we know when the enemy is attacking the player thatâ€™s going to happen in where are my actions so we know in here we can print an attack if the enemy is attacking the player that one is working perfectly fine but the issue is from this place we canâ€™t really access the player actually we can we have the player right here so technically we could run something on the player from here but i donâ€™t want to do that but a simple reason that later on whenever the enemy is attacking i also want to create some particle effects and for that to work i have to create this function in the level so essentially what iâ€™m going to create is create a couple of methods inside of my level and one of them for example is going to be damage layer this one will need self as always then we need an amount and then we need an attack type amount should be fairly obvious itâ€™s the amount of damage the enemy can deal attack type is going to be in settings itâ€™s what we get from attack type itâ€™s basically what kind of particle we are going to spawn once the enemy is attacking but for now we are not going to use it so now in here we want to write a function that can damage the player but first of all we need to deal with the same problems we have with our enemies that we first want to check if self dot player dot vulner vulnerable so essentially we want to create a timer after the player is hit so we canâ€™t attack the player multiple times in one attack but essentially once we have that weâ€™re going to implement that in just a second we want to get self dot player dots health and from that reduce the amount then we want to set self.player.vulnerable to false and in our player we want to have self dot player dot letâ€™s call it hurt time and this is going to be pygame dot time dot get underscore ticks and at the end later on we want to spawn particles but we donâ€™t have that one just yet now this damage player i want to create from the enemies so in my create map when i am creating the enemies so all the stuff down here i want to pass this one in there as well so self dot damage player and as always donâ€™t call this function and now in my enemy we also have to put this into a parameter uh spelling it correctly there we go so now in my letâ€™s call it player interaction i guess it fits best in there so self dot damage player is going to be damage underscore players what i called it oh i wrote parameter well never mind uh damage player that makes more sense so now our enemy has the ability to damage the player and now in my actions instead of printing attack i want to run self dot damage player and in here we have to figure out an amount and an attack type and well if you look at the init method we have a ton of statistics in here so the first one is self.attack damage we can just pick this one and paste it in the amount and we can do the same thing with the attack type it is all the way at the bottom this one here so attack type and actions this one here so now our enemy is able to attack the player and i guess let me minimize all of the methods it really is getting a larger project all right so this should be working at least hopefully now in my player we just have to set up all the attributes for the timer and letâ€™s add another section to this and letâ€™s call it a damage timer and in here we have self.vulnerabil which is true by default then we have self. i believe i called it hit time or was it hurt time itâ€™s hard to tell i called it her time there we go so self.her time and this by default is going to be none and finally we need something like self.invulnerability duration and letâ€™s say this one could be 500 seems like a decent value but you can take it with this and all right now in my not animate but in cooldowns i can add another timer so in here if not self dot vulnerable then i want to run the timer so if current time minus self dot hurt time is greater or equal than so self dot invulnerability duration and once that timer is running we want self. vulnerable and set it back to true so now okay well now we canâ€™t really see it but we should actually be able to see it in our health bar so letâ€™s try it and there we can actually see it in our health bar itâ€™s going down so obviously if it goes below zero we should be dying but in my case that doesnâ€™t really matter so much at the very least we know itâ€™s working so now in the player not the level the player we can now start working on the flickering and letâ€™s do this as an exercise so try to figure out to make the player flicker once we get hit should be very similar compared to the enemy right so if self. vulnerabil is not the case then i again want to get my alpha value and we want self.wave value the thing we get from the entity so this one here and we want to get our self.image.set and paste in the alpha in here and if that is not the case then self dot image dot set underscore alpha and set this to 255 so full visibility and that should be all we needed letâ€™s try this now and we indeed get hit and we can still attack the enemies and that is working really well now i guess the one downside is itâ€™s very easy for enemies to overlap but well not going to worry too much about that but you can add a few more collision mechanics and improve on this alright so with that we have pretty much all of our collision mechanics at least in the most basic sense so with that letâ€™s start working on the particles thatâ€™s going to be another major section now a particle effect sounds difficult in theory but in practice it really isnâ€™t that hard we already kind of created the basics for it anyway so essentially for my particle effects it is just going to be another sprite that animates for a couple of different images the only difference now is that this particle effect is going to disappear once weâ€™re running out of animation frames so weâ€™re not looping the animation anymore weâ€™re just playing it once and then we are giving it a position and thatâ€™s kind of all we need although thereâ€™s one downside here that we have a lot of different images for all of the different animations so i think in total we have about 15 different animations and each animation individually has about 5 different frames so we are looking at a lot of images overall and what i want to do is to import all of these images when the game starts and then keep them in memory and only play them when theyâ€™re needed in the game and the massive downside to avoid here is that we are importing images every time we are creating a new particle effect because that would be very slow importing images does take some time although i guess this is something that we can work on when we actually work on it so letâ€™s go into the code and letâ€™s have a look at this here iâ€™m back in my file and i can close a couple of things because we donâ€™t need them for now so my entity and my tile and i guess for now my enemy as well iâ€™m not going to need them and i do want to create a new file and letâ€™s call this one particles.pi and in here as always i want to import pi game and i already know that from support i want to import my import folder and now letâ€™s just create a dummy particle effect and thatâ€™s going to be a particle effect class and this one is going to inherit from pygame.sprite.sprite and in here i want an init method as always we need self spelled properly then we need a position and we want some animation frames so this is what we are going to loop over where we are getting this from you will see in a bit and then finally what groups we want to pass this into and then we need super and dunder init as always with not self but with the groups and now in here we need all the basics for an animation so self.frame index is going to be 0 then self.animation speed is going to be 0.15 self dot frames is going to be the animation frames but now we can already set the first image so self.image is going to be self dot image dot get underscore rect and then here self dot frame index so essentially this is going to be the basic setup for any kind of animation and now that we have that we can create an animate function give itself and nothing else and now self dot frame index plus equals self dot animation speed and now here we come to the difference so if self dot frame [Music] is greater or equal than the length of my self dot frames so we are going beyond the length of our animation then we want to self.kill but else self.image is going to be self.frames and we want an integer of self dot frame index so really all we are going to do in here is we are increasing frame index and if we are still inside of the list we are just picking one image from this list however if we go beyond that list then we are going to destroy that sprite so this way we are only running this animation once and once the animation has finished we are destroying the sprite and now we also have to be able to call this particle effect with the update method and then here self dot animate now we have a basic particle effect the problem is we need to figure out where to get these animation frames and now you might be tempted to just create another method like import particle images or something like that but thatâ€™d be a really bad idea for the simple reason that we have a lot of particles and if pygame always imports something when we destroy an enemy or some grass the game is going to run very slowly so iâ€™m going to do something else iâ€™m going to create another class and this i have called animation player doesnâ€™t need any inheritance and in here we are going to create an init method with self and also nothing else and this one is going to get one long dictionary where we are importing every single thing so this is going to look like this a slightly longer dictionary that well um imports all of the different material so we have our flame our aura and our heel so these are both played when the player heals then these are different attack types then we have our monster deaths and we have different leaves when we are destroying grass although in here i have created one more method that is called reflect images and this we also have to create in here letâ€™s make sure i am on the right line should be this one let me actually minimize this dictionary itâ€™s getting very hard to read things so what i want to do in here is reflect images and we need self and frames and let me demonstrate what this one is doing right now for the leaves so this is when weâ€™re destroying grass we have six different animations and pretty much what iâ€™m doing here is iâ€™m importing these animations twice once in the proper direction and then once reflected so that way we are going to get a bit more variability in there thatâ€™s really all it is and really all iâ€™m going to do in here is for frame in frames iâ€™m going to create a flipped frame and this is going to be pygame dot transform dot flip and we want to flip the frame for true and false flip can reverse something up in the x or in the y axis in my case i only want to flip the x-axis and ignore the y-axis which is why this one is true and false and now i have a flipped image and i want to save this one in a new list so letâ€™s call it new frames and that oneâ€™s going to be an empty list and now new frames dot append and i want to get the flip frame and at the end of all of this i want to return my new frames and that is basically all we are going to need for now and now back in my level we can start working with this particle effect so in here all the way at the top actually let me minimize all of this stuff again it is getting a bit confusing so at the bottom here i want another section and letâ€™s call this one particles and iâ€™m going to create my animation player with my animation so the animation player we have created in here and this animation player is basically going to be able to run a particle effect iâ€™m going to see in a second how thatâ€™s going to work but first of all we have to import it so from particles import animation player and to illustrate how that is going to work letâ€™s create our grass particles so in my player attack logic i know when i have destroyed some grass so in here i want to add a bit more logic to spawn some particles and basically what i want to do is run self dot animation player and do something like create grass particles but for that to work i am going to need two bits of information at the very least i need a position and i need to group so i can put these sprites into the visible sprite group but i am also going to need a position so letâ€™s first get the position and the position we can get fairly easily all i need is my target sprite dot rect dot center so we are playing these particles right where the grass used to be now next up for the group we just want self dot visible sprites and letâ€™s put it in the list so weâ€™re doing it in the same way we have done earlier pretty much all we have to do now is actually create this method here in my particle animation player this is going to happen down here great grass particle we need self we need a position and we need the groups and in here first of all i want to get some animation frames and the animation frames we are getting from self.frames because in here we have our leaf and i essentially want to pick a random animation from this list and to pick a random animation we need from random import choice and now in here i can just call choice and pick for myself dot frames and in there i have leaf so leaf is essentially a tuple with a bunch of lists inside and we are picking one of these lists and now that we have that we can actually create a particle effect so particle effect and then we need these parameters let me just copy them in here so position we already have animation frames we get from animation frames and then groups we get from groups so we didnâ€™t actually have to make any kind of change and well that should be it letâ€™s try so we get an error with inconsistent use of space letâ€™s see where heâ€™s complaining in there and in return new frames and from level a couple of errors so from particles in there not sure what happened with this one that was very strange okay there we go and now you can actually see that this one it took quite a bit of time to load and we get a key error so letâ€™s check my particles and oh i didnâ€™t mean left i mean leave okay now letâ€™s try this again now we get self where was that arrow so in particles we are getting self.image okay it is getting a bit late letâ€™s try this again now and now particle effect has another problem letâ€™s check it out and self.image this should be self.frames um it may be getting a bit very late letâ€™s check this out letâ€™s try again okay and now for the particle we are going to need a rectangle and this we get with self dot rect is going to be self dot rect dot get rekt and then here i just want to place the center is going to where the position will be okay we are working for all the errors so now particle effect has the same error that shouldnâ€™t happen anymore self dot image okay i am going to take a break after this section okay now particle effect we are back here and this should be self dot frame index so another attempt there we go finally now we have some particle effects that are going to spawn randomly and this is looking much better now there are a couple of things we have to work on first of all right now we are only spawning a single leaf which is not great so i want to create multiple and essentially what i want to do for a leaf in range and then here iâ€™m going to use rand int which i have not imported yet i believe from random we have choice but we donâ€™t have rendent i want to get random number between letâ€™s say three and six and then for each of those numbers we are going to create another animation and that way we get a bit more particles letâ€™s try this now this already feels a bit better so this is quite a nice effect cool although now i feel like in my level this position doesnâ€™t feel like itâ€™s really appropriate so i want to give this one a tiny bit of an offset so iâ€™m just going to add an offset and this is going to be pygame.math.vector2 and here 0 and 75. so weâ€™re just lifting up the particle effect by a tiny bit and this iâ€™m just going to subtract from my position and that just feels like itâ€™s looking better and there we go might even be a bit too high although this one feels pretty good and okay with that we have some basic particle effects and we are making some solid progress okay let me close it and now we can work on the other particles for the enemies and fortunately we already have in my level let me minimize all of this again we already have one method thatâ€™s called damage player and in here we want to spawn some particles so what i want to do in here is self dot animation player and letâ€™s call this a bit more generic generate particles although for this one we need a few more arguments so i want to know what the attack type is going to be so which of these different attack types are we going for so slash claw thunder and leaf attack besides that i need a position and i will need the groups where they should be and we can basically figure out all of these things right now so the tag type is pretty straightforward this is the one we already get from the argument position is going to be self.player player.rect.center and for the groups iâ€™m just going to go with the visible sprites so now all we have to figure out is how to create this function here about this method so in my particle effect i want to create my particles we have a tag type we want a position and we want the groups and letâ€™s do this one as an exercise so now try to write this function that our animation player plays one particle once the enemy is attacking the player alright first of all we need animation frames again and we want to pick from self.frames and in there we have different kinds of attack as a key so we can just pass in the attack type actually i think since we are later going to use discrete particles for something other than attacks letâ€™s call this not attack type but animation type that makes a bit more sense and now we have our animation frames now i can just call particle effect we again need a position we need the animation frames and we are going to need our groups back in my level now i have all i need i think and letâ€™s try this actually letâ€™s check letâ€™s reopen my enemy and letâ€™s see if we are passing in the right information so when we call in my where is my actions so in my actions when we call damage player we pass in attack damage and attack type so attack type is what we need i guess letâ€™s try it and letâ€™s see what we get so again we have problems with the indentation i do not know what his problem is okay letâ€™s try now and now if the enemies hit us we get an error so three position arguments but four were given so letâ€™s have a look i think i already know the problem i forgot self okay now letâ€™s try this again and now we get proper animations and letâ€™s try different enemies so we get this one and we get sparks we get all of this i may have spawned too many enemies uh okay but this is looking pretty good letâ€™s get to this squid as well and this one okay yep you can definitely see it but yeah i pretty much spawn too many enemies but who cares right now okay so with that we have our basic particle system and what you can see in there as well we have used basically the attack animations and the leaf animations now thereâ€™s two more that we need to figure out we have the monster death animation and we have the magic one the monster deaths we can already take care of the magic ones come in the next section so letâ€™s talk about the monster deaths and essentially all we have to do is play this animation once the monster is being destroyed all this really means is back in my level let me minimize this one i want to create letâ€™s call it trigger death particles and we need self and a position and a particle type and all iâ€™m really going to do in here is get myself dot animation player and call create particle the decoded particles create particles yes particles and i get the particle type from the argument same for the position and they should always be in self dot visible sprites and now all i have to do is when i create all of the enemies again so all the stuff down here iâ€™m going to pass this function in there as well so self dot trigger def particles and now in my nme class i guess let me minimize all the methods here as well we first want to create another parameter so letâ€™s call it trigger def particles this one has to be stored letâ€™s put it into play interactions self dot trigger def particles is going to be trigger death particles so now we can call this method from inside of the enemy actually letâ€™s do this as an exercise so try to figure out when to call this method with the different arguments all right so i want to trigger this when the enemy is dying so this line here and really what i want to call is self-taught trigger death particles and in here i need let me actually copy it from the particles so weâ€™re just calling the animation type a position and a group and in here let me open it in the level we want to trigger def particles we need a position and a particle type so in the enemy position and particle type now position is going to be self.rect.center and the particle type is just going to be self.monster name i think i called it all the way at the top uh monster name there we go so this is the name if you look at the particles monster name is the name of the particle or the name of the key and with that we should be good to go letâ€™s try so now if i tag any of these weâ€™re getting a proper animation so letâ€™s try it again looks pretty good and letâ€™s try with a different enemy u and this is also working so i assume they all work identically and with that we have most of our particles covered the one thing we still need is the magic so in the next section we are going to figure out the magic that one is going to be a bit more complicated but we are getting very close and iâ€™m going to take a break before i go to the next section because those were way too many errors sorry about that so letâ€™s talk about the magic and for the magic we right now have two different spells one for fire and one for healing and those two do very different things the flame is going to work kind of like the sword that it damages enemies whenever thereâ€™s contact and this is literally going to work like the sword in the sense that we are going to put the flame inside of the attackable sprites and then check for collisions so all we really have to do is place the flames and animate them for which we have most of the things we actually need now for healing it is getting a little bit easier because this one doesnâ€™t need any collision with the enemies we just have to spawn some particles and heal the player so increase the health but i want to create this in a slightly more flexible way so iâ€™m going to put all of this into a separate class and letâ€™s implement this straight in the code i think thatâ€™s going to make the most sense so here we are back in our project and i want to create a new file that iâ€™m going to call magic dot pi and in here i want to do the usual so import pygame and from settings import all of it and now i want to create a class that i called magic player thereâ€™s no need for inheriting anything and i want to create an init method with self and besides self we also want to get an animation player as a matter of fact this is the animation player we have created here so when we create this magic player it can play animations from our animation player so in here all i want is my animation player and thatâ€™s going to be my animation player and now basically all i want to do i want to have one method for here needs self as always weâ€™re going to add more parameters later on but for now letâ€™s add pass and i want to create a flame that for now works in the same way that it doesnâ€™t do anything so right now we have two spells you could be adding more here if you really wanted to so how can we actually use this thing now well in my level let me actually move it all the way to the left because itâ€™s the most important one and letâ€™s minimize some methods so essentially what i do in here in my init method besides the animation player i also want to create a self.magic underscore player and this one is going to be my magic player and as the one argument we need the self dot animation player and for this to work we have to import from magic import magic player so now we have our magic player and as a matter of fact we already have a create magic method and then here we have the style the strength and the cost and this we can use to cast the magic so essentially what i want to do is if the style is equal to heal is one i want to cast some healing and if the style is equal to flame i want to do something else which for now is going to be pass but letâ€™s start with healing thatâ€™s the easier one i think so we already have our self.magic player and all i want to do here is call heal so i want to call this heal method and i just realized this is a horrible way to spell magic so let me save this one and letâ€™s spell this one properly so magic dot pie all right now in my here i want to actually cast the heel but letâ€™s first check if this is working in the first place so i want to print heal and this should actually be working for now so letâ€™s try it let me go to my heel and we can see heal we still get the other stuff but that doesnâ€™t matter right now so i printed this one as well but i guess we can get rid of it we donâ€™t need it anymore at the very least we know this heal spell is going to work and in here now we have to figure out a couple of parameters so i first of all want to know my player then i want to know my strength then i need the cost and then i need the sprite groups and now when we call this thing we can pass all of this in here let me actually copy all of the parameters thatâ€™s going to make things a bit easier my player is just going to be self.player in this one we need for the position now the strength and the cost i already have is just the strength and the cost up here so we can just pass both of those in here and we are good to go now finally for the groups this is going to be a list again and in here i just want to have myself dot visible sprites and since thereâ€™s no collisions with these sprites we donâ€™t need anything else but for the flame we will also need our attack sprites but all right now we have all the arguments we need now we can actually work with this and the first thing we will need is if we can actually call this spell so if my player dot energy is greater or at very least equal to the cost and if thatâ€™s not the case nothing should happen and once that is the case i want to get my player dot health and at plus equal the strength of the spell and besides that i also want to get my player.energy minus equal the cost so weâ€™re increasing the health of our player and decreasing the energy thatâ€™s kind of how all of this works and i guess now we can actually try this so now letâ€™s select the magic spell it is working but now we if we press this again well we keep on increasing our health bar but once weâ€™re running out of enough energy we stop being able to cast it although the animation still plays but i kind of like the effect all right now what we have to figure out is that if our energy gets too large we donâ€™t want to overshoot on the health bar which also is fairly easy to do all we want to do is if our player health is greater than or equal to my player dot stats and then here health now this health is our maximum health so in the player i have it right here our stats is what we initiate the player with so 100 here right now is the maximum player health and then in our code we are keeping our actual current health in this variable or this attribute so this is going to be our max health if our current health is greater than our max health i just want to set my player health equal to my player dot stats and the health in here so now i can select my healing spell again now we have maximum and i made a typo this should be player now letâ€™s try this again and now we have our energy still decreasing but we cannot increase our health anymore and i guess here we have to make a decision do we want to play it to be able to increase the health or cast the healing spell if we already are at maximum health and i think most games handle it by allowing the player to cast the healing spell even though we have full health so iâ€™m not going to worry about it but with that we have the basic healing mechanic now finally we have to spawn some particles and in my particles i have aura and heal and i want to spawn both of those once we are casting a spell hence we should be calling this animation player here twice and i think this could be a good exercise for you use from our particles they create particles method and spawn the aura particles and the heal particles every time we are calling the heel magic effect right so in my heel method i want to get myself dot animation player and create underscore particles so now we are calling this method here and this method has three arguments and in my magic i want to paste the paradise so animation type the first one is going to be aura then for the position this should be in the center of my player so i have my player i want to get the rect and the center and groups we are just going to get from the groups we pass in into the parameters so thatâ€™s something weâ€™re going to figure out in a bit but now in my level i am already casting self.visible sprites in here so i have the right group and this should give us one particle animation letâ€™s try it actually so now we get the aura spell this looks pretty good and once you run out of energy it doesnâ€™t work anymore and now i also want the heal particle and for that i can just duplicate this line and right here for the particle type so now letâ€™s run this again and now we get the other particle as well what you could theoretically do give this heel extra effect an offset that can look kind of nice so in magic when you add the center you can add plus pi game dot math dot vector 2 and 0 for x and something like negative 60 or the height and now if you try this again this thing is now slightly on top um whatever you think looks better in my case iâ€™m not going to care too much about it so let me just remove it so all right with that we have our healing spell although thereâ€™s one more thing i would like to add because right now we donâ€™t really have any way to increase our energy once itâ€™s run out which doesnâ€™t feel very good so in my player let me minimize all of the methods here i want to create another method that i called energy recovery and we need self and nothing else and basically what i want to do in here is if self.energy is smaller or equal to myself dot stats and energy and then i want to get self dot energy and for now letâ€™s say plus equal one although that number is going to be way too high and now if our energy for whatever reason gets greater than our maximum energy so else i want to set self dot energy equal to self dot stats and energy and now we can call this method so self dot energy recovery and we should have recovering energy so now you can already tell our energy is increasing really fast i canâ€™t even cast the spell fast enough to deplete my energy but at the very least itâ€™s working but we do have to make some adjustments in my player first of all they shouldnâ€™t be smaller or equal they should just be smaller so now letâ€™s rise again and now our energy bar stops at the maximum but if we cast a spell it still recovers way too fast so instead i donâ€™t want to add one i want to add 0.01 and now if i cast this again now we can see a small increase and even if i cast the magic it still keeps on increasing so this works quite nicely now what you can also do is use in my stats i have it right here in here we have magic and this one i think is best to use it for two purposes one is our magic damage and then the other is our magic recovery so i want to multiply this with self dot stats and magic so that way if weâ€™re leveling up our magic we do more damage and we recover energy faster so now letâ€™s try this again and we have i guess itâ€™s kind of fast but you can play with this around and see what works well but i quite like this so now we have magic recovery and we have our healed spell so next up we can work on the flames and those do get a bit more complex although not that much let me explain the basic logic before we start right now we have our player here and essentially what i want to do is i want to cast five different flame spells that go in the direction of the player so for example if our player is facing to the right i want to create one flame two flames three flames four and five flames and then each of those flames get a bit of an offset to create some randomness here to make it look better and well thatâ€™s the general idea and let me leave the graphic open for now weâ€™re going to need it in just a second again but first of all in my flame i want to check if my player dot energy is greater or equal to the cost of the spell oh and i forgot we need the parameters again so in here i want to get my player i want to get my costs and i want to get my groups now importantly here we have no strength iâ€™ll show you later how to get that strength but now we can work on the cost and once we have cast a spell i want to get my player energy minus equal the cost so now we have the basic setup and now what we have to figure out is how to get this direction because this direction determines if the flames are spawned to the right to the bottom to the left or up so this direction is really important to figure out fortunately we can get it reasonably easy from the player itself and we have kind of done something similar before so what i want to get is if my player dot status and my player status i can get from let me minimize all of this again itâ€™s kind of hard to read so when i imported all of the player assets we created animations and in here we have all of our possible player states and i just want to get just the direction so up down left or right and if we have something like down underscore idle i want to get rid of the underscore idol actually letâ€™s do this as an exercise because we have done this like four hours ago so figure out how to split this string to only get the direction and ignore anything like idle or attack alright so what we need is the split method and in here the one argument we need is an underscore so that is going to return a list with the strings that we have split so for example if we had down idle we would get a list of down and idle and in my case i donâ€™t care about anything that comes after the first element so i just want to get the index of zero and if that happens to be letâ€™s say right then i want to create a direction that is going to be a vector so pygame.math.vector2 and a vector facing to the right is 1 and 0. and that way we can use the vector in some math and now i can just copy all of this three times to have it three times and turn this into an l if statement and then at the end we have an else statement now first of all here we have left and left should be negative one and zero then letâ€™s say we can go with up and up has zero on the x and minus one on the y and then finally for else let me copy this direction so else is going to be just one which is downwards so with that we have our different directions and i feel like putting all of those on the same line looks a bit cleaner although itâ€™s entirely up to you to do this but in my case when i have a one line if statement tends to feel better to have all of this on one line now we have our direction and now basically what i want to do since i want to spawn five flames i want to create a for loop so letâ€™s call it for i in range and then here you might be tempted to go something like five but i want to use this i for the offset so the first element should be a 1 and that way we can multiply this one with the tile size to get an offset of 64 pixels to the player center so this shouldnâ€™t start at zero it should start at one and since we still want five elements it should stop at five and go up two but not include six so now we have a proper for loop and now for the math i have to split this thing into horizontal and vertical direction so if direction dot x exists so itâ€™s different from zero this is going to be horizontal and else itâ€™s going to be vertical and letâ€™s just add a pass here for now so we donâ€™t get an error now we can work on letâ€™s start with the horizontal one first of all i have to get an offset and this one is in the x direction and basically what i want to do let me draw this out let me get a bit of space here we have my player again and letâ€™s say my player is facing to the right so my direction is going to be a vector that is one and zero the one we have created up here and essentially what i want to do i want to multiply this with i so the number we got here so if the vector is positive this one is going to get us further to the right and if the vector is negative for example if it was going to the left this would give us an increasingly larger negative number but now we would still just go by pixels of one so we go one to the right two to the right three to the right and so on so i want to multiply all of this again with my tile size and that way the first flame is going to be right to next of the player and we have an offset here of 64 pixels which is going to be the tile size and then for the next flame since i now is 2 we go another 64 pixels further to the right and now the center of our rectangle is going to be here the arrow should be a bit letâ€™s put the arrow but here so essentially all i want to do i want to get my direction dot x and multiply it with i and now i want to multiply all of this with my tile size i think i called it yep tile size this one and now for each of the flames i want to get an x and a y and once we have all of that i want to call myself dot animation player and create particles and then in here i want to call my flame so in my particles the flame here and besides that i will need a position and my groups so i need my flame i need x and y and then i need the groups i am getting from the parameters so all we have to do is figure out the x and we have to figure out the y and this might be a good exercise for you so try to figure out where each individual flame needs to be spawned so where the center x and y is supposed to be alright so first of all i want to get my player.rect.centerx and player.reg.center y because my flames are always supposed to start from my player now for the x position i want to get my offset x and thatâ€™s basically all i need and for my y position since weâ€™re only moving in the horizontal direction we can just leave it as it is and that is basically all we need so now in my level when i call flame i can call self.magic player and the arguments i passed in here was player cost and groups so player is going to be self.player again cost we already have and groups letâ€™s say for now this is only going to be self dot visible sprites the attack sprites we do later letâ€™s first figure out the flames by themselves so now if i run this we are getting an error because the dict has no attribute split so this is going to happen in my magic and self.stats it shouldnâ€™t be stats it should be stat twist so now if i run this down isnâ€™t going to work but if i look to the right we are getting some flames and if i look to the left weâ€™re also getting some flames so this seems to be working just fine and letâ€™s try one more time we do need enough energy there we go so iâ€™m happy with that although thereâ€™s one small change i would like to do right now i feel like those flames look too predictable like theyâ€™re too much in one straight line so i want to give them a bit of a random offset for both x and y and for that i need a random number generator so from random import rand and now for both of these positions i want to add rand and essentially what i have done i went from negative tile size divided by 3 all the way up to tile size divided by 3 except in the positive direction and this i have also done for the y position so essentially tile size is 64. if you divide this by 4 you get a number around 21. and that way if we have a larger tile size we get a larger offset so letâ€™s try this now and this looks a bit more random i kind of like that one so with that we have the horizontal flames now all we have to do is do the same thing for the vertical ones so let me copy all of this we can pass it in here and now instead of offset x we have offset y instead of direction.x we want to get direction.y and the rest for this line can stay the same now for x and y we need the offset x removed from the x position and added to the y position and this should now be offset y and besides that we donâ€™t need anything else so letâ€™s try it now so this side is working this side is working letâ€™s wait for some energy this side is working as well nice so now we have our flame spell it doesnâ€™t do anything just yet but we can work on it i guess letâ€™s work on it right now first thing that we have to work on is we have to place each of our flames also inside our self dot attack sprites so letâ€™s try this but we will get an error once we attack an enemy so for the grass it should work and it does itâ€™s actually really cool effect so this is pretty good but now if we attack an enemy letâ€™s say this one we get an error that particle object has no attribute sprite type and this error happens in player attack logic so player attack logic in here and in here we have target sprite get damage and in our enemy let me minimize all of the methods in here we have whereâ€™s get damage get damage is here so in here we need an attack type and for our weapons we have a sprite type called weapon and this sprite type we are passing in here so our attack sprite dot sprite type is the attack type in the enemy the problem is our particles donâ€™t have one so in this particle effect we donâ€™t have a sprite type we can give it one though so self dot sprite underscore type is going to be magic and magic is a bit broad but right now we only have a single attack spell but if you had multiple types of spells you could just get another parameter in here and there classify what kind of sprite type you have or you could even get a whole new particle effect that inherits from this particle effect and this one has a sprite type for different kind of spells so you can certainly make this very flexible with just a bit more effort but in my case i donâ€™t really mind and now letâ€™s try this actually to see whatâ€™s happening now so now if i attack an enemy we are actually getting something but you see now it doesnâ€™t actually damage the enemies in any meaningful way and the reason for that is in my enemy i have weapon and weâ€™re reducing the health but when we have anything else nothing is really happening so in here we want to do something else and in here we have to figure out how much damage we are going to get but first of all we have to get our health regardless of what we are doing but besides that i want to get from my player which we still have available from the parameters so weâ€™re going to pass this in here and now from this player i want to get full magic damage like we have done just above so now in my player i right below get full weapon damage actually let me open this method just for reference so in here define get underscore full magic damage needs self and nothing else and in here again we need a base damage and we need letâ€™s call this one is spell damage and then we are going to return the base damage plus the spell damage and well for our base damage we have self.stats and this one is magic and then for our spell damage we have magic data and in here i want to get self dot magic and then from that i want to get what i called the strength so now this should be working letâ€™s try so now if i attack an enemy they should theoretically disappear letâ€™s try it again um okay this needed okay letâ€™s try this properly without reducing for the flame damage the energy cost so that way we can call it indefinitely so letâ€™s try this again letâ€™s use this one and letâ€™s do it again iâ€™m not sure how much damage i gave ah there we go so it does indeed work and everything else still works just fine cool so with that we also have our proper flame spell so now in my player let me minimize all of the methods again and i think with that we have our magic figured out so thatâ€™s another major part of this game and now itâ€™s actually coming together really nicely and we can call different spells different attacks and all of this is working very very nicely cool we are actually getting very close to being done the one thing we still have to figure out is the upgrade mechanic and thatâ€™s going to be the next major section actually the last major section all right now how can we implement an upgrade mechanic and there are a couple of things that we need first of all something i havenâ€™t done yet our player should get some experience once we are destroying an enemy that oneâ€™s really easy to implement and once we have that the basic upgrade mechanic works like this in our self.stats we want to be able to upgrade any of the key value pairs so for example we want to increase health by 20 and every time we are doing that we are reducing the amount of our experience by a certain amount so i guess itâ€™s not really experience itâ€™s more like salts from dark souls but you get the mechanic and i guess the only really complicated bit in all of this is the gui for the upgrade mechanic because for that we need quite a few different bits but i guess letâ€™s do it step by step and letâ€™s first add an xp mechanic and then give our player a bit more data so here we are back in the code and i want to close down a couple of things so we donâ€™t need magic anymore we do need the enemies we donâ€™t need particles and settings can stay open i guess so in my player in the ending method i have down here right now my stats and i am going to need a few more stats the first one is going to be max stats so this is the maximum amount of health or energy or attack damage that my player can have and i realized speed of 12 was a bit high so letâ€™s go with 10. i also want to have an upgrade cost so this is going to be how expensive each upgrade is going to be and now just to get started letâ€™s increase our experience to something like 500 so we can work with this a bit more easily and now the first thing we are going to need is that our player should get some experience every time we are destroying an enemy and for that in our level let me minimize all the methods in here again i want to create another method and thatâ€™s just going to be add xp and this one needs self and amount and really all weâ€™re doing in here is we are getting our self dots player dot exp and plus equal the amount and now this method i want to place into the enemies so when we are creating all of our enemies the final method i get is self dot add xp and now in my enemies when they die so check def in here i also want to call self dot add exp and then we can add the amount but first of all in the parameters we have to add add exp and then letâ€™s say player interaction self dot add exp and now we can actually call it so add exp now we have to figure out how much experience the enemy should give and that information we have up here so for each monster we have a custom experience so we can just copy this one and place it in here so self dot exp and now this should actually already be working letâ€™s try and we are getting an error so enemy object has no add experience which no enemy and itâ€™s in the level and letâ€™s call it self.exp self.exp and then in my enemy the parameter is called add exp and oh i just forgot add exp okay now letâ€™s try this again there we go and now if i take an enemy there we go and we get some experience trice again there we got another 120 experience and letâ€™s try this one again and we get even more experience and i can also heal and well technically we should have just died but in my case i didnâ€™t really implement the death mechanic because well the game is already getting complex as it is but if you had an actual game this could lead you to an over world or something alright now in our enemy we have the ad experience so we can close enemies and minimize the create map method and add xp as well so all right now with that our player has the experience and we have the data now all we have to figure out is how to increase the stats of our player and for that i want to create a separate menu and that i actually want to do in my main file because in here i have my event loop and what i want to check in here is if event dot type is equal to pygame dot k down so weâ€™re pressing any button and if event dot key is equal to pygame dot k underscore m so my case the m button is the upgrade menu button and if we are pressing that i want to run myself.level and then there i have a method called toggle or i want to create a method so now in my level i can create a toggle method actually letâ€™s call it toggle menu that feels a bit more appropriate so toggle menu and if iâ€™m doing that self dot toggle underscore menu wii itself and nothing else and basically all i want to do i want to create self dot game underscore paused is going to be not self dot game underscore paused and in my init method letâ€™s say all the way in the basic setup self.gamepast by default is going to be false and now what i can do in my run method of this level essentially what i want to do in here is if gamepost is true i want to display the upgrade menu and if that is not the case i want to run the game and now we have to figure out what to draw in here what to draw on here and what to draw all the time so letâ€™s go through it one by one our visible sprites we always want to draw even if the game is paused however we only want to update them if the game is not paused and same with the visible sprites and the enemy update then the attack logic should also be in here but my ui display i always want to display even if the game is paused because there we can see the experience so now we can get rid of all of those and now we have to figure out what to do when the game is paused and for now i just have pass in here and to actually get the full menu i want to create yet another python file and this one i called upgrade dot pi that is actually going to be our final new file so we are getting very close to finishing this project and in here as always we have to import pi game and from settings import everything now i have my class upgrade there is no need for inheritance and in here i want it under init method with self and i want to place the player in here as the parameter and in this method for now i want to have a general set up and first of all we need to display underscore surface thatâ€™s just going to be pygame dot display dot get underscore surface and then self dot player is going to be my player we will need quite a bit more but that comes later the really important thing i want to have for now is a method called display this one doesnâ€™t need any arguments and for now i just want to make sure we can see what we are doing so for now i just want to get myself dot display surface dot fill and letâ€™s say weâ€™re going to fill it with black so whenever we have this menu open weâ€™re going to fill the screen with black and once itâ€™s gone we are not going to fill it so essentially what that means in my level i want to from upgrade import upgrade i believe i called it yep upgrade and now in the innit method all the way down here i guess this is also user interface so self.upgrade is going to be upgrade and this one is going to need self dot player so letâ€™s minimize this one now and now in my run method i want to run self dot upgrade dot display so now we can toggle at least in theory between a menu so in my game we get game paused not defined in my level.run because this should be self dot game paused there we go the game runs now if i press m it goes to black and if we press it again we go back to the same stage actually let me get chased by some enemies now press m and now we return back to the same stage where we were earlier so this is actually a pause mechanic and this keeps on working just fine cool and the reason why this is working is because when our game is paused we are not updating the main part of our game anymore and because of that the game picks up once we are stopping this so this is a nice pause mechanic so all we have to figure out now is how to create a proper menu and that is going to become a slightly longer section so i guess letâ€™s work through it one by one now first of all we need some input and for that again we need keys and pygame dot key dot get underscore pressed and then if keys and pi game dot k underscore right then letâ€™s say for now we just want to pass and l if keys pi game dot k left we want to move left but for now this is going to be passed as well and finally i want to check if keys and pie game thatâ€™s not how you spell that pie game dot k space we also want to pass but this is going to be our select button and letâ€™s spell keys correctly all right so now we have to figure out how to actually implement these mechanics for left and right and let me explain how this is going to work i am basically going to create a selection index and this selection index can be a number between 0 and 5 and that is the amount of stats my player has so once that could be health the other set could be energy and then i have speed attack and magic and then for each of those five iâ€™m going to create a box and each of those boxes is going to be one class so three four five and essentially what iâ€™m then going to do is iâ€™m going to have a selection number that letâ€™s say right now it could be one and if it is one weâ€™re going to select the box with the index number one if it is three weâ€™re going to select this box here so that way when we press left or right we are either increasing or decreasing this number and thatâ€™s then all we need to do okay but for that to work we need a couple of things first of all we need our self dot attribute number and all i really want in here is the length of my player dot stats so the length of in my player i want to get this dictionary and in there i have these different values and i guess while weâ€™re at it i can also get the names so self dot attribute names and this one is just going to be a list with my player.stats and from that i just want to get the keys and finally i am also going to need a font just like we needed one for the ui so self.font and in here we have pygame dot font dot font and now we can use the same font from our ui so ui font and ui font size so ui font and ui font size and that would then be all the basic information we are going to need but besides that we are also going to need letâ€™s call it a selection system and that is the number i just talked about that weâ€™re going to increase from zero to five and this i called self dot selection index and by default itâ€™s going to be zero and since weâ€™re going to move it we are also going to need a timer so self dot selection underscore time by default itâ€™s going to be none and then self dot can underscore move and by default this one is going to be true and now in my keys the most basic thing i want to do is self dot selection index not selection time selection index plus equal one if we are going to the right or minus equal one if we are going to the left but now for the proper timer we also want to set self dot can move to false and self dot selection time is going to be pygame dot time dot get underscore ticks and these two lines we need for both of the movement so in there and there we go and now when we call left and right besides the button we also want to check and self can move so this is basically our basic movement that we have implemented a couple of times by now and now finally we need a selection underscore cool down and this one again itâ€™s just going to be a basic timer so if not self dot can move then i want to get my current underscore time itâ€™s going to be pygm.time.get underscore ticks and then finally if my current time minus myself dot selection time is greater or equal than a certain number um letâ€™s say for this one 30 milliseconds once we have that can move is back to true and now we can get rid of this surface fill and just replace it with self dot input and self dot selection cool down actually letâ€™s do this slightly differently this self dot can move probably makes more sense when we put it as a general one all the way at the top and then check all of the other keys sorry about that this makes more sense because thereâ€™s one more thing that we do have to check so if we are all the way to the right we donâ€™t want to be able to go any further so iâ€™m going to check and self dot selection index is smaller than myself dot attribute number and this one needs to have negative one because of the way we are counting in the length method and then the same thing for left so self dot selection index except this one needs to be greater or equal than one at the very least and now finally we can also start with our space button so in here i also want to run the timer and what i want to do for now is just to print my self dot selection index so at least we have something and letâ€™s try all of this is working i press m the game pauses now if i press space you can see zero in the bottom left if i press right we get to four and if i press down we get back to zero so something with the input doesnâ€™t work just yet and the reason is that this selection index should be selection time now letâ€™s try this again if i press m never press space we just get one if i press to the right we get one result up to four but if i go back we get the numbers that i actually wanted cool so this is working now okay this really is a long tutorial now i can minimize my selection cooldown i donâ€™t need it anymore and for now letâ€™s minimize the input method as well so we can see a bit better whatâ€™s going on now basically what i want to do let me draw this out here we have our entire game window and what i want to do i want to spawn a couple of boxes over this thing five in total and each of these boxes should have some kind of bar on the inside that shows us how much we have and on top we want to have the name of that stat and at the bottom here we want to have the cost and iâ€™m going to create a class for each of these boxes so each of these red boxes is going to be one instance of a class but to be able to do that i first have to figure out a couple of dimensions about the screen so i have to know how wide each of these boxes have to be and how tall they have to be and for that i need to do some math so letâ€™s work on that first and we can do this straight in the init method letâ€™s do it right here so i called the class item and we want to get item dimensions and we need the height we need self dot width as well and height is the easier one i basically want to get myself dot display surface and in here get size and this is going to give us x and y and we only care about y and i am just going to multiply this by 0.8 so we have most of the screen but we are losing about 20 percent so we have a offset essentially now for the width i can actually copy most of this except this one should be zero so we get x and iâ€™m going to divide this by six which is my attribute number plus one so that way i have my five elements and the sixth one or the width of the sixth one is going to be the padding between them and now i can create another method and i call this one create items and for this one we donâ€™t need any arguments and essentially let me create a class right now i want to create a class that i called items or item and each of those is going to be one box that we can upgrade and for this one i need an init method and then here i want the left i want the top i want a width i want a height i want an index so we know what is selected and i want a font so all of this is what we have to figure out in this create items i guess for now let me add pass in here so python doesnâ€™t throw an error okay now first of all i want to store all of these items in the list so letâ€™s call it self dot item underscore list for now itâ€™s just an empty list and now i just want to go for i letâ€™s sorry for item in range self dot attribute number and now i have to figure out the horizontal position i need to figure out the vertical position and then i have to use that to create the object so letâ€™s do the last step first item is going to be my item and in here i want to have a left the top then the width i already have thatâ€™s the one i have up here so self dot with and self dot height then the index weâ€™re also going to get in just a second and then the font we already have thatâ€™s just self dot font so essentially we have to figure out the left the top and the index and once we have all of that i can get myself dot item list dot append and my item now we have to figure out the horizontal and the vertical position and the vertical position is kind of easier so letâ€™s start with this one and here we need the top and right now we know let me draw this actually so if this is the entire height of our game letâ€™s call this h so this is the entire window in specific numbers this would be 12 80. and we know that 80 of this so letâ€™s say roughly this one is going to be our current self.height so this number here so we have 10 here and we have 10 up here now because i want my boxes to start on this line essentially all i really need is 10 of the screen height starting from the top of the screen thatâ€™s the only number i need for the top and this one is really easy to get so i need self dot display surface dot get underscore size i need the y number again and now i have to multiply this by 0.1 i guess you could make this system a bit more flexible by putting these two numbers inside of one variable but iâ€™m not going to worry too much about it but all right with that we have our top now our left unfortunately is going to become a bit more difficult i guess first of all i want to have my full width and this one i can actually copy it is this number here except we want to have zero so right now we know the entire width of our window then i want to know by what increment i want to move to the right and let me actually draw this so right now this here is the entire height of our game so letâ€™s call it h oh and this one is actually 1280. the height before window is 20. the height of our window is 720. uh well i guess you get the idea but anyway this one right now is 1280 pixels wide and this is what i got with full width and now what i essentially want to get is i want to have a bit of an offset from the left and then i want to have my first element so letâ€™s start here with the left of the first element the first element should then go letâ€™s say roughly to here and then i want to have a bit further to the right another element and this should then be the left of the second element or i guess to be a bit more specific this should be the index zero and this should be the index one that is a bit easier to comprehend and this number is then going to be the increment itâ€™s basically the distance from the left to get the left side of each item and this number i basically get with my full width divided by myself attribute number so right now we are splitting the entire window into five different parts and with all of the information i can get my left so now all i have to do is i want to get my current item number so this could be either 0 1 2 and so on and multiply this by my increment and then to whatâ€™s that i want to get my increment and from that subtract my self.width of each of the items and floor divide this by two and that way we are offsetting each of the elements a little bit further to the left and well with that we have our left side now finally i need the current index and the best way to get the index is just to use the enumerate method and then we get item and index so with that we have the basic setup to create each of these items and letâ€™s actually draw them so we see whatâ€™s going on i know itâ€™s getting a bit theoretical so basically what i want to do in the init i first of all want to create a self dot rect and this is just going to be a pygame dot rect and then here we can just pass in left top width and height and besides that i also want to get myself dot index and that is going to be the index and i want to get myself dot font and thatâ€™s going to be the font and now each of these items is going to have their own display method and for this one besides self we need the surface to draw on so our display surface then we need this selection underscore num so what our currently selected item is so we can highlight it and then we need the values we actually want to display so be aware the item is essentially a box that could display any kind of information whatever we pass in so we actually have to pass in our stats so i want to have a name a value a max value and a cost and these are the informations i want to draw now that we have all of that for now letâ€™s just draw some basic thing all i want to do is pygame.draw.rect and we get the surface from the parameters then for the colors for now i just want the background color from my settings oh actually in my settings we need to import a bit more information because in here the upgrade menu has its own colors so finally a tiny bit more this is the last bit we need but for the background i just want to have the ui bg color so letâ€™s copy this one and paste it in here and finally self.wrecked the one we created up here here so for now weâ€™re just drawing a basic rectangle to see if something is going on in the first place and now finally for my display i can just draw all of them so i can for item in self dot item list i can do something but first of all i forgot to actually call self.createitems and letâ€™s do it below this one so self.create items and letâ€™s call this section just item creation okay we are nearly done sorry this section gets a bit more complex itâ€™s kind of hard to visualize but now in my for loop i just want to get item dot display and here we need the different arguments so we need all of these arguments let me copy them so surface is going to be myself dot display surface selection number for now weâ€™re not going to care about it itâ€™s going to be 0. name letâ€™s say for now we can just write test for value itâ€™s going to be 1 max values letâ€™s say 2 and cost 3. these numbers for note donâ€™t matter i just want to see if this is working in the first place but now we should see something so letâ€™s try to run main.pi and press m and there we go we can see our five different boxes so at the very least this is working and iâ€™m fully aware that the logic here is getting a bit more complex so i would recommend you to go over this if youâ€™re struggling with this so especially to create items can be a bit finicky but well letâ€™s continue with what we have now the first thing i want to do is to actually display the names of what we are dealing with so for now i want to show the name of the attributes and i guess what we added we can show the cost and for that to work we have to letâ€™s call it get attributes and we will need the name we will need the value we will need the max value and finally we will need the cost and since we also have to figure out what the index of each number is i also want to put item list in an enumerate method so this should be index and item and now letâ€™s work for them one by one first of all the name we already have in our attribute names so in here all i really have to do is get myself dot attribute names and then select the index for the values i need to get myself.player and for this one i want to write another method in the player that i called getvalue by index and this oneâ€™s going to get the index weâ€™re going to write that in just a second now for the max values i want to get them right at the top here because those donâ€™t change so in here self dot letâ€™s call it max values and to get this one itâ€™s supposed to be a list and i want to get my player.max stats i think i called it it is mac stats here and from this one i want to get the values so now for my max value i can just look at myself.max values and pick the one by the right index and finally for the cost this one also i want to get myself dot player and then get cost by index and we want to pass in the index all right and now in the player letâ€™s create those two methods and let me actually copy them so it saves me a bit of writing and letâ€™s write them right below the other two getter methods so we have get value by index self and index and then let me copy all of this and get cost by index and in here i essentially want to return just the value for each specific value in our stats so essentially i want to get my current value from this list here or this dictionary rather and all we have to return is first of all we need a list with our self dot stats dot values and from that i want to select the index and thatâ€™s really all we need itâ€™s not a particularly complex one and now i can copy this and now instead of stats i want to look at my upgrade cost so this way we also get our current index right in here with just one line of code and now all we have to do is to pass all of this information in the display method so first of all the surface we still have and now for the selection number i want to pass in myself dot selection index then next up we have my name and this can just be name then we have the value thatâ€™s going to be value then we have max value and then we have the cost so letâ€™s check if this is the working weâ€™re not getting an error message thatâ€™s at the very least a good sign so now we are passing in all the information we need in here so let me for now hide the upgrade menu weâ€™re not going to need it for a while so essentially all i have to do now is create a couple of methods to display the different things first of all i want to write display underscore names and then here we need self we again need the surface to draw on then we need the name and we need the cost and i also want to check if this is the currently selected box and in here we are going to create the title text and we are going to create the cost text and then at the end once we have created them we are going to draw everything so letâ€™s create the title first and then here i just want to create a title surface this one is going to be self dot font dot render and what we want to render is the name we already have and since weâ€™re drawing pixel art i donâ€™t want to anti-aliasing and now we are going to need a color and the color i am getting from my settings and in here we have a text color so letâ€™s pass this in here and then besides the surface we need a title rect and what i want to do is to get my title surface get wrecked and now the mid top should be where myself dot rekt dot mid top is and from that i want to give it an offset so pygame dot math dot vector 2 we want 0 offset in x and in my case 20 pixels in the y direction and with that we can get our surface and blit and create a title surface and the title rectangle so now in my display method i can run self dot display names and then here pass in the surface we already have then we want the name we want the cost and letâ€™s say selected for now is going to be false weâ€™re going to change that later on okay and letâ€™s try this if i press m we are getting an error because get rekt here should not be capitalized and now letâ€™s try this again there we can now see health energy attack magic and speed this is working really well and now besides that i also want to display the cost and this could be a good exercise for you so just like the title try to display the cost except now the cost should be at the bottom of each of the bars right first of all i want to create a cost surface going to be self.font.render again and in here i want to draw my cost but my cost right now is a number so iâ€™m going to turn this into an f string and there is a chance that my cost might become a floating point number so iâ€™m also going to convert it into an integer but besides that we can just copy the other arguments from my title surface and now once we have that we need our cost rect and our cost serve dot get underscore rect and this time i want to place my mid bottom and itâ€™s going to be myself dot rect dot mid bottom except with an offset so pygame.math.vector2 and 0 and 20. although now be aware we are subtracting that vector without increasing like in the upper one and now all we have to do is surface dot blit we need my cost surface and cost and that should be all we needed letâ€™s try now and there again we can see our cost now thereâ€™s one more thing that we do have to do and that is to work with this selected and essentially what i want to do is in my upgrade i have a selection index and if the selection index and the index of each item is identical then i want to highlight this and actually let me illustrate this this might be slightly confusing so this right now is our entire window and in here we have a couple of bars letâ€™s do all of them so here we have five and each of those has an index thatâ€™s the index we created just here and there are zero one two three and four and besides that i also have a selection index and this one could be anything between zero to four and this is also the number we can influence with our keyboard input and essentially what i want to do if for example our selection index is a 1 then i want to highlight this box here and if itâ€™s letâ€™s say a 4 i want to highlight this box here so whenever the index of our item is the same as our selection index then i know i want to highlight this box and i can change some colors thatâ€™s the entire idea here and i have both available in my class actually so this selection number is our selection index so the one we are passing in here and essentially all i have to do is if myself dot index is identical with the selection number i think i called it yeah selection number if that is the case we should be drawing something in a highlighted way and weâ€™re going to use this later but for now letâ€™s add pass in here and what we can also do is copy all of this and pass this in here for the true or false argument so this comparison can become either true or false so now that this selected here gives us either a true or false statement we can use that to influence the color and we have two different colors in our settings so we have the text color and text color selected so now if my text color is selected i basically want to do i have text color selected if selected is true and if that is not the case so else i just want to have my text color and now i can pass in color for both of the text colors and we should be good to go letâ€™s try this so now i press m and now my health and my health cost are darker if i press to the right we now have other fields selected and this is working quite well now obviously right now this is very hard to see but later on we are also going to change the background color for each of these items so itâ€™s going to be easier to see but for now this is working quite well i guess we can actually do it right now so if this if statement here is true we want to draw a selected color and if itâ€™s not true we just want to draw the regular background rectangle and i guess while weâ€™re at it i can duplicate this one because we also want to have a border color so i want 4 for the width and now for the border color i have ui border color and back in my upgrade i can change this one and letâ€™s try if this is working and yeah this looks pretty good oh now you can even tell weâ€™re not drawing any background for the currently selected item not ideal but it does look kind of funny but we can change this quite easily by just copying those two and putting them in here and now in my settings we have upgrade bg selected that we can place in here and ui border color actually stays the same so now letâ€™s try this and i press m and there we go this is looking really nice so with that we can properly see which one is selected what we have to do next is create another method and this is going to self dot display letâ€™s call it the bar and this is going to be the upgrade bar and then here letâ€™s actually create the method because this one also needs a couple of parameters so display underscore bar self as always we need a surface then we need our value we will need a max value and we need to know if this one is selected or not because that will change the color and now letâ€™s talk about what we have to do this one here is going to be one of the items and inside of each item i want to have a bar and inside of each bar we have the name and the cost that one doesnâ€™t matter right now but now what i want to do is to place a line in here and on this line we have a rectangle that shows us how much the player currently has in this skill and this one can go all the way to the max level and actually let me leave this one up here right now might be kind of helpful and let me spell properly this should be display bar now first of all we need some letâ€™s call it drawing set up and in here we want to know what the top and the bottom and i guess also the color of this bar is going to be so right now we just want to know what is the top and what is the bottom of this bar going to be is going to be self.wrecked.mid top and then i want to give this one an offset so plus pi game dot math dot vector vector 2 and 0 and 60. so weâ€™re going down a tiny bit and then for the bottom we can do something fairly similar except now we look at the mid bottom and we are subtracting in the y axis and for the color we have in our settings bar color and bar color selected so i want to have bar colors selected if selected and if that is not the case i just want to have the normal bar color and i guess we can actually already draw this line so draw elements and essentially what i want to do is pie game.draw.line and this one first of all is going to the surface and the surface we have from our parameters besides that we need a color this one we also have and then we need a top and a bottom also elements that we have so all of the stuff we just created so now i can actually call my bar so let me copy all the parameters again my surface is going to be my surface again my value we already have my max value we also have and selected is going to be the same thing we got from earlier so now this should be working letâ€™s try and there we can see we have a line although it is very very thin and the reason why it is so thin is because i didnâ€™t set a border width by that we can add with another argument and letâ€™s give it a width of five and now letâ€™s try this again there we go this fits better and this is looking pretty good so now what i essentially want to do is to place a rectangle somewhere on here to illustrate how much of this value my player currently has so we have to get letâ€™s call it a bar set up and first of all i need to know the full height of this thing and that is just going to be bottom and be aware my bottom right now has an x and a y position and i only care about the y one and from that i want to subtract my top and i also want just the y position and be aware here the origin of our window is in the top left so the bottom one is the higher number which is why we are subtracting top from bottom but all right now i want to have the relative number this right now is the value that i currently have divided by the max value so let me add a bit of space letâ€™s say right now in my init method theyâ€™re my stats so if my health is 100 and my max health is 300 i want this bar to be at one third of the maximum amount and this is exactly what we are doing here so this is going to give us something like 0.3 and this then i just want to multiply with the full height to turn this into a pixel measurement and now i can create letâ€™s call it a value rectangle and this is going to be pygame dot rect and this one does need to be capitalized and in here we need left we need top we need a width and we need a height and for the width and height i just went with 30 and 10. fairly random numbers i just went with what looked good now for the left i just went with either top or bottom doesnâ€™t matter they have the same position anyway and i went with zero so this is going to give me the x of the top and from that iâ€™m going to subtract 15 which is half of my width and then the top is going to be the bottom of my bar so one and from that iâ€™m going to subtract the relative number so just to illustrate whatâ€™s happening here if this is our entire bar then bottom one this bit here is this point all the way at the bottom and then the relative number is going to be however much of a gap that is from the bottom so this way our bar would be here ish and all right with that we have something to draw so pygmy.draw.rect i again want the surface the color and this time i want to draw a value rectangle and now letâ€™s try this and this is looking pretty good with that we only need to figure out how to actually increase any of these values and for that i have another method and this i called trigger and trigger needs self and player and we first of all have to figure out how to actually call this thing and this is going to happen let me minimize all of these methods this is going to happen essentially in here so right now weâ€™re just printing our selection index it doesnâ€™t really do anything right now instead i want to call this trigger inside of my item and we can minimize quite a few different things so itâ€™s a bit easier to see that is feeling slightly better i guess ah there we go okay essentially i want to get the trigger from my item list in here so i first of all want to get myself dot item list and from that thing i want to get myself dot selection index and this one then i want to call the trigger method on and pass in self.player and now in this trigger method we can get the first of all letâ€™s call it the upgrade attribute and this we get with player dot stats dot keys turn all of this into a list and once we have that we can use self dot index to get one specific value and index will always be the same for each item and i guess for now letâ€™s just print our upgrade attribute so we know this is working so back in here i can press space on health we get health energy attack magic and speed so this way we know which element we are selecting now besides that we have to first figure out if the player has enough experience to upgrade this certain kind of value so i want to check if my player.exp is greater or equal then my player dots upgrade underscore cost it was called so in my player we have upgrade cost so upgrade cost and i am only caring about my upgrade attribute and now once i have that and that is actually true i want to get my player.exp minus equal player dot upgrade cost again and get my upgrade attribute so now we are lowering dxp and then for my player.stats now we can finally upgrade something yep we have my upgrade attribute and in my case iâ€™m just going to multiply each value by 1.2 and what iâ€™m also going to do every time we are upgrading a certain part i want to increase my upgrade cost by 1.4 so we get increasingly more value and it becomes even more expensive every time we upgrade and now actually letâ€™s try this so now if i press space on health we get 140 and our experience did go down so now we get to 64 and we canâ€™t press this anymore because we donâ€™t have enough experience and letâ€™s actually try to destroy some enemies okay this should be enough now our health still stays at 274 and i can press space again and now we get even more health cool this is working really well and i can still heal up and all of this is working really nicely so with that we have some basic upgrade mechanic now thereâ€™s one more thing we do have to do and that is if our current value exceeds the maximum value i donâ€™t want that to be possible so if player dot stats and we want to check my upgrade attribute is greater than my player dot max stats and again my upgrade attribute and if that is the case i just want to set those two equal to each other and i guess what we could also do is in here we only allow the player to upgrade if my player stats is lower than my max stats i guess just another safeguard canâ€™t hurt to have those and all right with that we have a trigger and i guess we can test this so in my player iâ€™m going to give the experience of 5000. now in the game i can upgrade i guess my attack is the highest one right now i can increase this to well the maximum and we canâ€™t go any further so seems to work just fine and alright with that we have our upgrade menu thereâ€™s one more thing i do have to do because in my player so far we had self.speed but we donâ€™t really upgrade this after we upgrade so after unit method this self.speed is not being used anymore so i can get myself.speed and now all the way in my update method i donâ€™t want to use self.speed i want to use self.stats.speed and now in my game this is how we move by default and if i increase my speed all the way to the top we are moving significantly faster so we know the upgrades actually do something in the game cool except iâ€™m still terrible at my own game but never mind and that was the last major section in the game thereâ€™s only one more thing we have to do well two things we have to add the sound and there are some tiny details i do want to change but letâ€™s talk about them in their own section the first one is to fix a couple of smaller issues that are annoying me they are mostly visual and once we have that we are going to work on the audio and essentially what i want to do in my game in terms of visuals that in the original i had an offset for each individual object so the trees and the grass for example had different kinds of offset because they have different sizes and this i forgot earlier so i did want to include it and besides that right now if we walk too far to the right of our map we can see the black background which looks a bit weird actually let me illustrate all of this straight in the code and then we can work on it so here we are in the game and if i run this and move all the way to the right letâ€™s go all the way here i think you can see it there you can see the background is just black which looks kind of weird and for this or well the reason is we have a black background color but in my settings we have a watercolor and this i just want to copy in here and we have our settings available so this watercolor is the same color as the water thatâ€™s why itâ€™s called watercolor and well now if i run this we can go back here and now we can see only water so this looks a bit better although admittedly the water does look a bit boring but well we are at least getting a decent color so now besides that in my settings i also want to add another entry letâ€™s put it all the way up here and that is called hitbox offset and in here we have one for the player one for the object one for grass and one for invisible tiles so letâ€™s actually go through them and in my player let me minimize everything again in the init method here we have our hitbox and there we already have the 26 so we could leave it as it is but just to have everything in the settings let me call the hitbox offset and in there i want to get the key player and what i also want to do is just for the player i want to reduce the hitbox for the x dimension as well although not by much letâ€™s say by 6. and letâ€™s try this and with this it becomes a bit easier for our player to move through smaller gaps so especially here well itâ€™s kind of hard to see but with our player being a bit less wide it does make it easier to move around not a major change but it does make the game feel significantly better okay with that then we have to work through the appetites so we have the player now we need the object and the grass and all of this happened in my tile this one here and in here we are getting our hitbox all the way at the bottom and this one can change depending on if we have grass or an object so i want to put this in a separate variable letâ€™s call it y offset and in here weâ€™re just going to use hitbox offset and then we have a sprite type so sprite type we are getting from our level and we are getting it from create map and in here we have grass and we have object so weâ€™re passing them in here or in here so this is how we then get the y offset and now we can just get the y offset and paste it in our inflate method to get the hitbox and that way we have quite a larger offset for the trees so the objects get minus 40 and the grass only negative 10. so this is now going to make it drastically easier to move around because we can move much further behind the trees and this means that when we work for the forest things are much better in terms of movement so this feels considerably better for the movement and that is kind of all i wanted for the basic movement oh and i actually forgot in my settings thereâ€™s also invisible and invisible we get from our boundary tiles and they also work in here with the sprite type so this tile class actually pulls a ton of weight but all right so with that we have a couple of fixes that i really wanted to add that make our game feel surprisingly better but now that we have that all we have to do is add sound and then we are done and okay i guess we can go through it step by step add the different sound effects and all the way at the end we add the soundtrack for the game so letâ€™s go through it step by step first and i guess we can start with the player that one probably has the most common sounds so here we have the player and in my indian method i want to import his sound and all i want for the player is self dot weapon attack sound and this one we get with pygame dot mixer dot sound and in here we need a path we have to go up out of the folder then into audio and then we have sword dot wav and one thing i also want to do is for my attack sound i want to set the volume to 40 of what it is that way itâ€™s not getting too annoying and now in my input method whenever i have my attack input i also want to call self dot weapon attack sound and play it and that should be all we need for this one sound letâ€™s try it now and seems working just fine now next up we can add some sound to the magic because in there in my init method i want to have letâ€™s call it self.sounds and this is going to be a dictionary and here we want to have a sound for heal and another sound for the flame and in here i want to run pygame dot mixer dot sound and we have to go up a folder then to audio and then to heal dot wav now i can copy all of this and paste it in here except now we want flame and i guess if you want to make this a bit more elegant you could paste these sounds or the path to these sounds into this magic data i have actually done this for the sounds for the attacks but in our case the magic sounds are so few it doesnâ€™t really matter all right now when we are playing the health effect we can somewhere in there round self dot sounds call heal and then lay it and then we can do the same thing oh and we have to reactivate the energy cost for the flame effect and while we had added we can add the flame sound and now letâ€™s try this so we are getting an error that audioflame.wlv was not found letâ€™s have a look so i couldnâ€™t find this one because the file was called fire.wav now letâ€™s try this again and that looks better attack still works and now the name works and magic also works just fine cool so with that we can close the magic file and not worry about it anymore then next up i have my enemy sounds and that is going to be in the enemies letâ€™s open that file enemies enemy enemy and in here just in the init method i want to have a sound section and we essentially have two sounds self dot def sound this one is going to be pygame dot mixer dot sound and i want to have my fold up then my audio and then here we have def dot wav now i can copy all of this and i have a hit sound and this one is called hit.wav and now for both of these self dot def sound i want to set the volume a tiny bit lower to 0.2 and the same for the hit sound and now we just have to figure out where to call them and the death sound is the easier one actually let me minimize all of the methods this code is really getting extensive so in my check dev if this is true i want to call self.def thatâ€™s not how you spell that deathsound.play thatâ€™s the first one and the other one we want to play when we get to get damage down here so in get damage we want to play this once self dot hit sound dot play and that should be all we need so letâ€™s try this that feels pretty good now for the enemy again thereâ€™s one more sound we have to import and letâ€™s put it right here as well actually letâ€™s put it right here so in my settings we have one more sound this attack sound for each of the different attack types so self dot letâ€™s call it the attack sound and this one is going to be pygame dot mixer dot sound again and in here i want to have first of all the entire dictionary so my monster data and in here i first of all need to get my monster info i think i called it so in here we get the entire dictionary so the dictionary we get is this one for example for the squid and in there we want to pick the attack sound string and this one we can just get by indexing and i also want to reduce self dot attack sound dot set volume and this one i set to 0.3 and now we just have to figure out when to play it and this happens in my actions so in here if the status is attack my enemy is attacking so what i can do is self dot attack sound dot play and now this should be working so letâ€™s try this one and i can edit here the bamboo enemies i can hear all of the enemies and there certainly is some sound cool seems to be working so the final thing in this entire project is going to be in my main file where we start playing the sound so right here in the init method of my game i want to have sound and iâ€™m going to import main sound and i am importing pygame dot mixer dot sound and in here we have a string we go one fold up we go to audio and thereâ€™s a file in there called main dot o g g and this main sound i want to play and in here importantly we want to determine the loops they should be -1 so we are playing this continuously now letâ€™s try this [Music] all right now i think the one thing i do want to do is main sound dot set underscore volume and set this to something like 0.5 itâ€™s probably a touch loud right now [Music] and [Music] okay this one feels better i guess in terms of fine tuning the enemy sound effects feel a bit quiet so letâ€™s set those to 0.6 and letâ€™s see how that feels [Music] and yeah this is feeling much better and all right with that we are actually done i think that covers the entire game so thank you so much for sticking around if you actually managed to get all the way to the end of this project i hope you got something out of it and well iâ€™ll see you around</p>
]]></content>
  </entry>
</search>
